# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/openssl/all/openssl.rbi
#
# openssl-3.2.0

module OpenSSL
  def Digest(name); end
  def debug; end
  def debug=(arg0); end
  def errors; end
  def fips_mode; end
  def fips_mode=(arg0); end
  def self.Digest(name); end
  def self.debug; end
  def self.debug=(arg0); end
  def self.errors; end
  def self.fips_mode; end
  def self.fips_mode=(arg0); end
  def self.fixed_length_secure_compare(arg0, arg1); end
  def self.secure_compare(a, b); end
end
class OpenSSL::BN
  def %(arg0); end
  def *(arg0); end
  def **(arg0); end
  def +(arg0); end
  def +@; end
  def -(arg0); end
  def -@; end
  def /(arg0); end
  def <<(arg0); end
  def <=>(arg0); end
  def ==(arg0); end
  def ===(arg0); end
  def >>(arg0); end
  def abs; end
  def bit_set?(arg0); end
  def clear_bit!(arg0); end
  def cmp(arg0); end
  def coerce(arg0); end
  def copy(arg0); end
  def eql?(arg0); end
  def gcd(arg0); end
  def get_flags(arg0); end
  def hash; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def lshift!(arg0); end
  def mask_bits!(arg0); end
  def mod_add(arg0, arg1); end
  def mod_exp(arg0, arg1); end
  def mod_inverse(arg0); end
  def mod_mul(arg0, arg1); end
  def mod_sqr(arg0); end
  def mod_sqrt(arg0); end
  def mod_sub(arg0, arg1); end
  def negative?; end
  def num_bits; end
  def num_bytes; end
  def odd?; end
  def one?; end
  def pretty_print(q); end
  def prime?(*arg0); end
  def prime_fasttest?(*arg0); end
  def rshift!(arg0); end
  def self.generate_prime(*arg0); end
  def self.pseudo_rand(*arg0); end
  def self.pseudo_rand_range(arg0); end
  def self.rand(*arg0); end
  def self.rand_range(arg0); end
  def set_bit!(arg0); end
  def set_flags(arg0); end
  def sqr; end
  def to_bn; end
  def to_i; end
  def to_int; end
  def to_s(*arg0); end
  def ucmp(arg0); end
  def zero?; end
  include Comparable
end
class OpenSSL::Cipher
  def auth_data=(arg0); end
  def auth_tag(*arg0); end
  def auth_tag=(arg0); end
  def auth_tag_len=(arg0); end
  def authenticated?; end
  def block_size; end
  def ccm_data_len=(arg0); end
  def ciphers; end
  def decrypt(*arg0); end
  def encrypt(*arg0); end
  def final; end
  def initialize(arg0); end
  def initialize_copy(arg0); end
  def iv=(arg0); end
  def iv_len; end
  def iv_len=(arg0); end
  def key=(arg0); end
  def key_len; end
  def key_len=(arg0); end
  def name; end
  def padding=(arg0); end
  def pkcs5_keyivgen(*arg0); end
  def random_iv; end
  def random_key; end
  def reset; end
  def self.ciphers; end
  def update(*arg0); end
end
class OpenSSL::Config
  def [](arg0); end
  def each; end
  def get_value(arg0, arg1); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def inspect; end
  def sections; end
  def self.load(*, **); end
  def self.parse(arg0); end
  def self.parse_config(arg0); end
  def to_s; end
end
class OpenSSL::Digest < Digest::Class
  def <<(arg0); end
  def block_length; end
  def digest_length; end
  def finish(*arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def name; end
  def reset; end
  def self.digest(name, data); end
  def update(arg0); end
end
class OpenSSL::HMAC
  def <<(arg0); end
  def ==(other); end
  def base64digest; end
  def digest; end
  def hexdigest; end
  def initialize(arg0, arg1); end
  def initialize_copy(arg0); end
  def inspect; end
  def reset; end
  def self.base64digest(digest, key, data); end
  def self.digest(digest, key, data); end
  def self.hexdigest(digest, key, data); end
  def to_s; end
  def update(arg0); end
end
class OpenSSL::Netscape::SPKI
  def challenge; end
  def challenge=(arg0); end
  def initialize(*arg0); end
  def public_key; end
  def public_key=(arg0); end
  def sign(arg0, arg1); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(arg0); end
end
class OpenSSL::PKCS12
  def ca_certs; end
  def certificate; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def key; end
  def self.create(*arg0); end
  def to_der; end
end
class OpenSSL::PKCS7
  def add_certificate(arg0); end
  def add_crl(arg0); end
  def add_data(arg0); end
  def add_recipient(arg0); end
  def add_signer(arg0); end
  def certificates; end
  def certificates=(arg0); end
  def cipher=(arg0); end
  def crls; end
  def crls=(arg0); end
  def data; end
  def data=(arg0); end
  def decrypt(*arg0); end
  def detached; end
  def detached=(arg0); end
  def detached?; end
  def error_string; end
  def error_string=(arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def recipients; end
  def self.encrypt(*arg0); end
  def self.read_smime(arg0); end
  def self.sign(*arg0); end
  def self.write_smime(*arg0); end
  def signers; end
  def to_der; end
  def to_pem; end
  def to_s; end
  def type; end
  def type=(arg0); end
  def verify(*arg0); end
end
class OpenSSL::PKCS7::SignerInfo
  def initialize(arg0, arg1, arg2); end
  def issuer; end
  def serial; end
  def signed_time; end
end
class OpenSSL::PKCS7::RecipientInfo
  def enc_key; end
  def initialize(arg0); end
  def issuer; end
  def serial; end
end
module OpenSSL::PKey
  def generate_key(*arg0); end
  def generate_parameters(*arg0); end
  def new_raw_private_key(arg0, arg1); end
  def new_raw_public_key(arg0, arg1); end
  def read(*arg0); end
  def self.generate_key(*arg0); end
  def self.generate_parameters(*arg0); end
  def self.new_raw_private_key(arg0, arg1); end
  def self.new_raw_public_key(arg0, arg1); end
  def self.read(*arg0); end
end
class OpenSSL::PKey::PKey
  def compare?(arg0); end
  def decrypt(*arg0); end
  def derive(*arg0); end
  def encrypt(*arg0); end
  def initialize; end
  def initialize_copy(arg0); end
  def inspect; end
  def oid; end
  def private_to_der(*arg0); end
  def private_to_pem(*arg0); end
  def public_to_der; end
  def public_to_pem; end
  def raw_private_key; end
  def raw_public_key; end
  def sign(*arg0); end
  def sign_raw(*arg0); end
  def to_text; end
  def verify(*arg0); end
  def verify_raw(*arg0); end
  def verify_recover(*arg0); end
end
class OpenSSL::PKey::RSA < OpenSSL::PKey::PKey
  def d; end
  def dmp1; end
  def dmq1; end
  def e; end
  def export(*arg0); end
  def initialize(*arg0); end
  def iqmp; end
  def n; end
  def p; end
  def params; end
  def private?; end
  def private_decrypt(data, padding = nil); end
  def private_encrypt(string, padding = nil); end
  def public?; end
  def public_decrypt(string, padding = nil); end
  def public_encrypt(data, padding = nil); end
  def public_key; end
  def q; end
  def self.generate(size, exp = nil, &blk); end
  def self.new(*args, &blk); end
  def set_crt_params(arg0, arg1, arg2); end
  def set_factors(arg0, arg1); end
  def set_key(arg0, arg1, arg2); end
  def sign_pss(*arg0); end
  def to_der; end
  def to_pem(*arg0); end
  def to_s(*arg0); end
  def translate_padding_mode(num); end
  def verify_pss(*arg0); end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::PKey::DSA < OpenSSL::PKey::PKey
  def export(*arg0); end
  def g; end
  def initialize(*arg0); end
  def p; end
  def params; end
  def priv_key; end
  def private?; end
  def pub_key; end
  def public?; end
  def public_key; end
  def q; end
  def self.generate(size, &blk); end
  def self.new(*args, &blk); end
  def set_key(arg0, arg1); end
  def set_pqg(arg0, arg1, arg2); end
  def syssign(string); end
  def sysverify(digest, sig); end
  def to_der; end
  def to_pem(*arg0); end
  def to_s(*arg0); end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::PKey::DH < OpenSSL::PKey::PKey
  def compute_key(pub_bn); end
  def export; end
  def g; end
  def generate_key!; end
  def initialize(*arg0); end
  def p; end
  def params; end
  def params_ok?; end
  def priv_key; end
  def private?; end
  def pub_key; end
  def public?; end
  def public_key; end
  def q; end
  def self.generate(size, generator = nil, &blk); end
  def self.new(*args, &blk); end
  def set_key(arg0, arg1); end
  def set_pqg(arg0, arg1, arg2); end
  def to_der; end
  def to_pem; end
  def to_s; end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::PKey::EC < OpenSSL::PKey::PKey
  def check_key; end
  def dh_compute_key(pubkey); end
  def dsa_sign_asn1(data); end
  def dsa_verify_asn1(data, sig); end
  def export(*arg0); end
  def generate_key!; end
  def generate_key; end
  def group; end
  def group=(arg0); end
  def initialize(*arg0); end
  def private?; end
  def private_key; end
  def private_key=(arg0); end
  def private_key?; end
  def public?; end
  def public_key; end
  def public_key=(arg0); end
  def public_key?; end
  def self.builtin_curves; end
  def self.generate(arg0); end
  def to_der; end
  def to_pem(*arg0); end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::PKey::EC::Group
  def ==(arg0); end
  def asn1_flag; end
  def asn1_flag=(arg0); end
  def cofactor; end
  def curve_name; end
  def degree; end
  def eql?(arg0); end
  def generator; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def order; end
  def point_conversion_form; end
  def point_conversion_form=(arg0); end
  def seed; end
  def seed=(arg0); end
  def set_generator(arg0, arg1, arg2); end
  def to_der; end
  def to_pem; end
  def to_text; end
end
class OpenSSL::PKey::EC::Point
  def ==(arg0); end
  def add(arg0); end
  def eql?(arg0); end
  def group; end
  def infinity?; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def invert!; end
  def make_affine!; end
  def mul(*arg0); end
  def on_curve?; end
  def set_to_infinity!; end
  def to_bn(conversion_form = nil); end
  def to_octet_string(arg0); end
end
module OpenSSL::Random
  def load_random_file(arg0); end
  def random_add(arg0, arg1); end
  def random_bytes(arg0); end
  def seed(arg0); end
  def self.load_random_file(arg0); end
  def self.random_add(arg0, arg1); end
  def self.random_bytes(arg0); end
  def self.seed(arg0); end
  def self.status?; end
  def self.write_random_file(arg0); end
  def status?; end
  def write_random_file(arg0); end
end
class OpenSSL::SSL::Session
  def ==(arg0); end
  def id; end
  def initialize(arg0); end
  def initialize_copy(arg0); end
  def time; end
  def time=(arg0); end
  def timeout; end
  def timeout=(arg0); end
  def to_der; end
  def to_pem; end
  def to_text; end
end
class OpenSSL::SSL::SSLContext
  def add_certificate(*arg0); end
  def alpn_protocols; end
  def alpn_protocols=(arg0); end
  def alpn_select_cb; end
  def alpn_select_cb=(arg0); end
  def ca_file; end
  def ca_file=(arg0); end
  def ca_path; end
  def ca_path=(arg0); end
  def cert; end
  def cert=(arg0); end
  def cert_store; end
  def cert_store=(arg0); end
  def ciphers; end
  def ciphers=(arg0); end
  def ciphersuites=(arg0); end
  def client_ca; end
  def client_ca=(arg0); end
  def client_cert_cb; end
  def client_cert_cb=(arg0); end
  def ecdh_curves=(arg0); end
  def enable_fallback_scsv; end
  def extra_chain_cert; end
  def extra_chain_cert=(arg0); end
  def flush_sessions(*arg0); end
  def freeze; end
  def initialize(version = nil); end
  def key; end
  def key=(arg0); end
  def keylog_cb; end
  def keylog_cb=(arg0); end
  def max_version=(version); end
  def min_version=(version); end
  def npn_protocols; end
  def npn_protocols=(arg0); end
  def npn_select_cb; end
  def npn_select_cb=(arg0); end
  def options; end
  def options=(arg0); end
  def renegotiation_cb; end
  def renegotiation_cb=(arg0); end
  def security_level; end
  def security_level=(arg0); end
  def servername_cb; end
  def servername_cb=(arg0); end
  def session_add(arg0); end
  def session_cache_mode; end
  def session_cache_mode=(arg0); end
  def session_cache_size; end
  def session_cache_size=(arg0); end
  def session_cache_stats; end
  def session_get_cb; end
  def session_get_cb=(arg0); end
  def session_id_context; end
  def session_id_context=(arg0); end
  def session_new_cb; end
  def session_new_cb=(arg0); end
  def session_remove(arg0); end
  def session_remove_cb; end
  def session_remove_cb=(arg0); end
  def set_minmax_proto_version(arg0, arg1); end
  def set_params(params = nil); end
  def setup; end
  def ssl_timeout; end
  def ssl_timeout=(arg0); end
  def ssl_version=(meth); end
  def timeout; end
  def timeout=(arg0); end
  def tmp_dh=(arg0); end
  def tmp_dh_callback; end
  def tmp_dh_callback=(arg0); end
  def verify_callback; end
  def verify_callback=(arg0); end
  def verify_depth; end
  def verify_depth=(arg0); end
  def verify_hostname; end
  def verify_hostname=(arg0); end
  def verify_mode; end
  def verify_mode=(arg0); end
end
class OpenSSL::SSL::SSLSocket
  def accept; end
  def accept_nonblock(*arg0); end
  def alpn_protocol; end
  def cert; end
  def cipher; end
  def client_ca; end
  def client_cert_cb; end
  def connect; end
  def connect_nonblock(*arg0); end
  def context; end
  def export_keying_material(*arg0); end
  def finished_message; end
  def hostname; end
  def hostname=(arg0); end
  def initialize(*arg0); end
  def io; end
  def npn_protocol; end
  def peer_cert; end
  def peer_cert_chain; end
  def peer_finished_message; end
  def pending; end
  def post_connection_check(hostname); end
  def self.open(remote_host, remote_port, local_host = nil, local_port = nil, context: nil); end
  def session; end
  def session=(arg0); end
  def session_get_cb; end
  def session_new_cb; end
  def session_reused?; end
  def ssl_version; end
  def state; end
  def stop; end
  def sync_close; end
  def sync_close=(arg0); end
  def sysclose; end
  def sysread(*arg0); end
  def sysread_nonblock(*arg0); end
  def syswrite(arg0); end
  def syswrite_nonblock(*arg0); end
  def tmp_dh_callback; end
  def tmp_key; end
  def to_io; end
  def using_anon_cipher?; end
  def verify_result; end
  include OpenSSL::Buffering
  include OpenSSL::SSL::SocketForwarder
end
class OpenSSL::Timestamp::Response
  def failure_info; end
  def initialize(arg0); end
  def status; end
  def status_text; end
  def to_der; end
  def token; end
  def token_info; end
  def tsa_certificate; end
  def verify(*arg0); end
end
class OpenSSL::Timestamp::TokenInfo
  def algorithm; end
  def gen_time; end
  def initialize(arg0); end
  def message_imprint; end
  def nonce; end
  def ordering; end
  def policy_id; end
  def serial_number; end
  def to_der; end
  def version; end
end
class OpenSSL::Timestamp::Request
  def algorithm; end
  def algorithm=(arg0); end
  def cert_requested=(arg0); end
  def cert_requested?; end
  def initialize(*arg0); end
  def message_imprint; end
  def message_imprint=(arg0); end
  def nonce; end
  def nonce=(arg0); end
  def policy_id; end
  def policy_id=(arg0); end
  def to_der; end
  def version; end
  def version=(arg0); end
end
class OpenSSL::Timestamp::Factory
  def additional_certs; end
  def additional_certs=(arg0); end
  def allowed_digests; end
  def allowed_digests=(arg0); end
  def create_timestamp(arg0, arg1, arg2); end
  def default_policy_id; end
  def default_policy_id=(arg0); end
  def gen_time; end
  def gen_time=(arg0); end
  def serial_number; end
  def serial_number=(arg0); end
end
class OpenSSL::X509::Attribute
  def ==(other); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def oid; end
  def oid=(arg0); end
  def to_der; end
  def value; end
  def value=(arg0); end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::X509::Certificate
  def ==(arg0); end
  def add_extension(arg0); end
  def check_private_key(arg0); end
  def extensions; end
  def extensions=(arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def inspect; end
  def issuer; end
  def issuer=(arg0); end
  def not_after; end
  def not_after=(arg0); end
  def not_before; end
  def not_before=(arg0); end
  def pretty_print(q); end
  def public_key; end
  def public_key=(arg0); end
  def self.load(arg0); end
  def self.load_file(path); end
  def serial; end
  def serial=(arg0); end
  def sign(arg0, arg1); end
  def signature_algorithm; end
  def subject; end
  def subject=(arg0); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(arg0); end
  def version; end
  def version=(arg0); end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
  include OpenSSL::X509::Extension::AuthorityInfoAccess
  include OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include OpenSSL::X509::Extension::CRLDistributionPoints
  include OpenSSL::X509::Extension::SubjectKeyIdentifier
end
class OpenSSL::X509::CRL
  def ==(other); end
  def add_extension(arg0); end
  def add_revoked(arg0); end
  def extensions; end
  def extensions=(arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def issuer; end
  def issuer=(arg0); end
  def last_update; end
  def last_update=(arg0); end
  def next_update; end
  def next_update=(arg0); end
  def revoked; end
  def revoked=(arg0); end
  def sign(arg0, arg1); end
  def signature_algorithm; end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(arg0); end
  def version; end
  def version=(arg0); end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
  include OpenSSL::X509::Extension::AuthorityKeyIdentifier
end
class OpenSSL::X509::ExtensionFactory
  def config; end
  def config=(arg0); end
  def create_ext(*arg0); end
  def create_ext_from_array(ary); end
  def create_ext_from_hash(hash); end
  def create_ext_from_string(str); end
  def create_extension(*arg); end
  def crl; end
  def crl=(arg0); end
  def initialize(*arg0); end
  def issuer_certificate; end
  def issuer_certificate=(arg0); end
  def subject_certificate; end
  def subject_certificate=(arg0); end
  def subject_request; end
  def subject_request=(arg0); end
end
class OpenSSL::X509::Extension
  def ==(other); end
  def critical=(arg0); end
  def critical?; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def oid; end
  def oid=(arg0); end
  def to_a; end
  def to_der; end
  def to_h; end
  def to_s; end
  def value; end
  def value=(arg0); end
  def value_der; end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::X509::Name
  def <=>(arg0); end
  def add_entry(*arg0); end
  def cmp(arg0); end
  def eql?(arg0); end
  def hash; end
  def hash_old; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def inspect; end
  def pretty_print(q); end
  def self.parse(str, template = nil); end
  def self.parse_openssl(str, template = nil); end
  def self.parse_rfc2253(str, template = nil); end
  def to_a; end
  def to_der; end
  def to_s(*arg0); end
  def to_utf8; end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::X509::Request
  def ==(other); end
  def add_attribute(arg0); end
  def attributes; end
  def attributes=(arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def public_key; end
  def public_key=(arg0); end
  def sign(arg0, arg1); end
  def signature_algorithm; end
  def subject; end
  def subject=(arg0); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(arg0); end
  def version; end
  def version=(arg0); end
  extend OpenSSL::Marshal::ClassMethods
  include OpenSSL::Marshal
end
class OpenSSL::X509::Revoked
  def ==(other); end
  def add_extension(arg0); end
  def extensions; end
  def extensions=(arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def serial; end
  def serial=(arg0); end
  def time; end
  def time=(arg0); end
  def to_der; end
end
class OpenSSL::X509::Store
  def add_cert(arg0); end
  def add_crl(arg0); end
  def add_file(arg0); end
  def add_path(arg0); end
  def chain; end
  def error; end
  def error_string; end
  def flags=(arg0); end
  def initialize(*arg0); end
  def purpose=(arg0); end
  def set_default_paths; end
  def time=(arg0); end
  def trust=(arg0); end
  def verify(*arg0); end
  def verify_callback; end
  def verify_callback=(arg0); end
end
class OpenSSL::X509::StoreContext
  def chain; end
  def cleanup; end
  def current_cert; end
  def current_crl; end
  def error; end
  def error=(arg0); end
  def error_depth; end
  def error_string; end
  def flags=(arg0); end
  def initialize(*arg0); end
  def purpose=(arg0); end
  def time=(arg0); end
  def trust=(arg0); end
  def verify; end
end
class OpenSSL::OCSP::Request
  def add_certid(arg0); end
  def add_nonce(*arg0); end
  def certid; end
  def check_nonce(arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def sign(*arg0); end
  def signed?; end
  def to_der; end
  def verify(*arg0); end
end
class OpenSSL::OCSP::Response
  def basic; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def self.create(arg0, arg1); end
  def status; end
  def status_string; end
  def to_der; end
end
class OpenSSL::OCSP::BasicResponse
  def add_nonce(*arg0); end
  def add_status(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def copy_nonce(arg0); end
  def find_response(arg0); end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def responses; end
  def sign(*arg0); end
  def status; end
  def to_der; end
  def verify(*arg0); end
end
class OpenSSL::OCSP::SingleResponse
  def cert_status; end
  def certid; end
  def check_validity(*arg0); end
  def extensions; end
  def initialize(arg0); end
  def initialize_copy(arg0); end
  def next_update; end
  def revocation_reason; end
  def revocation_time; end
  def this_update; end
  def to_der; end
end
class OpenSSL::OCSP::CertificateId
  def cmp(arg0); end
  def cmp_issuer(arg0); end
  def hash_algorithm; end
  def initialize(*arg0); end
  def initialize_copy(arg0); end
  def issuer_key_hash; end
  def issuer_name_hash; end
  def serial; end
  def to_der; end
end
class OpenSSL::Provider
  def inspect; end
  def name; end
  def self.load(arg0); end
  def self.provider_names; end
  def unload; end
end
module OpenSSL::ASN1
  def BMPString(*arg0); end
  def BitString(*arg0); end
  def Boolean(*arg0); end
  def EndOfContent(*arg0); end
  def Enumerated(*arg0); end
  def GeneralString(*arg0); end
  def GeneralizedTime(*arg0); end
  def GraphicString(*arg0); end
  def IA5String(*arg0); end
  def ISO64String(*arg0); end
  def Integer(*arg0); end
  def Null(*arg0); end
  def NumericString(*arg0); end
  def ObjectId(*arg0); end
  def OctetString(*arg0); end
  def PrintableString(*arg0); end
  def Sequence(*arg0); end
  def Set(*arg0); end
  def T61String(*arg0); end
  def UTCTime(*arg0); end
  def UTF8String(*arg0); end
  def UniversalString(*arg0); end
  def VideotexString(*arg0); end
  def decode(arg0); end
  def decode_all(arg0); end
  def self.BMPString(*arg0); end
  def self.BitString(*arg0); end
  def self.Boolean(*arg0); end
  def self.EndOfContent(*arg0); end
  def self.Enumerated(*arg0); end
  def self.GeneralString(*arg0); end
  def self.GeneralizedTime(*arg0); end
  def self.GraphicString(*arg0); end
  def self.IA5String(*arg0); end
  def self.ISO64String(*arg0); end
  def self.Integer(*arg0); end
  def self.Null(*arg0); end
  def self.NumericString(*arg0); end
  def self.ObjectId(*arg0); end
  def self.OctetString(*arg0); end
  def self.PrintableString(*arg0); end
  def self.Sequence(*arg0); end
  def self.Set(*arg0); end
  def self.T61String(*arg0); end
  def self.UTCTime(*arg0); end
  def self.UTF8String(*arg0); end
  def self.UniversalString(*arg0); end
  def self.VideotexString(*arg0); end
  def self.decode(arg0); end
  def self.decode_all(arg0); end
  def self.traverse(arg0); end
  def traverse(arg0); end
end
class OpenSSL::ASN1::ASN1Data
  def indefinite_length; end
  def indefinite_length=(arg0); end
  def infinite_length; end
  def infinite_length=(arg0); end
  def initialize(arg0, arg1, arg2); end
  def tag; end
  def tag=(arg0); end
  def tag_class; end
  def tag_class=(arg0); end
  def to_der; end
  def value; end
  def value=(arg0); end
end
class OpenSSL::ASN1::Primitive < OpenSSL::ASN1::ASN1Data
  def initialize(*arg0); end
  def tagging; end
  def tagging=(arg0); end
  def to_der; end
end
class OpenSSL::ASN1::Constructive < OpenSSL::ASN1::ASN1Data
  def each; end
  def initialize(*arg0); end
  def tagging; end
  def tagging=(arg0); end
  def to_der; end
end
class OpenSSL::ASN1::ObjectId < OpenSSL::ASN1::Primitive
  def ==(arg0); end
  def ln; end
  def long_name; end
  def oid; end
  def self.register(arg0, arg1, arg2); end
  def short_name; end
  def sn; end
end
class OpenSSL::ASN1::BitString < OpenSSL::ASN1::Primitive
  def unused_bits; end
  def unused_bits=(arg0); end
end
class OpenSSL::ASN1::EndOfContent < OpenSSL::ASN1::ASN1Data
  def initialize; end
  def to_der; end
end
module OpenSSL::KDF
  def hkdf(*arg0); end
  def pbkdf2_hmac(*arg0); end
  def scrypt(*arg0); end
  def self.hkdf(*arg0); end
  def self.pbkdf2_hmac(*arg0); end
  def self.scrypt(*arg0); end
end
class Integer < Numeric
  def to_bn; end
end
module OpenSSL::Marshal
  def _dump(_level); end
  def self.included(base); end
end
module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end
class OpenSSL::Cipher::AES < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::CAST5 < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::BF < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::DES < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::IDEA < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::RC2 < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::RC4 < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::RC5 < OpenSSL::Cipher
  def initialize(*args); end
end
class OpenSSL::Cipher::AES128 < OpenSSL::Cipher
  def initialize(mode = nil); end
end
class OpenSSL::Cipher::AES192 < OpenSSL::Cipher
  def initialize(mode = nil); end
end
class OpenSSL::Cipher::AES256 < OpenSSL::Cipher
  def initialize(mode = nil); end
end
class OpenSSL::Cipher::Cipher < OpenSSL::Cipher
end
class OpenSSL::Digest::MD4 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::MD5 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::RIPEMD160 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::SHA1 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::SHA224 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::SHA256 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::SHA384 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::SHA512 < OpenSSL::Digest
  def initialize(data = nil); end
  def self.digest(data); end
  def self.hexdigest(data); end
end
class OpenSSL::Digest::Digest < OpenSSL::Digest
end
module OpenSSL::X509
end
module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end
module OpenSSL::X509::Extension::SubjectKeyIdentifier
  def subject_key_identifier; end
  include OpenSSL::X509::Extension::Helpers
end
module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  def authority_key_identifier; end
  include OpenSSL::X509::Extension::Helpers
end
module OpenSSL::X509::Extension::CRLDistributionPoints
  def crl_uris; end
  include OpenSSL::X509::Extension::Helpers
end
module OpenSSL::X509::Extension::AuthorityInfoAccess
  def ca_issuer_uris; end
  def ocsp_uris; end
  def parse_aia_asn1; end
  include OpenSSL::X509::Extension::Helpers
end
module OpenSSL::X509::Name::RFC2253DN
  def expand_hexstring(str); end
  def expand_pair(str); end
  def expand_value(str1, str2, str3); end
  def scan(dn); end
  def self.expand_hexstring(str); end
  def self.expand_pair(str); end
  def self.expand_value(str1, str2, str3); end
  def self.scan(dn); end
end
module OpenSSL::Buffering
  def <<(s); end
  def close; end
  def consume_rbuff(size = nil); end
  def do_write(s); end
  def each(eol = nil); end
  def each_byte; end
  def each_line(eol = nil); end
  def eof; end
  def eof?; end
  def fill_rbuff; end
  def flush; end
  def getbyte; end
  def getc; end
  def gets(eol = nil, limit = nil); end
  def initialize(*); end
  def print(*args); end
  def printf(s, *args); end
  def puts(*args); end
  def read(size = nil, buf = nil); end
  def read_nonblock(maxlen, buf = nil, exception: nil); end
  def readchar; end
  def readline(eol = nil); end
  def readlines(eol = nil); end
  def readpartial(maxlen, buf = nil); end
  def sync; end
  def sync=(arg0); end
  def ungetc(c); end
  def write(*s); end
  def write_nonblock(s, exception: nil); end
  include Enumerable
end
class OpenSSL::Buffering::Buffer < String
  def <<(string); end
  def concat(string); end
  def initialize; end
end
module OpenSSL::SSL
  def self.verify_certificate_identity(cert, hostname); end
  def self.verify_hostname(hostname, san); end
  def self.verify_wildcard(domain_component, san_component); end
  def verify_certificate_identity(cert, hostname); end
  def verify_hostname(hostname, san); end
  def verify_wildcard(domain_component, san_component); end
end
module OpenSSL::SSL::SocketForwarder
  def addr; end
  def closed?; end
  def do_not_reverse_lookup=(flag); end
  def fcntl(*args); end
  def fileno; end
  def getsockopt(level, optname); end
  def peeraddr; end
  def setsockopt(level, optname, optval); end
end
class OpenSSL::SSL::SSLServer
  def accept; end
  def close; end
  def initialize(svr, ctx); end
  def listen(backlog = nil); end
  def shutdown(how = nil); end
  def start_immediately; end
  def start_immediately=(arg0); end
  def to_io; end
  include OpenSSL::SSL::SocketForwarder
end
module OpenSSL::PKCS5
  def pbkdf2_hmac(pass, salt, iter, keylen, digest); end
  def pbkdf2_hmac_sha1(pass, salt, iter, keylen); end
  def self.pbkdf2_hmac(pass, salt, iter, keylen, digest); end
  def self.pbkdf2_hmac_sha1(pass, salt, iter, keylen); end
end
