# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def deconstruct(); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Sexp
  def s(type, *children); end
end

class AbstractController::ActionNotFound
  def action(); end

  def controller(); end

  def initialize(message=T.unsafe(nil), controller=T.unsafe(nil), action=T.unsafe(nil)); end
end

class AbstractController::Base
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def performed?(); end

  def process(action, *args, **arg); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*arg); end
end

class AbstractController::Base
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Caching
  def view_cache_dependencies(); end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module AbstractController::Caching::Fragments
  def combined_fragment_cache_key(key); end

  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key, &block); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module AbstractController::Caching::Fragments::ClassMethods
  def fragment_cache_key(value=T.unsafe(nil), &key); end
end

class AbstractController::Callbacks::ActionFilter
  def after(controller); end

  def around(controller); end

  def before(controller); end

  def initialize(actions); end

  def match?(controller); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end
end

module AbstractController::Collector
  def atom(*args, **arg, &block); end

  def bmp(*args, **arg, &block); end

  def css(*args, **arg, &block); end

  def csv(*args, **arg, &block); end

  def gif(*args, **arg, &block); end

  def gzip(*args, **arg, &block); end

  def html(*args, **arg, &block); end

  def ics(*args, **arg, &block); end

  def jpeg(*args, **arg, &block); end

  def js(*args, **arg, &block); end

  def json(*args, **arg, &block); end

  def m4a(*args, **arg, &block); end

  def mp3(*args, **arg, &block); end

  def mp4(*args, **arg, &block); end

  def mpeg(*args, **arg, &block); end

  def multipart_form(*args, **arg, &block); end

  def ogg(*args, **arg, &block); end

  def otf(*args, **arg, &block); end

  def pdf(*args, **arg, &block); end

  def png(*args, **arg, &block); end

  def rss(*args, **arg, &block); end

  def svg(*args, **arg, &block); end

  def text(*args, **arg, &block); end

  def tiff(*args, **arg, &block); end

  def ttf(*args, **arg, &block); end

  def url_encoded_form(*args, **arg, &block); end

  def vcf(*args, **arg, &block); end

  def vtt(*args, **arg, &block); end

  def webm(*args, **arg, &block); end

  def woff(*args, **arg, &block); end

  def woff2(*args, **arg, &block); end

  def xml(*args, **arg, &block); end

  def yaml(*args, **arg, &block); end

  def zip(*args, **arg, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module AbstractController::Helpers
  def _helpers(); end
end

module AbstractController::Helpers::ClassMethods
  def _helpers=(_helpers); end

  def _helpers_for_modification(); end

  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*methods); end

  def inherited(klass); end

  def modules_for_helpers(modules_or_helper_prefixes); end
end

class AbstractController::Helpers::MissingHelperError
  def initialize(error, path); end
end

module AbstractController::Rendering
  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Translation
  def l(object, **options); end

  def localize(object, **options); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(val); end

  def t(key, **options); end

  def translate(key, **options); end
end

module AbstractController::Translation
  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(val); end
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

class ActionCable::Channel::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def connection(); end

  def identifier(); end

  def initialize(connection, identifier, params=T.unsafe(nil)); end

  def logger(*arg, **arg1, &arg2); end

  def params(); end

  def perform_action(data); end

  def periodic_timers=(periodic_timers); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def subscribe_to_channel(); end

  def unsubscribe_from_channel(); end
end

class ActionCable::Channel::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.action_methods(); end

  def self.periodic_timers(); end

  def self.periodic_timers=(value); end

  def self.periodic_timers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end
end

module ActionCable::Channel::Broadcasting
  def broadcast_to(*arg, **arg1, &arg2); end

  def broadcasting_for(*arg, **arg1, &arg2); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end

  def broadcasting_for(model); end

  def serialize_broadcasting(object); end
end

module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end

  def after_unsubscribe(*methods, &block); end

  def before_subscribe(*methods, &block); end

  def before_unsubscribe(*methods, &block); end

  def on_subscribe(*methods, &block); end

  def on_unsubscribe(*methods, &block); end
end

module ActionCable::Channel::ChannelStub
  def confirmed?(); end

  def rejected?(); end

  def start_periodic_timers(); end

  def stop_all_streams(); end

  def stop_periodic_timers(); end

  def stream_from(broadcasting, *arg); end

  def streams(); end
end

class ActionCable::Channel::ConnectionStub
  def connection_identifier(); end

  def identifiers(); end

  def initialize(identifiers=T.unsafe(nil)); end

  def logger(); end

  def subscriptions(); end

  def transmissions(); end

  def transmit(cable_message); end
end

module ActionCable::Channel::Naming
  def channel_name(*arg, **arg1, &arg2); end
end

module ActionCable::Channel::Naming::ClassMethods
  def channel_name(); end
end

class ActionCable::Channel::NonInferrableChannelError
  def initialize(name); end
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name=T.unsafe(nil), every:, &block); end
end

module ActionCable::Channel::Streams
  def pubsub(*arg, **arg1, &arg2); end

  def stop_all_streams(); end

  def stop_stream_for(model); end

  def stop_stream_from(broadcasting); end

  def stream_for(model, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_from(broadcasting, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_or_reject_for(model); end
end

class ActionCable::Channel::TestCase
  def _channel_class(); end

  def _channel_class=(_channel_class); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

module ActionCable::Channel::TestCase::Behavior
  def assert_broadcast_on(stream_or_object, *args); end

  def assert_broadcasts(stream_or_object, *args); end

  def assert_has_stream(stream); end

  def assert_has_stream_for(object); end

  def assert_no_streams(); end

  def perform(action, data=T.unsafe(nil)); end

  def stub_connection(identifiers=T.unsafe(nil)); end

  def subscribe(params=T.unsafe(nil)); end

  def transmissions(); end

  def unsubscribe(); end
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
  def channel_class(); end

  def determine_default_channel(name); end

  def tests(channel); end
end

class ActionCable::Channel::TestCase
  def self._channel_class(); end

  def self._channel_class=(value); end

  def self._channel_class?(); end
end

module ActionCable::Connection::Assertions
  def assert_reject_connection(&block); end
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Base
  def beat(); end

  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*arg, **arg1, &arg2); end

  def identifiers(); end

  def identifiers=(identifiers); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*arg, **arg1, &arg2); end

  def receive(websocket_message); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  def self.identifiers(); end

  def self.identifiers=(value); end

  def self.identifiers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::NonInferrableConnectionError
  def initialize(name); end
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*arg, **arg1, &arg2); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger, &block); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TestCase
  def _connection_class(); end

  def _connection_class=(_connection_class); end

  def _connection_class?(); end

  def connection(); end
end

module ActionCable::Connection::TestCase::Behavior
  def connect(path=T.unsafe(nil), **request_params); end

  def cookies(); end

  def disconnect(); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
  def connection_class(); end

  def determine_default_connection(name); end

  def tests(connection); end
end

class ActionCable::Connection::TestCase
  def self._connection_class(); end

  def self._connection_class=(value); end

  def self._connection_class?(); end
end

module ActionCable::Connection::TestConnection
  def initialize(request); end

  def logger(); end

  def request(); end
end

class ActionCable::Connection::TestCookieJar
  def encrypted(); end

  def signed(); end
end

class ActionCable::Connection::TestRequest
  def cookie_jar=(cookie_jar); end

  def session=(session); end
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  def disconnect(); end

  def identifiers(); end

  def identifiers=(identifiers); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection
  def self.identifiers(); end

  def self.identifiers=(value); end

  def self.identifiers?(); end
end

class ActionCable::Server::Base
  def call(env); end

  def config(); end

  def connection_identifiers(); end

  def disconnect(identifiers); end

  def event_loop(); end

  def initialize(config: T.unsafe(nil)); end

  def logger(*arg, **arg1, &arg2); end

  def mutex(); end

  def pubsub(); end

  def remote_connections(); end

  def restart(); end

  def worker_pool(); end
end

class ActionCable::Server::Base
  def self.config(); end

  def self.config=(val); end

  def self.logger(); end
end

module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end

  def broadcasting(); end

  def coder(); end

  def initialize(server, broadcasting, coder:); end

  def server(); end
end

class ActionCable::Server::Configuration
  def allow_same_origin_as_host(); end

  def allow_same_origin_as_host=(allow_same_origin_as_host); end

  def allowed_request_origins(); end

  def allowed_request_origins=(allowed_request_origins); end

  def cable(); end

  def cable=(cable); end

  def connection_class(); end

  def connection_class=(connection_class); end

  def disable_request_forgery_protection(); end

  def disable_request_forgery_protection=(disable_request_forgery_protection); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def mount_path(); end

  def mount_path=(mount_path); end

  def precompile_assets(); end

  def precompile_assets=(precompile_assets); end

  def pubsub_adapter(); end

  def url(); end

  def url=(url); end

  def worker_pool_size(); end

  def worker_pool_size=(worker_pool_size); end
end

module ActionCable::Server::Connections
  def add_connection(connection); end

  def connections(); end

  def open_connections_statistics(); end

  def remove_connection(connection); end

  def setup_heartbeat_timer(); end
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class ActionCable::Server::Worker
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def connection(); end

  def connection=(obj); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection, &block); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(&block); end
end

class ActionCable::Server::Worker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

class ActionCable::SubscriptionAdapter::Async::AsyncSubscriberMap
  def add_subscriber(*arg); end

  def initialize(event_loop); end

  def invoke_callback(*arg); end
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def identifier(); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::Inline
  def initialize(*arg); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::Test
  def broadcasts(channel); end

  def clear(); end

  def clear_messages(channel); end
end

module ActionCable::TestHelper
  def after_teardown(); end

  def assert_broadcast_on(stream, data, &block); end

  def assert_broadcasts(stream, number, &block); end

  def assert_no_broadcasts(stream, &block); end

  def before_setup(); end

  def broadcasts(*arg, **arg1, &arg2); end

  def clear_messages(*arg, **arg1, &arg2); end

  def pubsub_adapter(); end
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  def __callbacks(); end

  def __callbacks?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(_renderers); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _wrapper_options(); end

  def _wrapper_options=(_wrapper_options); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(etaggers); end

  def etaggers?(); end

  def logger(); end

  def logger=(value); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end
end

class ActionController::API
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(value); end

  def self._renderers?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(value); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(value); end

  def self.etaggers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.without_modules(*modules); end
end

module ActionController::ApiRendering
  def render_to_body(options=T.unsafe(nil)); end
end

class ActionController::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(_renderers); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(_view_cache_dependencies); end

  def _view_cache_dependencies?(); end

  def _wrapper_options(); end

  def _wrapper_options=(_wrapper_options); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(etag_with_template_digest); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(etaggers); end

  def etaggers?(); end

  def flash(*arg, **arg1, &arg2); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(fragment_cache_keys); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(helpers_path); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(include_all_helpers); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def urlsafe_csrf_tokens(); end
end

module ActionController::Base::HelperMethods
  def alert(*args, **arg, &block); end

  def combined_fragment_cache_key(*args, **arg, &block); end

  def content_security_policy?(*args, **arg, &block); end

  def content_security_policy_nonce(*args, **arg, &block); end

  def cookies(*args, **arg, &block); end

  def form_authenticity_token(*args, **arg, &block); end

  def notice(*args, **arg, &block); end

  def protect_against_forgery?(*args, **arg, &block); end

  def view_cache_dependencies(*args, **arg, &block); end
end

class ActionController::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(value); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(value); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._layout(); end

  def self._layout=(value); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(value); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(value); end

  def self._renderers?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(value); end

  def self._view_cache_dependencies?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(value); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(value); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(value); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(value); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(value); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(value); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.urlsafe_csrf_tokens(); end

  def self.urlsafe_csrf_tokens=(urlsafe_csrf_tokens); end

  def self.without_modules(*modules); end
end

module ActionController::BasicImplicitRender
  def default_render(); end

  def send_action(method, *args); end
end

module ActionController::ConditionalGet
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(object=T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), cache_control: T.unsafe(nil), template: T.unsafe(nil)); end

  def http_cache_forever(public: T.unsafe(nil)); end

  def no_store(); end

  def stale?(object=T.unsafe(nil), **freshness_kwargs); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled=T.unsafe(nil), **options, &block); end

  def content_security_policy_report_only(report_only=T.unsafe(nil), **options); end
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DefaultHeaders::ClassMethods
  def make_response!(request); end
end

module ActionController::Flash::ClassMethods
  def action_methods(); end
end

module ActionController::FormBuilder
  def default_form_builder(); end
end

module ActionController::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Helpers
  def helpers(); end
end

module ActionController::Helpers::ClassMethods
  def all_helpers_from_path(path); end

  def helper_attr(*attrs); end

  def modules_for_helpers(args); end
end

module ActionController::Helpers
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm, message); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def http_basic_authenticate_or_request_with(name:, password:, realm: T.unsafe(nil), message: T.unsafe(nil)); end

  def request_http_basic_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), message=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::ImplicitRender
  def default_render(); end

  def method_for_action(action_name); end
end

module ActionController::Instrumentation
  def redirect_to(*arg); end

  def render(*arg); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

module ActionController::Live
  def new_controller_thread(); end

  def process(name); end

  def response_body=(body); end

  def send_stream(filename:, disposition: T.unsafe(nil), type: T.unsafe(nil)); end
end

class ActionController::Live::Buffer
  def call_on_error(); end

  def connected?(); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end

  def writeln(string); end
end

class ActionController::Live::Buffer
  def self.queue_size(); end

  def self.queue_size=(queue_size); end
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::LiveTestResponse
  def error?(); end

  def missing?(); end

  def success?(); end
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

module ActionController::Logging::ClassMethods
  def log_at(level, **options); end
end

class ActionController::Metal
  def content_type(*arg, **arg1, &arg2); end

  def content_type=(arg); end

  def controller_name(); end

  def dispatch(name, request, response); end

  def headers(*arg, **arg1, &arg2); end

  def location(*arg, **arg1, &arg2); end

  def location=(arg); end

  def media_type(*arg, **arg1, &arg2); end

  def middleware_stack(); end

  def middleware_stack=(middleware_stack); end

  def middleware_stack?(); end

  def response=(response); end

  def response_body=(body); end

  def response_code(*arg, **arg1, &arg2); end

  def session(*arg, **arg1, &arg2); end

  def set_request!(request); end

  def set_response!(response); end

  def status(*arg, **arg1, &arg2); end

  def status=(arg); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name); end

  def self.action_encoding_template(action); end

  def self.controller_name(); end

  def self.dispatch(name, req, res); end

  def self.inherited(base); end

  def self.make_response!(request); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(value); end

  def self.middleware_stack?(); end

  def self.use(*arg, **arg1, &arg2); end
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil), &block); end
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, args, actions, strategy, block); end

  def valid?(action); end
end

class ActionController::MimeResponds::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def any_response?(); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

class ActionController::MissingRenderer
  def initialize(format); end
end

module ActionController::ParameterEncoding::ClassMethods
  def action_encoding_template(action); end

  def inherited(klass); end

  def param_encoding(action, param, encoding); end

  def setup_param_encode(); end

  def skip_parameter_encoding(action); end
end

class ActionController::Parameters
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

class ActionController::ParamsWrapper::Options
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::PermissionsPolicy::ClassMethods
  def permissions_policy(**options, &block); end
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  def redirect_back_or_to(fallback_location, allow_other_host: T.unsafe(nil), **options); end

  def redirect_to(options=T.unsafe(nil), response_options=T.unsafe(nil)); end

  def url_from(location); end
  ILLEGAL_HEADER_VALUE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::Redirecting
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::Renderer
  def controller(); end

  def defaults(); end

  def initialize(controller, env, defaults); end

  def new(env=T.unsafe(nil)); end

  def render(*args); end

  def render_to_string(*args); end

  def with_defaults(defaults); end
end

class ActionController::Renderer
  def self.for(controller, env=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

module ActionController::Renderers
  def _render_to_body_with_renderer(options); end

  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_xml(xml, options); end

  def render_to_body(options); end
end

module ActionController::Renderers::ClassMethods
  def use_renderer(*args); end

  def use_renderers(*args); end
end

module ActionController::Renderers
  def self._render_with_renderer_method_name(key); end

  def self.add(key, &block); end

  def self.remove(key); end
end

module ActionController::Rendering
  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*arg); end
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end

  def render(*arg, **arg1, &arg2); end

  def renderer(); end

  def setup_renderer!(); end
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def handle_unverified_request(); end

  def initialize(controller); end

  def warning_message(); end

  def warning_message=(warning_message); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
  def write(*arg); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
  def enabled?(); end

  def initialize(req); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

module ActionController::Rescue
  def show_detailed_exceptions?(); end
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

class ActionController::TestCase
  def _controller_class(); end

  def _controller_class=(_controller_class); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  def build_response(klass); end

  def controller_class_name(); end

  def delete(action, **args); end

  def generated_path(generated_extras); end

  def get(action, **args); end

  def head(action, **args); end

  def patch(action, **args); end

  def post(action, **args); end

  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

class ActionController::TestCase
  def self._controller_class(); end

  def self._controller_class=(value); end

  def self._controller_class?(); end

  def self.executor_around_each_request(); end

  def self.executor_around_each_request=(executor_around_each_request); end
end

class ActionController::TestRequest
  def assign_parameters(routes, controller_path, action, parameters, generated_path, query_string_keys); end

  def content_type=(type); end

  def initialize(env, session, controller_class); end

  def query_string=(string); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  def self.create(controller_class); end

  def self.new_session(); end
end

class ActionController::TestSession
  def dig(*keys); end

  def enabled?(); end

  def fetch(key, *args, &block); end

  def initialize(session=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::Testing::Functional
  def clear_instance_variables_between_requests(); end

  def recycle!(); end
end

module ActionController::UrlFor
  def url_options(); end
end

module ActionController
  def self.add_renderer(key, &block); end

  def self.remove_renderer(key); end
end

class ActionDispatch::ActionableExceptions
  def call(env); end

  def endpoint(); end

  def endpoint=(val); end

  def initialize(app); end
end

class ActionDispatch::ActionableExceptions
  def self.endpoint(); end

  def self.endpoint=(val); end
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, **arg, &block); end

  def setup(); end

  def with_routing(); end
end

class ActionDispatch::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def block_all_mixed_content(enabled=T.unsafe(nil)); end

  def build(context=T.unsafe(nil), nonce=T.unsafe(nil), nonce_directives=T.unsafe(nil)); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def directives(); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def plugin_types(*types); end

  def prefetch_src(*sources); end

  def report_uri(uri); end

  def require_sri_for(*types); end

  def require_trusted_types_for(*sources); end

  def sandbox(*values); end

  def script_src(*sources); end

  def script_src_attr(*sources); end

  def script_src_elem(*sources); end

  def style_src(*sources); end

  def style_src_attr(*sources); end

  def style_src_elem(*sources); end

  def trusted_types(*sources); end

  def upgrade_insecure_requests(enabled=T.unsafe(nil)); end

  def worker_src(*sources); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy(); end

  def content_security_policy=(policy); end

  def content_security_policy_nonce(); end

  def content_security_policy_nonce_directives(); end

  def content_security_policy_nonce_directives=(generator); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(value); end
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SAME_SITE_PROTECTION = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(val); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*arg); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(headers); end
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(val); end

  def self.build(req, cookies); end
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::MarshalWithJsonFallback
  def self.dump(value); end

  def self.load(value); end
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil), interceptors=T.unsafe(nil)); end
end

class ActionDispatch::DebugExceptions
  def self.interceptors(); end

  def self.register_interceptor(object=T.unsafe(nil), &block); end
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*arg); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::ExceptionWrapper
  def application_trace(); end

  def backtrace_cleaner(); end

  def exception(); end

  def exception_trace(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def rescue_response?(); end

  def rescue_responses(); end

  def rescue_responses=(val); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(val); end

  def silent_exceptions(); end

  def silent_exceptions=(val); end

  def source_extracts(); end

  def source_to_show_id(); end

  def status_code(); end

  def trace_to_show(); end

  def traces(); end

  def unwrapped_exception(); end

  def wrapped_causes(); end

  def wrapper_exceptions(); end

  def wrapper_exceptions=(val); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(val); end

  def self.rescue_templates(); end

  def self.rescue_templates=(val); end

  def self.silent_exceptions(); end

  def self.silent_exceptions=(val); end

  def self.status_code_for_exception(class_name); end

  def self.wrapper_exceptions(); end

  def self.wrapper_exceptions=(val); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::FileHandler
  def attempt(env); end

  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil), precompressed: T.unsafe(nil), compressible_content_types: T.unsafe(nil)); end
  PRECOMPRESSED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

class ActionDispatch::Flash
  def self.new(app); end
end

class ActionDispatch::HostAuthorization
  def call(env); end

  def initialize(app, hosts, exclude: T.unsafe(nil), response_app: T.unsafe(nil)); end
  ALLOWED_HOSTS_IN_DEVELOPMENT = ::T.let(nil, ::T.untyped)
  IPV4_HOSTNAME = ::T.let(nil, ::T.untyped)
  IPV6_HOSTNAME = ::T.let(nil, ::T.untyped)
  IPV6_HOSTNAME_WITH_PORT = ::T.let(nil, ::T.untyped)
  PORT_REGEX = ::T.let(nil, ::T.untyped)
  VALID_IP_HOSTNAME = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::DefaultResponseApp
  def call(env); end
  RESPONSE_STATUS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::Permissions
  def allows?(host); end

  def empty?(); end

  def initialize(hosts); end
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag=(weak_validators); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def strong_etag=(strong_validators); end

  def strong_etag?(); end

  def weak_etag=(weak_validators); end

  def weak_etag?(); end
  NO_STORE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def initialize(); end
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
end

class ActionDispatch::Http::Headers
  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, default=T.unsafe(nil)); end

  def include?(key); end

  def initialize(request); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
end

class ActionDispatch::Http::Headers
  def self.from_hash(hash); end
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def should_apply_vary_header?(); end

  def variant(); end

  def variant=(variant); end
end

module ActionDispatch::Http::Parameters
  def path_parameters(); end

  def path_parameters=(parameters); end
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def secure_protocol(); end

  def secure_protocol=(val); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(val); end

  def url(); end
end

module ActionDispatch::Http::URL
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.secure_protocol(); end

  def self.secure_protocol=(val); end

  def self.tld_length(); end

  def self.tld_length=(val); end

  def self.url_for(options); end
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end

  def follow_redirect!(**args); end

  def get(path, **args); end

  def head(path, **args); end

  def options(path, **args); end

  def patch(path, **args); end

  def post(path, **args); end

  def put(path, **args); end
end

module ActionDispatch::Integration::Runner
  def app(); end

  def assertions(); end

  def assertions=(assertions); end

  def assigns(*arg, **arg1, &arg2); end

  def before_setup(); end

  def cookies(*arg, **arg1, &arg2); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*arg, **arg1, &arg2); end

  def follow_redirect!(*arg, **arg1, &arg2); end

  def get(*arg, **arg1, &arg2); end

  def head(*arg, **arg1, &arg2); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*arg, **arg1, &arg2); end

  def post(*arg, **arg1, &arg2); end

  def put(*arg, **arg1, &arg2); end

  def remove!(); end

  def reset!(); end

  def root_session(); end

  def root_session=(root_session); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::ActionDispatch::Integration::RequestHelpers
  def accept(); end

  def accept=(accept); end

  def body(*arg, **arg1, &arg2); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def headers(*arg, **arg1, &arg2); end

  def host(); end

  def host!(arg); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*arg, **arg1, &arg2); end

  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*arg, **arg1, &arg2); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*arg, **arg1, &arg2); end

  def status_message(*arg, **arg1, &arg2); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

module ActionDispatch::IntegrationTest::Behavior
  def app(); end

  def document_root_element(); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app(); end

  def app=(app); end

  def register_encoder(*args, **options); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

class ActionDispatch::Journey::Format
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
  DUMMY_END_NODE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Simulator
  INITIAL_STATE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::TransitionTable
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
  DEFAULT_EXP_ANCHORED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
  GREEDY_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::MiddlewareStack
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def delete!(target); end

  def each(&block); end

  def initialize(*args); end

  def insert(index, klass, *args, **arg, &block); end

  def insert_after(index, *args, **arg, &block); end

  def insert_before(index, klass, *args, **arg, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def move(target, source); end

  def move_after(target, source); end

  def move_before(target, source); end

  def size(); end

  def swap(target, *args, **arg, &block); end

  def unshift(klass, *args, **arg, &block); end

  def use(klass, *args, **arg, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def build_instrumented(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::PermissionsPolicy
  def accelerometer(*sources); end

  def ambient_light_sensor(*sources); end

  def autoplay(*sources); end

  def build(context=T.unsafe(nil)); end

  def camera(*sources); end

  def directives(); end

  def encrypted_media(*sources); end

  def fullscreen(*sources); end

  def geolocation(*sources); end

  def gyroscope(*sources); end

  def magnetometer(*sources); end

  def microphone(*sources); end

  def midi(*sources); end

  def payment(*sources); end

  def picture_in_picture(*sources); end

  def speaker(*sources); end

  def usb(*sources); end

  def vibrate(*sources); end

  def vr(*sources); end
end

class ActionDispatch::PermissionsPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::PermissionsPolicy::Request
  def permissions_policy(); end

  def permissions_policy=(policy); end
  POLICY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::Request
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(val); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_script_name(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def raw_request_method(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def return_only_media_type_on_content_type(); end

  def return_only_media_type_on_content_type=(val); end

  def routes(); end

  def routes=(routes); end

  def send_early_hints(links); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(val); end

  def self.parameter_parsers(); end

  def self.return_only_media_type_on_content_type(); end

  def self.return_only_media_type_on_content_type=(val); end
end

module ActionDispatch::RequestCookieMethods
  def authenticated_encrypted_cookie_salt(); end

  def commit_cookie_jar!(); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_same_site_protection(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def have_cookie_jar?(); end

  def key_generator(); end

  def secret_key_base(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def use_cookies_with_metadata(); end
end

class ActionDispatch::RequestEncoder
  def accept_header(); end

  def content_type(); end

  def encode_params(params); end

  def initialize(mime_name, param_encoder, response_parser); end

  def response_parser(); end
end

class ActionDispatch::RequestEncoder::IdentityEncoder
  def accept_header(); end

  def content_type(); end

  def encode_params(params); end

  def response_parser(); end
end

class ActionDispatch::RequestEncoder
  def self.encoder(name); end

  def self.parser(content_type); end

  def self.register_encoder(mime_name, param_encoder: T.unsafe(nil), response_parser: T.unsafe(nil)); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app, header:); end
end

class ActionDispatch::Response
  def [](*arg, **arg1, &arg2); end

  def []=(*arg, **arg1, &arg2); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(val); end

  def default_headers(); end

  def default_headers=(val); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(val); end

  def self.default_headers(); end

  def self.default_headers=(val); end

  def self.merge_default_headers(original, default); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end

  def no_routes(routes, filter); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
  def initialize(width: T.unsafe(nil)); end
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*arg); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::Mapper
  def initialize(set); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  def options(*args, &block); end
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set:, ast:, controller:, default_action:, to:, formatted:, via:, options_constraints:, anchor:, scope_params:, options:); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def scope_options(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def draw(name); end

  def nested(&block); end

  def new(&block); end

  def resources_path_names(options); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def available_actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Scope
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(&blk); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil), &block); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil), &block); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

class ActionDispatch::Routing::OptionRedirect
  def options(); end
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Redirect
  def block(); end

  def call(env); end

  def initialize(status, block); end

  def path(params, request); end

  def serve(req); end

  def status(); end
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

class ActionDispatch::Routing::RouteSet
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

class ActionDispatch::Routing::RouteWrapper
  def action(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def internal?(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil), ssl_default_redirect_status: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
  PERMANENT_REDIRECT_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

class ActionDispatch::ServerTiming
  def call(env); end

  def initialize(app); end
  SERVER_TIMING_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ServerTiming::Subscriber
  def call(event); end

  def collect_events(); end

  def ensure_subscribed(); end

  def unsubscribe(); end
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ServerTiming
  def self.unsubscribe(); end
end

class ActionDispatch::Session::AbstractSecureStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractSecureStore
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Session::CookieStore::SessionId
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

module ActionDispatch::TestProcess
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

class ActionMailbox::Base
  include ::ActionMailbox::Routing
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_with(message); end

  def bounced!(*arg, **arg1, &arg2); end

  def delivered!(*arg, **arg1, &arg2); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(*arg, **arg1, &arg2); end

  def mail(*arg, **arg1, &arg2); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def router(); end

  def router=(val); end
end

class ActionMailbox::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(val); end
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks::ClassMethods
  def after_processing(*methods, &block); end

  def around_processing(*methods, &block); end

  def before_processing(*methods, &block); end
end

class ActionMailbox::InboundEmail
  include ::ActionMailbox::InboundEmail::Routable
  include ::ActionMailbox::InboundEmail::MessageId
  def autosave_associated_records_for_raw_email_attachment(*args); end

  def autosave_associated_records_for_raw_email_blob(*args); end

  def mail(); end

  def processed?(); end

  def source(); end
end

module ActionMailbox::InboundEmail::GeneratedAssociationMethods
  def build_raw_email_attachment(*args, &block); end

  def build_raw_email_blob(*args, &block); end

  def create_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment!(*args, &block); end

  def create_raw_email_blob(*args, &block); end

  def create_raw_email_blob!(*args, &block); end

  def raw_email(); end

  def raw_email=(attachable); end

  def raw_email_attachment(); end

  def raw_email_attachment=(value); end

  def raw_email_blob(); end

  def raw_email_blob=(value); end

  def reload_raw_email_attachment(); end

  def reload_raw_email_blob(); end
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::Incineratable
  def incinerate(); end

  def incinerate_later(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
  def initialize(inbound_email); end

  def run(); end
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
  def create_and_extract_message_id!(source, **options); end
end

module ActionMailbox::InboundEmail::Routable
  def route(); end

  def route_later(); end
end

class ActionMailbox::InboundEmail
  def self.bounced(*args, **arg); end

  def self.delivered(*args, **arg); end

  def self.failed(*args, **arg); end

  def self.not_bounced(*args, **arg); end

  def self.not_delivered(*args, **arg); end

  def self.not_failed(*args, **arg); end

  def self.not_pending(*args, **arg); end

  def self.not_processing(*args, **arg); end

  def self.pending(*args, **arg); end

  def self.processing(*args, **arg); end

  def self.statuses(); end

  def self.with_attached_raw_email(*args, **arg); end
end

class ActionMailbox::IncinerationJob
  def perform(inbound_email); end
end

class ActionMailbox::IncinerationJob
  def self.schedule(inbound_email); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(key:, timestamp:, token:, signature:); end

  def key(); end

  def signature(); end

  def timestamp(); end

  def token(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
  def create(); end

  def health_check(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(request, key); end

  def key(); end

  def request(); end
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
  def create(); end
end

module ActionMailbox::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def mailbox_for(inbound_email); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

module ActionMailbox::Routing::ClassMethods
  def mailbox_for(inbound_email); end

  def route(inbound_email); end

  def routing(routes); end
end

class ActionMailbox::RoutingJob
  def perform(inbound_email); end
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options, &block); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs, &block); end

  def receive_inbound_email_from_source(*args); end
end

class ActionMailer::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(_view_cache_dependencies); end

  def _view_cache_dependencies?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_params(); end

  def default_params=(default_params); end

  def default_params?(); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(val); end

  def delivery_job(); end

  def delivery_job=(delivery_job); end

  def delivery_job?(); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(delivery_methods); end

  def delivery_methods?(); end

  def email_address_with_name(address, name); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(file_settings); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(fragment_cache_keys); end

  def fragment_cache_keys?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(val); end

  def preview_interceptors(); end

  def preview_path(); end

  def process(method_name, *args, **arg); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(val); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(sendmail_settings); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(smtp_settings); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(test_settings); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionMailer::Base::HelperMethods
  def combined_fragment_cache_key(*args, **arg, &block); end

  def view_cache_dependencies(*args, **arg, &block); end
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._layout(); end

  def self._layout=(value); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(value); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(value); end

  def self._view_cache_dependencies?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(value); end

  def self.default_params?(); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(val); end

  def self.deliver_mail(mail); end

  def self.delivery_job(); end

  def self.delivery_job=(value); end

  def self.delivery_job?(); end

  def self.delivery_method(); end

  def self.delivery_method=(value); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(value); end

  def self.delivery_methods?(); end

  def self.email_address_with_name(address, name); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(value); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(value); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(val); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(val); end

  def self.preview_path(); end

  def self.preview_path=(val); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(val); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(value); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(val); end

  def self.smtp_settings(); end

  def self.smtp_settings=(value); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(value); end

  def self.test_settings?(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_interceptors(*interceptors); end

  def self.unregister_observer(observer); end

  def self.unregister_observers(*observers); end
end

class ActionMailer::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(*arg, **arg1, &arg2); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

class ActionMailer::InlinePreviewInterceptor
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end
end

class ActionMailer::MailDeliveryJob
  def perform(mailer, mail_method, delivery_method, args:, kwargs: T.unsafe(nil), params: T.unsafe(nil)); end
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args, **arg); end

  def message(); end

  def processed?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::NonInferrableMailerError
  def initialize(name); end
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args, **arg); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end

  def unregister_preview_interceptor(interceptor); end

  def unregister_preview_interceptors(*interceptors); end
end

module ActionMailer::Rescuable
  def handle_exceptions(); end
end

module ActionMailer::Rescuable::ClassMethods
  def handle_exception(exception); end
end

class ActionMailer::TestCase
  def _mailer_class(); end

  def _mailer_class=(_mailer_class); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

class ActionMailer::TestCase
  def self._mailer_class(); end

  def self._mailer_class=(value); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  def assert_emails(number, &block); end

  def assert_enqueued_email_with(mailer, method, args: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_emails(number, &block); end

  def assert_no_emails(&block); end

  def assert_no_enqueued_emails(&block); end
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable
  def as_json(*arg); end

  def attachable_content_type(); end

  def attachable_filename(); end

  def attachable_filesize(); end

  def attachable_metadata(); end

  def attachable_sgid(); end

  def previewable_attachable?(); end

  def to_attachable_partial_path(); end

  def to_rich_text_attributes(attributes=T.unsafe(nil)); end

  def to_trix_content_attachment_partial_path(); end
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

module ActionText::Attachable
  def self.from_attachable_sgid(sgid, options=T.unsafe(nil)); end

  def self.from_node(node); end
end

class ActionText::Attachables::ContentAttachment
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def model_name(*arg, **arg1, &arg2); end

  def name(); end

  def name=(name); end

  def to_trix_content_attachment_partial_path(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.from_node(node); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*arg, **arg1, &arg2); end
end

module ActionText::Attachables::MissingAttachable
  def self.to_partial_path(); end
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(*arg, **arg1, &arg2); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  def self.from_node(node); end
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  def attachable(); end

  def caption(); end

  def full_attributes(); end

  def initialize(node, attachable); end

  def method_missing(method, *args, **arg, &block); end

  def node(); end

  def tag_name(); end

  def tag_name=(val); end

  def to_html(); end

  def to_param(*arg, **arg1, &arg2); end

  def to_plain_text(); end

  def with_full_attributes(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  def self.fragment_by_canonicalizing_attachments(content); end

  def self.from_attachable(attachable, attributes=T.unsafe(nil)); end

  def self.from_attachables(attachables); end

  def self.from_attributes(attributes, attachable=T.unsafe(nil)); end

  def self.from_node(node, attachable=T.unsafe(nil)); end

  def self.tag_name(); end

  def self.tag_name=(val); end
end

class ActionText::AttachmentGallery
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(*arg, **arg1, &arg2); end

  def node(); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.attachment_selector(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end

  def self.selector(); end
end

module ActionText::Attachments::Caching
  def cache_key(*args); end
end

module ActionText::Attachments::TrixConversion
  def to_trix_attachment(content=T.unsafe(nil)); end
end

class ActionText::Content
  include ::ActionText::Serialization
  def ==(other); end

  def append_attachables(attachables); end

  def as_json(*arg); end

  def attachables(); end

  def attachment_galleries(); end

  def attachments(); end

  def blank?(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def fragment(); end

  def gallery_attachments(); end

  def html_safe(*arg, **arg1, &arg2); end

  def initialize(content=T.unsafe(nil), options=T.unsafe(nil)); end

  def links(); end

  def present?(*arg, **arg1, &arg2); end

  def render(*arg, **arg1, &arg2); end

  def render_attachment_galleries(&block); end

  def render_attachments(**options, &block); end

  def to_html(); end

  def to_partial_path(); end

  def to_plain_text(); end

  def to_rendered_html_with_layout(); end

  def to_trix_html(); end
end

class ActionText::Content
  def self.default_renderer(); end

  def self.default_renderer=(val); end

  def self.fragment_by_canonicalizing_content(content); end

  def self.renderer(); end

  def self.renderer=(obj); end
end

module ActionText::ContentHelper
  def allowed_attributes(); end

  def allowed_attributes=(val); end

  def allowed_tags(); end

  def allowed_tags=(val); end

  def render_action_text_attachment(attachment, locals: T.unsafe(nil)); end

  def render_action_text_attachments(content); end

  def render_action_text_content(content); end

  def sanitize_action_text_content(content); end

  def sanitizer(); end

  def sanitizer=(val); end

  def scrubber(); end

  def scrubber=(val); end
end

module ActionText::ContentHelper
  def self.allowed_attributes(); end

  def self.allowed_attributes=(val); end

  def self.allowed_tags(); end

  def self.allowed_tags=(val); end

  def self.sanitizer(); end

  def self.sanitizer=(val); end

  def self.scrubber(); end

  def self.scrubber=(val); end
end

module ActionText::EncryptedRichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::Encryption
  def decrypt(); end

  def encrypt(); end
end

class ActionText::FixtureSet
end

class ActionText::FixtureSet
  def self.attachment(fixture_set_name, label, column_type: T.unsafe(nil)); end
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::Rendering::ClassMethods
  def render(*args, &block); end

  def with_renderer(renderer); end
end

class ActionText::RichText
  def autosave_associated_records_for_embeds_attachments(*args); end

  def autosave_associated_records_for_embeds_blobs(*args); end

  def autosave_associated_records_for_record(*args); end

  def blank?(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def nil?(*arg, **arg1, &arg2); end

  def present?(*arg, **arg1, &arg2); end

  def to_plain_text(); end

  def to_s(*arg, **arg1, &arg2); end

  def to_trix_html(); end

  def validate_associated_records_for_embeds_attachments(*args); end

  def validate_associated_records_for_embeds_blobs(*args); end
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
  def purge(); end

  def purge_later(); end
end

module ActionText::RichText::GeneratedAssociationMethods
  def embeds(); end

  def embeds=(attachables); end

  def embeds_attachment_ids(); end

  def embeds_attachment_ids=(ids); end

  def embeds_attachments(); end

  def embeds_attachments=(value); end

  def embeds_blob_ids(); end

  def embeds_blob_ids=(ids); end

  def embeds_blobs(); end

  def embeds_blobs=(value); end

  def record(); end

  def record=(value); end

  def record_changed?(); end

  def record_previously_changed?(); end

  def reload_record(); end
end

module ActionText::RichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActionText::RichText
  def self.with_attached_embeds(*args, **arg); end
end

module ActionText::Serialization
  def _dump(*arg); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::TagHelper
  def rich_text_area_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionText::TagHelper
  def self.id(); end

  def self.id=(val); end
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def any_templates?(*arg, **arg1, &arg2); end

  def formats(*arg, **arg1, &arg2); end

  def initialize(lookup_context); end

  def render(); end

  def template_exists?(*arg, **arg1, &arg2); end
  NO_DETAILS = ::T.let(nil, ::T.untyped)
end

module ActionView::AbstractRenderer::ObjectRendering
  def initialize(lookup_context, options); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedCollection
  def body(); end

  def format(); end

  def initialize(rendered_templates, spacer); end

  def rendered_templates(); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
  def body(); end

  def format(); end

  def initialize(format); end
end

class ActionView::AbstractRenderer::RenderedCollection
  def self.empty(format); end
end

class ActionView::AbstractRenderer::RenderedTemplate
  def body(); end

  def format(); end

  def initialize(body, template); end

  def template(); end
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ERB::Escape
  def _routes(); end

  def _routes=(_routes); end

  def _routes?(); end

  def _run(method, template, locals, buffer, add_to_stack: T.unsafe(nil), &block); end

  def annotate_rendered_view_with_filenames(); end

  def annotate_rendered_view_with_filenames=(val); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(val); end

  def compiled_method_container(); end

  def config(); end

  def config=(config); end

  def debug_missing_translation(); end

  def debug_missing_translation=(val); end

  def default_formats(); end

  def default_formats=(val); end

  def field_error_proc(); end

  def field_error_proc=(val); end

  def formats(*arg, **arg1, &arg2); end

  def formats=(arg); end

  def in_rendering_context(options); end

  def initialize(lookup_context, assigns, controller); end

  def locale(*arg, **arg1, &arg2); end

  def locale=(arg); end

  def logger=(logger); end

  def logger?(); end

  def lookup_context(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(prefix_partial_path_with_controller_namespace); end

  def prefix_partial_path_with_controller_namespace?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(val); end

  def view_paths(*arg, **arg1, &arg2); end

  def view_paths=(arg); end

  def view_renderer(); end
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(value); end

  def self._routes?(); end

  def self.annotate_rendered_view_with_filenames(); end

  def self.annotate_rendered_view_with_filenames=(val); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(val); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.changed?(other); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(val); end

  def self.default_form_builder(); end

  def self.default_form_builder=(val); end

  def self.default_formats(); end

  def self.default_formats=(val); end

  def self.empty(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(val); end

  def self.logger(); end

  def self.logger=(value); end

  def self.logger?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(value); end

  def self.prefix_partial_path_with_controller_namespace?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(val); end

  def self.with_context(context, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.with_empty_template_cache(); end

  def self.with_view_paths(view_paths, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.xss_safe?(); end
end

class ActionView::CacheExpiry::Executor
  def complete(_); end

  def initialize(watcher:); end

  def run(); end
end

class ActionView::CacheExpiry::ViewModificationWatcher
  def execute_if_updated(); end

  def initialize(watcher:, &block); end
end

class ActionView::CollectionRenderer
  include ::ActionView::AbstractRenderer::ObjectRendering
  def render_collection_derive_partial(collection, context, block); end

  def render_collection_with_partial(collection, partial, context, block); end
end

class ActionView::CollectionRenderer::CollectionIterator
  include ::Enumerable
  def each(&blk); end

  def initialize(collection); end

  def length(); end

  def size(); end
end

class ActionView::CollectionRenderer::CollectionIterator
end

class ActionView::CollectionRenderer::MixedCollectionIterator
  def each_with_info(); end

  def initialize(collection, paths); end
end

class ActionView::CollectionRenderer::MixedCollectionIterator
end

class ActionView::CollectionRenderer::PreloadCollectionIterator
  def initialize(collection, path, variables, relation); end
end

class ActionView::CollectionRenderer::PreloadCollectionIterator
end

class ActionView::CollectionRenderer::SameCollectionIterator
  def each_with_info(); end

  def from_collection(collection); end

  def initialize(collection, path, variables); end
end

class ActionView::CollectionRenderer::SameCollectionIterator
end

class ActionView::CollectionRenderer
end

module ActionView::Context
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker::RipperTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::RipperTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker
  def self.find_dependencies(name, template, view_paths=T.unsafe(nil)); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor
  def self.digest(name:, finder:, format: T.unsafe(nil), dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path); end

  def path(); end

  def to_path(); end
end

module ActionView::Helpers::AssetTagHelper
  def apply_stylesheet_media_default(); end

  def apply_stylesheet_media_default=(val); end

  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_decoding(); end

  def image_decoding=(val); end

  def image_loading(); end

  def image_loading=(val); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def preload_link_tag(source, options=T.unsafe(nil)); end

  def preload_links_header(); end

  def preload_links_header=(val); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
  MAX_HEADER_SIZE = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetTagHelper
  def self.apply_stylesheet_media_default(); end

  def self.apply_stylesheet_media_default=(val); end

  def self.image_decoding(); end

  def self.image_decoding=(val); end

  def self.image_loading(); end

  def self.image_loading=(val); end

  def self.preload_links_header(); end

  def self.preload_links_header=(val); end
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def public_compute_asset_path(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), skip_digest: T.unsafe(nil), digest_path: T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def caching?(); end

  def digest_path_from_template(template); end

  def uncacheable!(); end
end

module ActionView::Helpers::CaptureHelper
  def capture(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::ControllerHelper
  def action_name(*arg, **arg1, &arg2); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*arg, **arg1, &arg2); end

  def controller_path(*arg, **arg1, &arg2); end

  def cookies(*arg, **arg1, &arg2); end

  def flash(*arg, **arg1, &arg2); end

  def headers(*arg, **arg1, &arg2); end

  def logger(); end

  def params(*arg, **arg1, &arg2); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*arg, **arg1, &arg2); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def response(*arg, **arg1, &arg2); end

  def session(*arg, **arg1, &arg2); end
end

module ActionView::Helpers::CspHelper
  def csp_meta_tag(**options); end
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
end

module ActionView::Helpers::DebugHelper
  def debug(object); end
end

module ActionView::Helpers::FormHelper
  def _object_for_form_builder(object); end

  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(record, options=T.unsafe(nil), &block); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options, &block); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(val); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(val); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def multiple_file_field_include_hidden(); end

  def multiple_file_field_include_hidden=(val); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def rich_text_area(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(val); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(val); end

  def self.multiple_file_field_include_hidden(); end

  def self.multiple_file_field_include_hidden=(val); end
end

module ActionView::Helpers::FormOptionsHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def weekday_options_for_select(selected=T.unsafe(nil), index_as_value: T.unsafe(nil), day_format: T.unsafe(nil), beginning_of_week: T.unsafe(nil)); end

  def weekday_select(object, method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def default_enforce_utf8(); end

  def default_enforce_utf8=(val); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(val); end

  def field_id(object_name, method_name, *suffixes, index: T.unsafe(nil), namespace: T.unsafe(nil)); end

  def field_name(object_name, method_name, *method_names, multiple: T.unsafe(nil), index: T.unsafe(nil)); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  def self.default_enforce_utf8(); end

  def self.default_enforce_utf8=(val); end

  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(val); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end

  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::TagHelper
  def cdata_section(content); end

  def class_names(*args); end

  def content_tag(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name=T.unsafe(nil), options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end

  def token_list(*args); end
  ARIA_PREFIXES = ::T.let(nil, ::T.untyped)
  DATA_PREFIXES = ::T.let(nil, ::T.untyped)
  TAG_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  def self.build_tag_values(*args); end
end

module ActionView::Helpers::TextHelper
  def concat(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil), &block); end

  def pluralize(count, singular, plural_arg=T.unsafe(nil), plural: T.unsafe(nil), locale: T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, line_width: T.unsafe(nil), break_sequence: T.unsafe(nil)); end
end

module ActionView::Helpers::TranslationHelper
  def l(object, **options); end

  def localize(object, **options); end

  def t(key, **options); end

  def translate(key, **options); end
end

module ActionView::Helpers::TranslationHelper
  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(raise_on_missing_translations); end
end

module ActionView::Helpers::UrlHelper
  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def button_to_generates_button_tag(); end

  def button_to_generates_button_tag=(val); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def phone_to(phone_number, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def sms_to(phone_number, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
end

module ActionView::Helpers::UrlHelper
  def self.button_to_generates_button_tag(); end

  def self.button_to_generates_button_tag=(val); end
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

module ActionView::Layouts
  def _layout_conditions(*arg, **arg1, &arg2); end

  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*arg); end
end

class ActionView::LogSubscriber
  def render_collection(event); end

  def render_layout(event); end

  def render_partial(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LookupContext
  def digest_cache(); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def rendered_format(); end

  def rendered_format=(rendered_format); end

  def with_prepended_formats(formats); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.details_cache_key(details); end

  def self.digest_cache(details); end

  def self.digest_caches(); end

  def self.view_context_class(klass); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end
end

class ActionView::LookupContext
  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(registered_details); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *arg); end

  def partial(); end

  def paths(); end

  def prefixes(); end
end

class ActionView::MissingTemplate::Results
  def add(path, score); end

  def initialize(size); end

  def should_record?(score); end

  def to_a(); end
end

class ActionView::MissingTemplate::Results::Result
  def path(); end

  def path=(_); end

  def score(); end

  def score=(_); end
end

class ActionView::MissingTemplate::Results::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

class ActionView::ObjectRenderer
  include ::ActionView::AbstractRenderer::ObjectRendering
  def render_object_derive_partial(object, context, block); end

  def render_object_with_partial(object, partial, context, block); end
end

class ActionView::ObjectRenderer
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*arg); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialRenderer
  def collection_cache(); end

  def collection_cache=(val); end

  def initialize(lookup_context, options); end

  def render(partial, context, block); end
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(val); end
end

class ActionView::PathSet
  def +(array); end

  def <<(*args); end

  def [](*arg, **arg1, &arg2); end

  def concat(*args); end

  def each(*arg, **arg1, &arg2); end

  def exists?(path, prefixes, partial, details, details_key, locals); end

  def find(path, prefixes, partial, details, details_key, locals); end

  def find_all(path, prefixes, partial, details, details_key, locals); end

  def include?(*arg, **arg1, &arg2); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*arg, **arg1, &arg2); end

  def push(*args); end

  def size(*arg, **arg1, &arg2); end

  def to_ary(); end

  def unshift(*args); end
end

module ActionView::RecordIdentifier
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end
end

class ActionView::RenderParser
  def initialize(name, code); end

  def render_calls(); end
  ALL_KNOWN_KEYS = ::T.let(nil, ::T.untyped)
  RENDER_TYPE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionView::RenderParser::RipperASTParser
  def parse_render_nodes(code); end
end

class ActionView::RenderParser::RipperASTParser::Node
  def argument_nodes(); end

  def call?(); end

  def call_method_name(); end

  def children(); end

  def fcall?(); end

  def fcall_named?(name); end

  def hash?(); end

  def hash_from_body(body); end

  def initialize(type, arr, opts=T.unsafe(nil)); end

  def string?(); end

  def symbol?(); end

  def to_hash(); end

  def to_string(); end

  def to_symbol(); end

  def type(); end

  def variable_name(); end

  def variable_reference?(); end

  def vcall?(); end
end

class ActionView::RenderParser::RipperASTParser::NodeParser
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(list, item); end

  def on_args_add_block(list, item); end

  def on_args_add_star(list, item); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_dedent(*args); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(list, item); end

  def on_method_add_block(list, item); end

  def on_mlhs_add(list, item); end

  def on_mlhs_add_post(list, item); end

  def on_mlhs_add_star(list, item); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(list, item); end

  def on_mrhs_add_star(list, item); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(list, item); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(list, item); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(list, item); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(list, item); end

  def on_stmts_new(*args); end

  def on_string_add(list, item); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(list, item); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(list, item); end

  def on_word_new(*args); end

  def on_words_add(list, item); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(list, item); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class ActionView::RenderParser::RipperASTParser::RenderCallExtractor
  def initialize(*args); end

  def render_calls(); end
  METHODS_TO_PARSE = ::T.let(nil, ::T.untyped)
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def initialize(); end

  def process(*arg, **arg1, &arg2); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_renderer(); end
end

class ActionView::Resolver
  def all_template_paths(); end

  def caching(); end

  def caching=(val); end

  def caching?(*arg, **arg1, &arg2); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end
end

ActionView::Resolver::Path = ActionView::TemplatePath

class ActionView::Resolver::PathParser
  def build_path_regex(); end

  def parse(path); end
end

class ActionView::Resolver::PathParser::ParsedPath
  def details(); end

  def details=(_); end

  def path(); end

  def path=(_); end
end

class ActionView::Resolver::PathParser::ParsedPath
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(val); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  def default_url_options=(val); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(val); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::SyntaxErrorInTemplate
  def initialize(template, offending_code_string); end
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, locals:, format: T.unsafe(nil), variant: T.unsafe(nil), virtual_path: T.unsafe(nil)); end

  def locals(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def render(view, locals, buffer=T.unsafe(nil), add_to_stack: T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def variable(); end

  def variant(); end

  def virtual_path(); end
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def format(); end

  def identifier(); end

  def initialize(string, type); end

  def render(*args); end

  def to_str(); end

  def type(); end
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template, source); end

  def default_format(); end

  def default_format=(default_format); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(value); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template, source); end

  def erb_implementation(); end

  def erb_implementation=(erb_implementation); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(erb_trim_mode); end

  def erb_trim_mode?(); end

  def escape_ignore_list(); end

  def escape_ignore_list=(escape_ignore_list); end

  def escape_ignore_list?(); end

  def handles_encoding?(); end

  def strip_trailing_newlines(); end

  def strip_trailing_newlines=(strip_trailing_newlines); end

  def strip_trailing_newlines?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  def evaluate(action_view_erb_handler_context); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB
  def self.call(template, source); end

  def self.erb_implementation(); end

  def self.erb_implementation=(value); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(value); end

  def self.erb_trim_mode?(); end

  def self.escape_ignore_list(); end

  def self.escape_ignore_list=(value); end

  def self.escape_ignore_list?(); end

  def self.strip_trailing_newlines(); end

  def self.strip_trailing_newlines=(value); end

  def self.strip_trailing_newlines?(); end
end

class ActionView::Template::Handlers::Raw
  def call(template, source); end
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::RawFile
  def format(); end

  def format=(format); end

  def identifier(); end

  def initialize(filename); end

  def render(*args); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Renderable
  def format(); end

  def identifier(); end

  def initialize(renderable); end

  def render(context, *args); end
end

class ActionView::Template::Renderable
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

class ActionView::Template::Text
  def format(); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Types::Type
  def self.[](type); end
end

module ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.symbols(); end

  def self.type_klass(); end

  def self.type_klass=(type_klass); end
end

class ActionView::Template
  def self.frozen_string_literal(); end

  def self.frozen_string_literal=(frozen_string_literal); end
end

class ActionView::TemplateDetails
  def format(); end

  def format_or_default(); end

  def handler(); end

  def handler_class(); end

  def initialize(locale, handler, format, variant); end

  def locale(); end

  def matches?(requested); end

  def sort_key_for(requested); end

  def variant(); end
end

class ActionView::TemplateDetails::Requested
  def formats(); end

  def formats_idx(); end

  def handlers(); end

  def handlers_idx(); end

  def initialize(locale:, handlers:, formats:, variants:); end

  def locale(); end

  def locale_idx(); end

  def variants(); end

  def variants_idx(); end
  ANY_HASH = ::T.let(nil, ::T.untyped)
end

class ActionView::TemplateDetails::Requested
end

class ActionView::TemplateDetails
end

class ActionView::TemplatePath
  def ==(other); end

  def eql?(other); end

  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end

  def virtual_path(); end
end

class ActionView::TemplatePath
  def self.build(name, prefix, partial); end

  def self.parse(virtual); end

  def self.virtual(name, prefix, partial); end
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(val); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*arg, **arg1, &arg2); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def request(); end

  def request=(request); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*arg); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

module ActionView::TestCase::HelperMethods
  def _test_case(); end

  def protect_against_forgery?(); end
end

class ActionView::TestCase::TestController
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(val); end
end

class ActionView::UnboundTemplate
  def bind_locals(locals); end

  def details(); end

  def format(*arg, **arg1, &arg2); end

  def handler(*arg, **arg1, &arg2); end

  def initialize(source, identifier, details:, virtual_path:); end

  def locale(*arg, **arg1, &arg2); end

  def variant(*arg, **arg1, &arg2); end

  def virtual_path(); end
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*arg, **arg1, &arg2); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*arg, **arg1, &arg2); end

  def formats=(arg); end

  def locale(*arg, **arg1, &arg2); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*arg, **arg1, &arg2); end

  def view_paths(*arg, **arg1, &arg2); end
end

module ActionView::ViewPaths
  def self.all_view_paths(); end

  def self.get_view_paths(klass); end

  def self.set_view_paths(klass, paths); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def logger(); end

  def logger=(val); end

  def queue_adapter(*arg, **arg1, &arg2); end

  def queue_name_prefix(); end

  def queue_name_prefix=(queue_name_prefix); end

  def queue_name_prefix?(); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end
end

class ActiveJob::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(value); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(value); end

  def self._test_adapter(); end

  def self._test_adapter=(value); end

  def self.log_arguments(); end

  def self.log_arguments=(value); end

  def self.log_arguments?(); end

  def self.logger(); end

  def self.logger=(val); end

  def self.priority(); end

  def self.priority=(value); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(value); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(value); end

  def self.queue_name_delimiter?(); end

  def self.queue_name_prefix(); end

  def self.queue_name_prefix=(value); end

  def self.queue_name_prefix?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.retry_jitter(); end

  def self.retry_jitter=(value); end

  def self.skip_after_callbacks_if_terminated(*args, **arg, &block); end

  def self.skip_after_callbacks_if_terminated=(*args, **arg, &block); end
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Callbacks
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*arg, **arg1, &arg2); end

  def perform_now(*arg, **arg1, &arg2); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def arguments(); end

  def arguments=(arguments); end

  def deserialize(job_data); end

  def enqueue_error(); end

  def enqueue_error=(enqueue_error); end

  def enqueued_at(); end

  def enqueued_at=(enqueued_at); end

  def exception_executions(); end

  def exception_executions=(exception_executions); end

  def executions(); end

  def executions=(executions); end

  def initialize(*arguments, **arg); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def priority=(priority); end

  def provider_job_id(); end

  def provider_job_id=(provider_job_id); end

  def queue_name=(queue_name); end

  def scheduled_at(); end

  def scheduled_at=(scheduled_at); end

  def serialize(); end

  def serialized_arguments=(serialized_arguments); end

  def set(options=T.unsafe(nil)); end

  def successfully_enqueued=(successfully_enqueued); end

  def successfully_enqueued?(); end

  def timezone(); end

  def timezone=(timezone); end
end

class ActiveJob::DeserializationError
  def initialize(); end
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end
end

module ActiveJob::Exceptions
  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Execution
  def perform(*arg); end

  def perform_now(); end
end

module ActiveJob::Instrumentation
  def perform_now(); end
end

class ActiveJob::LogSubscriber
  def discard(event); end

  def enqueue(event); end

  def enqueue_at(event); end

  def enqueue_retry(event); end

  def perform(event); end

  def perform_start(event); end

  def retry_stopped(event); end
end

module ActiveJob::Logging
  def perform_now(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def immediate=(immediate); end

  def initialize(**executor_options); end

  def shutdown(wait: T.unsafe(nil)); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
  def initialize(job); end

  def perform(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  def enqueue(job, queue_name:); end

  def enqueue_at(job, timestamp, queue_name:); end

  def executor(); end

  def immediate(); end

  def immediate=(immediate); end

  def initialize(**options); end

  def shutdown(wait: T.unsafe(nil)); end
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*arg); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def at(); end

  def at=(at); end

  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  def self.lookup(name); end
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueuePriority
  def priority(); end
end

module ActiveJob::Serializers
  def _additional_serializers(); end

  def _additional_serializers=(val); end
end

class ActiveJob::Serializers::DateSerializer
  def deserialize(hash); end

  def serialize(date); end
end

class ActiveJob::Serializers::DateTimeSerializer
  def deserialize(hash); end
end

class ActiveJob::Serializers::DurationSerializer
  def deserialize(hash); end

  def serialize(duration); end
end

class ActiveJob::Serializers::ModuleSerializer
  def deserialize(hash); end

  def serialize(constant); end
end

class ActiveJob::Serializers::ObjectSerializer
  def deserialize(json); end

  def serialize(hash); end

  def serialize?(argument); end
end

class ActiveJob::Serializers::ObjectSerializer
  def self.deserialize(*arg, **arg1, &arg2); end

  def self.serialize(*arg, **arg1, &arg2); end

  def self.serialize?(*arg, **arg1, &arg2); end
end

class ActiveJob::Serializers::RangeSerializer
  def deserialize(hash); end

  def serialize(range); end
  KEYS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Serializers::SymbolSerializer
  def deserialize(argument); end

  def serialize(argument); end
end

class ActiveJob::Serializers::TimeObjectSerializer
  def serialize(time); end
  NANO_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Serializers::TimeSerializer
  def deserialize(hash); end
end

class ActiveJob::Serializers::TimeWithZoneSerializer
  def deserialize(hash); end
end

module ActiveJob::Serializers
  def self._additional_serializers(); end

  def self._additional_serializers=(val); end

  def self.add_serializers(*new_serializers); end

  def self.deserialize(argument); end

  def self.serialize(argument); end

  def self.serializers(); end
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
  def after_teardown(); end

  def assert_enqueued_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), priority: T.unsafe(nil), &block); end

  def assert_no_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_no_performed_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), priority: T.unsafe(nil), &block); end

  def before_setup(); end

  def enqueued_jobs(*arg, **arg1, &arg2); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), at: T.unsafe(nil), &block); end

  def performed_jobs(*arg, **arg1, &arg2); end

  def performed_jobs=(arg); end

  def queue_adapter(); end

  def queue_adapter_for_test(); end
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::API
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

class ActiveModel::Attribute::UserProvidedDefault
  def initialize(name, value, type, database_default); end

  def marshal_dump(); end

  def marshal_load(values); end
end

module ActiveModel::AttributeAssignment
  def assign_attributes(new_attributes); end

  def attributes=(new_attributes); end
end

module ActiveModel::AttributeMethods
  FORWARD_PARAMETERS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def force_change(attr_name); end

  def forget_change(attr_name); end

  def initialize(attributes); end

  def original_value(attr_name); end
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def freeze(); end

  def initialize(*arg); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, cast_type=T.unsafe(nil), default: T.unsafe(nil), **options); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::BlockValidator
  def initialize(options, &block); end
end

module ActiveModel::Callbacks
  def define_model_callbacks(*callbacks); end
end

module ActiveModel::Callbacks
  def self.extended(base); end
end

module ActiveModel::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end

  def to_partial_path(); end
end

module ActiveModel::Dirty
  def as_json(options=T.unsafe(nil)); end

  def attribute_previously_was(attr_name); end

  def attribute_was(attr_name); end

  def changed(); end

  def changed_attributes(); end

  def changes(); end

  def changes_applied(); end

  def clear_attribute_changes(attr_names); end

  def clear_changes_information(); end

  def restore_attributes(attr_names=T.unsafe(nil)); end
end

class ActiveModel::EachValidator
  def attributes(); end

  def check_validity!(); end

  def initialize(options); end

  def validate_each(record, attribute, value); end
end

class ActiveModel::Error
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Errors
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
end

class ActiveModel::ForcedMutationTracker
  def finalize_changes(); end
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

class ActiveModel::Name
  def !~(*arg, **arg1, &arg2); end

  def ==(arg); end

  def ===(arg); end

  def =~(*arg, **arg1, &arg2); end

  def as_json(*arg, **arg1, &arg2); end

  def cache_key(); end

  def collection(); end

  def collection=(collection); end

  def element(); end

  def element=(element); end

  def eql?(*arg, **arg1, &arg2); end

  def human(options=T.unsafe(nil)); end

  def i18n_key(); end

  def i18n_key=(i18n_key); end

  def initialize(klass, namespace=T.unsafe(nil), name=T.unsafe(nil), locale=T.unsafe(nil)); end

  def match?(*arg, **arg1, &arg2); end

  def name(); end

  def name=(name); end

  def param_key(); end

  def param_key=(param_key); end

  def plural(); end

  def plural=(plural); end

  def route_key(); end

  def route_key=(route_key); end

  def singular(); end

  def singular=(singular); end

  def singular_route_key(); end

  def singular_route_key=(singular_route_key); end

  def to_s(*arg, **arg1, &arg2); end

  def to_str(*arg, **arg1, &arg2); end

  def uncountable?(); end
end

module ActiveModel::Naming
  def model_name(); end
end

module ActiveModel::Naming
  def self.extended(base); end

  def self.param_key(record_or_class); end

  def self.plural(record_or_class); end

  def self.route_key(record_or_class); end

  def self.singular(record_or_class); end

  def self.singular_route_key(record_or_class); end

  def self.uncountable?(record_or_class); end
end

class ActiveModel::NullMutationTracker
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, **arg); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def original_value(attr_name); end
end

module ActiveModel::SecurePassword
  def self.min_cost(); end

  def self.min_cost=(min_cost); end
end

module ActiveModel::Serialization
  def read_attribute_for_serialization(*arg); end

  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveModel::Serializers::JSON
  def as_json(options=T.unsafe(nil)); end

  def from_json(json, include_root=T.unsafe(nil)); end
end

module ActiveModel::Translation
  def human_attribute_name(attribute, options=T.unsafe(nil)); end

  def i18n_scope(); end

  def lookup_ancestors(); end
end

class ActiveModel::Type::Binary
  def changed_in_place?(raw_old_value, value); end
end

class ActiveModel::Type::Binary::Data
  def ==(other); end

  def hex(); end

  def initialize(value); end

  def to_str(); end
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
  def initialize(defaults: T.unsafe(nil)); end
end

module ActiveModel::Type::Helpers::AcceptsMultiparameterTime::InstanceMethods
  def assert_valid_value(value); end

  def cast(value); end

  def serialize(value); end

  def value_constructed_by_mass_assignment?(value); end
end

module ActiveModel::Type::Helpers::Mutable
  def cast(value); end

  def changed_in_place?(raw_old_value, new_value); end

  def mutable?(); end
end

module ActiveModel::Type::Helpers::Numeric
  def cast(value); end

  def changed?(old_value, _new_value, new_value_before_type_cast); end

  def serialize(value); end
end

module ActiveModel::Type::Helpers::TimeValue
  def apply_seconds_precision(value); end

  def serialize(value); end

  def type_cast_for_schema(value); end

  def user_input_in_time_zone(value); end
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

class ActiveModel::Type::ImmutableString
  def initialize(**args); end
end

class ActiveModel::Type::Integer
  def initialize(**arg); end
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Registry
  def lookup(symbol, *args, **arg); end

  def register(type_name, klass=T.unsafe(nil), &block); end
end

class ActiveModel::Type::String
  def to_immutable_string(); end
end

class ActiveModel::Type::Value
  def ==(other); end

  def assert_valid_value(_); end

  def binary?(); end

  def changed?(old_value, new_value, _new_value_before_type_cast); end

  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end

  def eql?(other); end

  def force_equality?(_value); end

  def limit(); end

  def map(value); end

  def mutable?(); end

  def precision(); end

  def scale(); end

  def serializable?(value); end

  def serialize(value); end

  def serialized?(); end

  def type(); end

  def type_cast_for_schema(value); end

  def value_constructed_by_mass_assignment?(_value); end
end

module ActiveModel::Type
  def self.default_value(); end

  def self.lookup(*arg, **arg1, &arg2); end

  def self.register(type_name, klass=T.unsafe(nil), &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveModel::ValidationError
  def initialize(model); end

  def model(); end
end

module ActiveModel::Validations
  def read_attribute_for_validation(*arg); end

  def validate(context=T.unsafe(nil)); end

  def validate!(context=T.unsafe(nil)); end

  def validates_with(*args, &block); end
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end

  def validates_acceptance_of(*attr_names); end

  def validates_comparison_of(*attr_names); end

  def validates_confirmation_of(*attr_names); end

  def validates_exclusion_of(*attr_names); end

  def validates_format_of(*attr_names); end

  def validates_inclusion_of(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_numericality_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end
end

class ActiveModel::Validator
  def initialize(options=T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def validate(record); end
end

class ActiveModel::Validator
  def self.kind(); end
end

module ActiveRecord::Aggregations
  def reload(*arg); end
end

module ActiveRecord::Aggregations::ClassMethods
  def composed_of(part_id, options=T.unsafe(nil)); end
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation
  def initialize(klass, macro, association_name, options, possible_sources); end
end

class ActiveRecord::AssociationNotFoundError
  def association_name(); end

  def initialize(record=T.unsafe(nil), association_name=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::AssociationRelation
  def initialize(klass, association, **arg); end

  def insert(attributes, **kwargs); end

  def insert!(attributes, **kwargs); end

  def insert_all(attributes, **kwargs); end

  def insert_all!(attributes, **kwargs); end

  def proxy_association(); end

  def upsert(attributes, **kwargs); end

  def upsert_all(attributes, **kwargs); end
end

module ActiveRecord::Associations
  def association(name); end

  def association_cached?(name); end
end

class ActiveRecord::AsynchronousQueriesTracker
  def current_session(); end

  def finalize_session(); end

  def start_session(); end
end

module ActiveRecord::AsynchronousQueriesTracker::NullSession
  def self.active?(); end

  def self.finalize(); end
end

class ActiveRecord::AsynchronousQueriesTracker::Session
  def active?(); end

  def finalize(); end
end

class ActiveRecord::AsynchronousQueriesTracker
  def self.complete(asynchronous_queries_tracker); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  def attributes_before_type_cast(); end

  def attributes_for_database(); end

  def read_attribute_before_type_cast(attr_name); end
end

module ActiveRecord::AttributeMethods::Dirty
  def attribute_before_last_save(attr_name); end

  def attribute_change_to_be_saved(attr_name); end

  def attribute_in_database(attr_name); end

  def attributes_in_database(); end

  def changed_attribute_names_to_save(); end

  def changes_to_save(); end

  def has_changes_to_save?(); end

  def reload(*arg); end

  def saved_change_to_attribute(attr_name); end

  def saved_changes(); end

  def saved_changes?(); end

  def will_save_change_to_attribute?(attr_name, **options); end
end

module ActiveRecord::AttributeMethods::PrimaryKey
  def id(); end

  def id=(value); end

  def id?(); end

  def id_before_type_cast(); end

  def id_for_database(); end

  def id_in_database(); end

  def id_was(); end

  def to_key(); end
end

module ActiveRecord::AttributeMethods::Query
  def query_attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Read
  def _read_attribute(attr_name, &block); end

  def read_attribute(attr_name, &block); end
end

module ActiveRecord::AttributeMethods::Write
  def _write_attribute(attr_name, value); end

  def write_attribute(attr_name, value); end
end

module ActiveRecord::AutosaveAssociation
  def changed_for_autosave?(); end

  def destroyed_by_association(); end

  def destroyed_by_association=(reflection); end

  def mark_for_destruction(); end

  def marked_for_destruction?(); end

  def reload(options=T.unsafe(nil)); end
end

class ActiveRecord::Base
  include ::ActionText::Encryption
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _commit_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def attachment_reflections(); end

  def attachment_reflections?(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def automatic_scope_inversing(); end

  def automatic_scope_inversing?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def collection_cache_versioning(); end

  def collection_cache_versioning?(); end

  def column_for_attribute(*arg, **arg1, &arg2); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_role(); end

  def default_role?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_shard(); end

  def default_shard?(); end

  def defined_enums(); end

  def defined_enums?(); end

  def destroy_association_async_job(); end

  def encrypted_attributes(); end

  def encrypted_attributes=(encrypted_attributes); end

  def encrypted_attributes?(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def logger?(); end

  def model_name(*arg, **arg1, &arg2); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_inserts(); end

  def partial_inserts?(); end

  def partial_updates(); end

  def partial_updates?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def primary_key_prefix_type?(); end

  def record_timestamps(); end

  def record_timestamps=(record_timestamps); end

  def record_timestamps?(); end

  def signed_id_verifier_secret(); end

  def signed_id_verifier_secret?(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_class_name(); end

  def store_full_class_name?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_attributes?(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def type_for_attribute(*arg, **arg1, &arg2); end

  def validation_context(); end
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(value); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(value); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(value); end

  def self.aggregate_reflections?(); end

  def self.application_record_class?(); end

  def self.asynchronous_queries_session(); end

  def self.asynchronous_queries_tracker(); end

  def self.attachment_reflections(); end

  def self.attachment_reflections=(value); end

  def self.attachment_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(value); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(value); end

  def self.attribute_method_matchers?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(value); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.automatic_scope_inversing(); end

  def self.automatic_scope_inversing=(value); end

  def self.automatic_scope_inversing?(); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(value); end

  def self.belongs_to_required_by_default?(); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(value); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(value); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(value); end

  def self.collection_cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connected_to_stack(); end

  def self.connection_class(); end

  def self.connection_class=(b); end

  def self.connection_class?(); end

  def self.connection_class_for_self(); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.connection_handlers(); end

  def self.connection_handlers=(handlers); end

  def self.current_preventing_writes(); end

  def self.current_role(); end

  def self.current_shard(); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(value); end

  def self.default_connection_handler?(); end

  def self.default_role(); end

  def self.default_role=(value); end

  def self.default_role?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(value); end

  def self.default_scopes(); end

  def self.default_scopes=(value); end

  def self.default_shard(); end

  def self.default_shard=(value); end

  def self.default_shard?(); end

  def self.defined_enums(); end

  def self.defined_enums=(value); end

  def self.defined_enums?(); end

  def self.destroy_association_async_job(); end

  def self.destroy_association_async_job=(value); end

  def self.encrypted_attributes(); end

  def self.encrypted_attributes=(value); end

  def self.encrypted_attributes?(); end

  def self.enumerate_columns_in_select_statements(); end

  def self.enumerate_columns_in_select_statements=(value); end

  def self.enumerate_columns_in_select_statements?(); end

  def self.has_many_inversing(); end

  def self.has_many_inversing=(value); end

  def self.has_many_inversing?(); end

  def self.immutable_strings_by_default(); end

  def self.immutable_strings_by_default=(value); end

  def self.immutable_strings_by_default?(); end

  def self.implicit_order_column(); end

  def self.implicit_order_column=(value); end

  def self.implicit_order_column?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(value); end

  def self.include_root_in_json?(); end

  def self.inheritance_column(); end

  def self.inheritance_column=(value); end

  def self.inheritance_column?(); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(value); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(value); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.logger?(); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(value); end

  def self.nested_attributes_options?(); end

  def self.partial_inserts(); end

  def self.partial_inserts=(value); end

  def self.partial_inserts?(); end

  def self.partial_updates(); end

  def self.partial_updates=(value); end

  def self.partial_updates?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(value); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(value); end

  def self.primary_key_prefix_type?(); end

  def self.record_timestamps(); end

  def self.record_timestamps=(value); end

  def self.record_timestamps?(); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(value); end

  def self.schema_migrations_table_name?(); end

  def self.shard_selector(); end

  def self.shard_selector=(value); end

  def self.shard_selector?(); end

  def self.signed_id_verifier_secret(); end

  def self.signed_id_verifier_secret=(value); end

  def self.signed_id_verifier_secret?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(value); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_class_name(); end

  def self.store_full_class_name=(value); end

  def self.store_full_class_name?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(value); end

  def self.store_full_sti_class?(); end

  def self.strict_loading_by_default(); end

  def self.strict_loading_by_default=(value); end

  def self.strict_loading_by_default?(); end

  def self.strict_loading_violation!(owner:, reflection:); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(value); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(value); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(value); end

  def self.time_zone_aware_attributes?(); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(value); end

  def self.time_zone_aware_types?(); end
end

module ActiveRecord::Batches
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil), &block); end

  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end

  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Batches::BatchEnumerator
  def batch_size(); end

  def delete_all(); end

  def destroy_all(); end

  def each(&block); end

  def each_record(&block); end

  def finish(); end

  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil)); end

  def relation(); end

  def start(); end

  def update_all(updates); end
end

module ActiveRecord::Calculations
  def average(column_name); end

  def calculate(operation, column_name); end

  def count(column_name=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name); end

  def minimum(column_name); end

  def pick(*column_names); end

  def pluck(*column_names); end

  def sum(identity_or_column=T.unsafe(nil), &block); end
end

class ActiveRecord::Calculations::ColumnAliasTracker
  def alias_for(field); end

  def initialize(connection); end
end

module ActiveRecord::Callbacks
  def destroy(); end

  def increment!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def touch(*arg, **arg1); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def advisory_locks_enabled?(); end

  def all_foreign_keys_valid?(); end

  def async_enabled?(); end

  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end

  def case_sensitive_comparison(attribute, value); end

  def check_if_write_query(sql); end

  def check_version(); end

  def clear_cache!(); end

  def close(); end

  def connection_class(); end

  def create(*arg); end

  def create_enum(*arg); end

  def database_version(); end

  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value); end

  def delete(*arg); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def exec_insert_all(*arg); end

  def expire(); end

  def extensions(); end

  def get_advisory_lock(lock_id); end

  def get_database_version(); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*arg); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def prepared_statements?(); end

  def prepared_statements_disabled_cache(); end

  def preventing_writes?(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def replica?(); end

  def requires_reloading?(); end

  def reset!(); end

  def role(); end

  def rollback_db_transaction(*arg); end

  def rollback_to_savepoint(*arg); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_migration(); end

  def schema_version(); end

  def seconds_idle(); end

  def shard(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_check_constraints?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_common_table_expressions?(); end

  def supports_concurrent_connections?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_deferrable_constraints?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_insert_conflict_target?(); end

  def supports_insert_on_duplicate_skip?(); end

  def supports_insert_on_duplicate_update?(); end

  def supports_insert_returning?(); end

  def supports_json?(); end

  def supports_lazy_transactions?(); end

  def supports_materialized_views?(); end

  def supports_optimizer_hints?(); end

  def supports_partial_index?(); end

  def supports_partitioned_indexes?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def throw_away!(); end

  def truncate(*arg); end

  def truncate_tables(*arg); end

  def unprepared_statement(); end

  def update(*arg); end

  def use_metadata_table?(); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end

  def with_instrumenter(instrumenter, &block); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
  TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  def full_version_string(); end

  def initialize(version_string, full_version_string=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.build_read_query_regexp(*parts); end

  def self.database_exists?(config); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
  def get_schema_cache(connection); end

  def lazily_set_schema_cache(); end

  def set_schema_cache(cache); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def column(); end

  def column=(_); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_check_constraint(expression, options); end

  def add_column(name, type, **options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def check_constraint_adds(); end

  def check_constraint_drops(); end

  def drop_check_constraint(constraint_name); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition
  def export_name_on_schema_dump?(); end

  def expression(); end

  def expression=(_); end

  def name(); end

  def options(); end

  def options=(_); end

  def table_name(); end

  def table_name=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::Column
  def ==(other); end

  def bigint?(); end

  def collation(); end

  def comment(); end

  def default(); end

  def default_function(); end

  def encode_with(coder); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def init_with(coder); end

  def initialize(name, default, sql_type_metadata=T.unsafe(nil), null=T.unsafe(nil), default_function=T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **arg); end

  def limit(*arg, **arg1, &arg2); end

  def name(); end

  def null(); end

  def precision(*arg, **arg1, &arg2); end

  def scale(*arg, **arg1, &arg2); end

  def sql_type(*arg, **arg1, &arg2); end

  def sql_type_metadata(); end

  def type(*arg, **arg1, &arg2); end

  def virtual?(); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def aliased_types(name, fallback); end

  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def limit(); end

  def limit=(value); end

  def name(); end

  def name=(_); end

  def null(); end

  def null=(value); end

  def options(); end

  def options=(_); end

  def precision(); end

  def precision=(value); end

  def primary_key?(); end

  def scale(); end

  def scale=(value); end

  def sql_type(); end

  def sql_type=(_); end

  def type(); end

  def type=(_); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def active_connections?(role=T.unsafe(nil)); end

  def all_connection_pools(); end

  def clear_active_connections!(role=T.unsafe(nil)); end

  def clear_all_connections!(role=T.unsafe(nil)); end

  def clear_reloadable_connections!(role=T.unsafe(nil)); end

  def connected?(spec_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def connection_pool_list(role=T.unsafe(nil)); end

  def connection_pool_names(); end

  def connection_pools(role=T.unsafe(nil)); end

  def establish_connection(config, owner_name: T.unsafe(nil), role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def flush_idle_connections!(role=T.unsafe(nil)); end

  def prevent_writes(); end

  def prevent_writes=(prevent_writes); end

  def remove_connection_pool(owner, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def retrieve_connection(spec_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def retrieve_connection_pool(owner, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def while_preventing_writes(enabled=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler::StringConnectionOwner
  def current_preventing_writes(); end

  def initialize(name); end

  def name(); end

  def primary_class?(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  def active_connection?(); end

  def async_executor(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connection_class(); end

  def connection_klass(*args, **arg, &block); end

  def connections(); end

  def db_config(); end

  def discard!(); end

  def discarded?(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(pool_config); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def pool_config(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def role(); end

  def schedule_query(future_result); end

  def schema_cache(*arg, **arg1, &arg2); end

  def schema_cache=(arg); end

  def shard(); end

  def size(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def self.register_pool(pool, frequency); end
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition
  def algorithm(); end

  def algorithm=(_); end

  def if_not_exists(); end

  def if_not_exists=(_); end

  def index(); end

  def index=(_); end
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def index_name_length(); end

  def max_identifier_length(); end

  def table_alias_length(); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record, ensure_finalize=T.unsafe(nil)); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*arg, **arg1, &arg2); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*arg, **arg1, &arg2); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*arg, **arg1, &arg2); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def disable_lazy_transactions!(*arg, **arg1, &arg2); end

  def empty_insert_statement_value(primary_key=T.unsafe(nil)); end

  def enable_lazy_transactions!(*arg, **arg1, &arg2); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def high_precision_current_timestamp(); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def mark_transaction_written_if_write(sql); end

  def materialize_transactions(*arg, **arg1, &arg2); end

  def open_transactions(*arg, **arg1, &arg2); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*arg, **arg1, &arg2); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil), &block); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def with_yaml_fallback(value); end

  def within_new_transaction(*arg, **arg1, &arg2); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::Deduplicable
  def -@(); end

  def deduplicate(); end
end

module ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
  def new(*arg, **arg1); end

  def registry(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def deferrable(); end

  def defined_for?(to_table: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def column_options(); end

  def columns(); end

  def comment(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::LegacyPoolManager
  def get_pool_config(_, shard); end

  def pool_configs(_=T.unsafe(nil)); end

  def remove_pool_config(_, shard); end

  def set_pool_config(role, shard, pool_config); end

  def shard_names(); end
end

class ActiveRecord::ConnectionAdapters::LegacyPoolManager
end

class ActiveRecord::ConnectionAdapters::NullColumn
  def initialize(name, **arg); end
end

class ActiveRecord::ConnectionAdapters::NullPool
  def async_executor(); end

  def checkin(_); end

  def connection_class(); end

  def remove(_); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record, _=T.unsafe(nil)); end

  def closed?(); end

  def joinable?(); end

  def open?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::PoolConfig
  def connection_class(); end

  def connection_specification_name(); end

  def db_config(); end

  def discard_pool!(); end

  def disconnect!(); end

  def initialize(connection_class, db_config, role, shard); end

  def lock(); end

  def locked?(); end

  def pool(); end

  def role(); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end

  def shard(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActiveRecord::ConnectionAdapters::PoolConfig
  def self.discard_pools!(); end
end

class ActiveRecord::ConnectionAdapters::PoolManager
  def get_pool_config(role, shard); end

  def pool_configs(role=T.unsafe(nil)); end

  def remove_pool_config(role, shard); end

  def remove_role(role); end

  def role_names(); end

  def set_pool_config(role, shard, pool_config); end

  def shard_names(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
  def constraint_validations(); end

  def validate_constraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
  def array(); end

  def array?(); end

  def enum?(); end

  def fmod(*arg, **arg1, &arg2); end

  def initialize(*arg, serial: T.unsafe(nil), generated: T.unsafe(nil), **arg1); end

  def oid(*arg, **arg1, &arg2); end

  def serial?(); end

  def sql_type(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def primary_key(name, type=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil), async: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def high_precision_current_timestamp(); end

  def query(sql, name=T.unsafe(nil)); end

  def write_query?(sql); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  def ==(o); end

  def eql?(o); end

  def identifier(); end

  def initialize(schema, identifier); end

  def parts(); end

  def quoted(); end

  def schema(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
  def delimiter(); end

  def force_equality?(value); end

  def initialize(subtype, delimiter=T.unsafe(nil)); end

  def limit(*arg, **arg1, &arg2); end

  def map(value, &block); end

  def precision(*arg, **arg1, &arg2); end

  def scale(*arg, **arg1, &arg2); end

  def subtype(); end

  def type(*arg, **arg1, &arg2); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def encoder(); end

  def encoder=(_); end

  def values=(_); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
  def binary?(); end

  def hex?(); end

  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
  def real_type_unless_aliased(real_type); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
  def infinity(options=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
  def accessor(); end
  ERROR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
  def force_equality?(value); end

  def initialize(subtype, type=T.unsafe(nil)); end

  def subtype(); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
  def initialize(type, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
  def initialize(store); end

  def query_conditions_for_array_types(); end

  def query_conditions_for_known_type_names(); end

  def query_conditions_for_known_type_types(); end

  def run(records); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
  ACCEPTABLE_UUID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
  def delim(); end

  def initialize(delim, subtype); end

  def subtype(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
  def initialize(value); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  def check_int_in_range(value); end

  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def escape_bytea(value); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(name); end

  def quote_default_expression(value, column); end

  def quote_schema_name(name); end

  def quote_string(s); end

  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def type_cast(value); end

  def unescape_bytea(value); end
  QUOTED_COLUMN_NAMES = ::T.let(nil, ::T.untyped)
  QUOTED_TABLE_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::IntegerOutOf64BitRange
  def initialize(msg); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  def all_foreign_keys_valid?(); end

  def disable_referential_integrity(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  def add_column(table_name, column_name, type, **options); end

  def add_index(table_name, column_name, **options); end

  def change_column(table_name, column_name, type, **options); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table_comment(table_name, comment_or_changes); end

  def check_constraints(table_name); end

  def client_min_messages(); end

  def client_min_messages=(level); end

  def collation(); end

  def columns_for_distinct(columns, orders); end

  def create_database(name, options=T.unsafe(nil)); end

  def create_schema(schema_name); end

  def create_schema_dumper(options); end

  def ctype(); end

  def current_database(); end

  def current_schema(); end

  def default_sequence_name(table_name, pk=T.unsafe(nil)); end

  def drop_database(name); end

  def drop_schema(schema_name, **options); end

  def drop_table(table_name, **options); end

  def encoding(); end

  def foreign_keys(table_name); end

  def foreign_table_exists?(table_name); end

  def foreign_tables(); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def pk_and_sequence_for(table); end

  def primary_keys(table_name); end

  def recreate_database(name, options=T.unsafe(nil)); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def reset_pk_sequence!(table, pk=T.unsafe(nil), sequence=T.unsafe(nil)); end

  def schema_exists?(name); end

  def schema_names(); end

  def schema_search_path(); end

  def schema_search_path=(schema_csv); end

  def serial_sequence(table, column); end

  def set_pk_sequence!(table, value); end

  def table_comment(table_name); end

  def table_options(table_name); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), enum_type: T.unsafe(nil), **arg); end

  def update_table_definition(table_name, base); end

  def validate_check_constraint(table_name, **options); end

  def validate_constraint(table_name, constraint_name); end

  def validate_foreign_key(from_table, to_table=T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def initialize(*arg, **arg1); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def unlogged(); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  def ==(other); end

  def eql?(other); end

  def fmod(); end

  def hash(); end

  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def oid(); end

  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  def extract_schema_qualified_name(string); end

  def unquote_identifier(identifier); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  def create_enum(name, values); end

  def create_unlogged_tables(); end

  def create_unlogged_tables=(create_unlogged_tables); end

  def create_unlogged_tables?(); end

  def datetime_type(); end

  def datetime_type=(datetime_type); end

  def datetime_type?(); end

  def enum_types(); end

  def extension_available?(name); end

  def extension_enabled?(name); end

  def initialize(connection, logger, connection_parameters, config); end

  def postgresql_version(); end

  def reload_type_map(); end

  def session_auth=(user); end

  def set_standard_conforming_strings(); end

  def supports_insert_on_conflict?(); end

  def supports_pgcrypto_uuid?(); end

  def use_insert_returning?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  DUPLICATE_DATABASE = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder
  def decode(value, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
  TYPE = ::T.let(nil, ::T.untyped)
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
  def initialize(connection, max); end

  def next_key(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  def self.create_unlogged_tables(); end

  def self.create_unlogged_tables=(value); end

  def self.create_unlogged_tables?(); end

  def self.datetime_type(); end

  def self.datetime_type=(value); end

  def self.datetime_type?(); end

  def self.native_database_types(); end

  def self.new_client(conn_params); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column

ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*arg); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*arg); end

  def query_cache_enabled(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_bound_value(value); end

  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def sanitize_as_sql_comment(value); end

  def type_cast(value); end

  def unquoted_false(); end

  def unquoted_true(); end
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add_to(table); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, **options); end

  def rollback(); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def columns_hash?(table_name); end

  def connection(); end

  def connection=(connection); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def database_version(); end

  def dump_to(filename); end

  def encode_with(coder); end

  def indexes(table_name); end

  def init_with(coder); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def self.load_from(filename); end
end

class ActiveRecord::ConnectionAdapters::SchemaCreation
  def accept(o); end

  def initialize(conn); end
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  DEFAULT_DATETIME_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  def add_belongs_to(table_name, ref_name, **options); end

  def add_check_constraint(table_name, expression, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_columns(table_name, *column_names, type:, **options); end

  def add_foreign_key(from_table, to_table, **options); end

  def add_index(table_name, column_name, **options); end

  def add_index_options(table_name, column_name, name: T.unsafe(nil), if_not_exists: T.unsafe(nil), internal: T.unsafe(nil), **options); end

  def add_reference(table_name, ref_name, **options); end

  def add_timestamps(table_name, **options); end

  def assume_migrated_upto_version(version); end

  def change_column(table_name, column_name, type, **options); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, **options); end

  def change_table_comment(table_name, comment_or_changes); end

  def check_constraint_options(table_name, expression, options); end

  def check_constraints(table_name); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), **options); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  def create_table(table_name, id: T.unsafe(nil), primary_key: T.unsafe(nil), force: T.unsafe(nil), **options); end

  def data_source_exists?(name); end

  def data_sources(); end

  def distinct_relation_for_primary_key(relation); end

  def drop_join_table(table_1, table_2, **options); end

  def drop_table(table_name, **options); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_key_exists?(from_table, to_table=T.unsafe(nil), **options); end

  def foreign_key_options(from_table, to_table, options); end

  def foreign_keys(table_name); end

  def index_algorithm(algorithm); end

  def index_exists?(table_name, column_name, **options); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def internal_string_options_for_primary_key(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def primary_key(table_name); end

  def quoted_columns_for_index(column_names, options); end

  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_check_constraint(table_name, expression=T.unsafe(nil), **options); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), **options); end

  def remove_columns(table_name, *column_names, type: T.unsafe(nil), **options); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end

  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_timestamps(table_name, **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_comment(table_name); end

  def table_exists?(table_name); end

  def table_options(table_name); end

  def tables(); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **arg); end

  def update_table_definition(table_name, base); end

  def view_exists?(view_name); end

  def views(); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  def ==(other); end

  def eql?(other); end

  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def precision(); end

  def scale(); end

  def sql_type(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::StatementPool
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def blob(*names, **options); end

  def boolean(*names, **options); end

  def change_null(column_name, null, default=T.unsafe(nil)); end

  def check_constraint(*args, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def initialize(table_name, base); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def numeric(*names, **options); end

  def remove_check_constraint(*args, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def as(); end

  def bigint(*names, **options); end

  def binary(*names, **options); end

  def blob(*names, **options); end

  def boolean(*names, **options); end

  def check_constraint(expression, **options); end

  def check_constraints(); end

  def comment(); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def foreign_key(to_table, **options); end

  def foreign_keys(); end

  def if_not_exists(); end

  def indexes(); end

  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **arg); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def new_check_constraint_definition(expression, options); end

  def new_column_definition(name, type, **options); end

  def new_foreign_key_definition(to_table, options); end

  def numeric(*names, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def string(*names, **options); end

  def temporary(); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record, ensure_finalize=T.unsafe(nil)); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, isolation: T.unsafe(nil), joinable: T.unsafe(nil), run_commit_callbacks: T.unsafe(nil)); end

  def isolation_level(); end

  def joinable?(); end

  def materialize!(); end

  def materialized?(); end

  def open?(); end

  def records(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end

  def written(); end

  def written=(written); end
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil), _lazy: T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def disable_lazy_transactions!(); end

  def enable_lazy_transactions!(); end

  def initialize(connection); end

  def lazy_transactions_enabled?(); end

  def materialize_transactions(); end

  def open_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def invalidate!(); end

  def invalidated?(); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*arg, **arg1, &arg2); end

  def clear_all_connections!(*arg, **arg1, &arg2); end

  def clear_cache!(); end

  def clear_query_caches_for_current_thread(); end

  def clear_reloadable_connections!(*arg, **arg1, &arg2); end

  def connected?(); end

  def connected_to_many(*classes, role:, shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  def connecting_to(role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  def connection(); end

  def connection_db_config(); end

  def connection_pool(); end

  def connection_specification_name(); end

  def connection_specification_name=(connection_specification_name); end

  def establish_connection(config_or_env=T.unsafe(nil)); end

  def flush_idle_connections!(*arg, **arg1, &arg2); end

  def lookup_connection_handler(handler_key); end

  def postgresql_connection(config); end

  def primary_class?(); end

  def prohibit_shard_swapping(enabled=T.unsafe(nil)); end

  def remove_connection(name=T.unsafe(nil)); end

  def retrieve_connection(); end

  def shard_swapping_prohibited?(); end

  def while_preventing_writes(enabled=T.unsafe(nil), &block); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Core
  def ==(comparison_object); end

  def connection_handler(); end

  def encode_with(coder); end

  def eql?(comparison_object); end

  def freeze(); end

  def frozen?(); end

  def hash(); end

  def init_with(coder, &block); end

  def init_with_attributes(attributes, new_record=T.unsafe(nil)); end

  def initialize(attributes=T.unsafe(nil)); end

  def inspect(); end

  def pretty_print(pp); end

  def readonly!(); end

  def readonly?(); end

  def slice(*methods); end

  def strict_loading!(value=T.unsafe(nil), mode: T.unsafe(nil)); end

  def strict_loading?(); end

  def strict_loading_mode(); end

  def strict_loading_n_plus_one_only?(); end

  def values_at(*methods); end
end

class ActiveRecord::DatabaseConfigurations
  def any?(*arg, **arg1, &arg2); end

  def configs_for(env_name: T.unsafe(nil), name: T.unsafe(nil), include_replicas: T.unsafe(nil), include_hidden: T.unsafe(nil)); end

  def configurations(); end

  def empty?(); end

  def find_db_config(env); end

  def initialize(configurations=T.unsafe(nil)); end

  def primary?(name); end

  def resolve(config); end
end

class ActiveRecord::DatabaseConfigurations::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
  def _database=(database); end

  def adapter(); end

  def adapter_method(); end

  def checkout_timeout(); end

  def database(); end

  def env_name(); end

  def for_current_env?(); end

  def host(); end

  def idle_timeout(); end

  def initialize(env_name, name); end

  def max_queue(); end

  def max_threads(); end

  def migrations_paths(); end

  def min_threads(); end

  def name(); end

  def owner_name(); end

  def owner_name=(owner_name); end

  def pool(); end

  def reaping_frequency(); end

  def replica?(); end

  def schema_cache_path(); end
end

class ActiveRecord::DatabaseConfigurations::HashConfig
  def configuration_hash(); end

  def database_tasks?(); end

  def default_schema_cache_path(); end

  def initialize(env_name, name, configuration_hash); end

  def lazy_schema_cache_path(); end

  def primary?(); end

  def schema_dump(format=T.unsafe(nil)); end

  def socket(); end
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
  def initialize(env_name, name, url, configuration_hash=T.unsafe(nil)); end

  def url(); end
end

module ActiveRecord::DelegatedType
  def delegated_type(role, types:, **options); end
end

module ActiveRecord::Delegation
  def &(*arg, **arg1, &arg2); end

  def +(*arg, **arg1, &arg2); end

  def -(*arg, **arg1, &arg2); end

  def [](*arg, **arg1, &arg2); end

  def as_json(*arg, **arg1, &arg2); end

  def compact(*arg, **arg1, &arg2); end

  def connection(*arg, **arg1, &arg2); end

  def each(*arg, **arg1, &arg2); end

  def encode_with(*arg, **arg1, &arg2); end

  def in_groups(*arg, **arg1, &arg2); end

  def in_groups_of(*arg, **arg1, &arg2); end

  def index(*arg, **arg1, &arg2); end

  def join(*arg, **arg1, &arg2); end

  def length(*arg, **arg1, &arg2); end

  def primary_key(*arg, **arg1, &arg2); end

  def reverse(*arg, **arg1, &arg2); end

  def rindex(*arg, **arg1, &arg2); end

  def rotate(*arg, **arg1, &arg2); end

  def sample(*arg, **arg1, &arg2); end

  def shuffle(*arg, **arg1, &arg2); end

  def slice(*arg, **arg1, &arg2); end

  def split(*arg, **arg1, &arg2); end

  def to_formatted_s(*arg, **arg1, &arg2); end

  def to_fs(*arg, **arg1, &arg2); end

  def to_sentence(*arg, **arg1, &arg2); end

  def to_xml(*arg, **arg1, &arg2); end

  def |(*arg, **arg1, &arg2); end
end

module ActiveRecord::Delegation::ClassMethods
  def create(klass, *args, **kwargs); end
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  def name(); end
end

module ActiveRecord::Delegation::DelegateCache
  def generate_relation_method(method); end

  def include_relation_methods(delegate); end

  def inherited(child_class); end

  def initialize_relation_delegate_cache(); end

  def relation_delegate_class(klass); end
end

class ActiveRecord::DeleteRestrictionError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DestroyAssociationAsyncJob
  def perform(owner_model_name: T.unsafe(nil), owner_id: T.unsafe(nil), association_class: T.unsafe(nil), association_ids: T.unsafe(nil), association_primary_key_column: T.unsafe(nil), ensuring_owner_was_method: T.unsafe(nil)); end
end

class ActiveRecord::DisableJoinsAssociationRelation
  def initialize(klass, key, ids); end

  def key(); end

  def load(); end
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def define(); end

  def initialize(model, method_name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

class ActiveRecord::EagerLoadPolymorphicError
  def initialize(reflection=T.unsafe(nil)); end
end

module ActiveRecord::Encryption
  def config(); end

  def custom_contexts(); end

  def custom_contexts=(obj); end

  def default_context(); end

  def encrypted_attribute_declaration_listeners(); end

  def encrypted_attribute_declaration_listeners=(val); end
end

class ActiveRecord::Encryption::Cipher
  def decrypt(encrypted_message, key:); end

  def encrypt(clean_text, key:, deterministic: T.unsafe(nil)); end

  def iv_length(); end

  def key_length(); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Cipher::Aes256Gcm
  def decrypt(encrypted_message); end

  def encrypt(clear_text); end

  def initialize(secret, deterministic: T.unsafe(nil)); end
  CIPHER_TYPE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Cipher::Aes256Gcm
  def self.iv_length(); end

  def self.key_length(); end
end

class ActiveRecord::Encryption::Config
  def add_to_filter_parameters(); end

  def add_to_filter_parameters=(add_to_filter_parameters); end

  def deterministic_key(); end

  def deterministic_key=(deterministic_key); end

  def encrypt_fixtures(); end

  def encrypt_fixtures=(encrypt_fixtures); end

  def excluded_from_filter_parameters(); end

  def excluded_from_filter_parameters=(excluded_from_filter_parameters); end

  def extend_queries(); end

  def extend_queries=(extend_queries); end

  def forced_encoding_for_deterministic_encryption(); end

  def forced_encoding_for_deterministic_encryption=(forced_encoding_for_deterministic_encryption); end

  def key_derivation_salt(); end

  def key_derivation_salt=(key_derivation_salt); end

  def previous=(previous_schemes_properties); end

  def previous_schemes(); end

  def previous_schemes=(previous_schemes); end

  def primary_key(); end

  def primary_key=(primary_key); end

  def store_key_references(); end

  def store_key_references=(store_key_references); end

  def support_unencrypted_data(); end

  def support_unencrypted_data=(support_unencrypted_data); end

  def validate_column_size(); end

  def validate_column_size=(validate_column_size); end
end

module ActiveRecord::Encryption::Configurable::ClassMethods
  def cipher(*arg, **arg1, &arg2); end

  def configure(primary_key:, deterministic_key:, key_derivation_salt:, **properties); end

  def encrypted_attribute_was_declared(klass, name); end

  def encryptor(*arg, **arg1, &arg2); end

  def frozen_encryption(*arg, **arg1, &arg2); end

  def install_auto_filtered_parameters_hook(application); end

  def key_generator(*arg, **arg1, &arg2); end

  def key_provider(*arg, **arg1, &arg2); end

  def message_serializer(*arg, **arg1, &arg2); end

  def on_encrypted_attribute_declared(&block); end
end

class ActiveRecord::Encryption::Context
  def cipher(); end

  def cipher=(cipher); end

  def encryptor(); end

  def encryptor=(encryptor); end

  def frozen_encryption(); end

  def frozen_encryption=(frozen_encryption); end

  def frozen_encryption?(); end

  def key_generator(); end

  def key_generator=(key_generator); end

  def key_provider(); end

  def key_provider=(key_provider); end

  def message_serializer(); end

  def message_serializer=(message_serializer); end
  PROPERTIES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Encryption::Contexts::ClassMethods
  def context(); end

  def current_custom_context(); end

  def protecting_encrypted_data(&block); end

  def with_encryption_context(properties); end

  def without_encryption(&block); end
end

class ActiveRecord::Encryption::DerivedSecretKeyProvider
  def initialize(passwords); end
end

class ActiveRecord::Encryption::DeterministicKeyProvider
  def initialize(password); end
end

class ActiveRecord::Encryption::DeterministicKeyProvider
end

module ActiveRecord::Encryption::EncryptableRecord
  def ciphertext_for(attribute_name); end

  def decrypt(); end

  def encrypt(); end

  def encrypted_attribute?(attribute_name); end
  ORIGINAL_ATTRIBUTE_PREFIX = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::EncryptedAttributeType
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(*arg, **arg1, &arg2); end

  def cast_type(); end

  def deterministic?(*arg, **arg1, &arg2); end

  def downcase?(*arg, **arg1, &arg2); end

  def fixed?(*arg, **arg1, &arg2); end

  def initialize(scheme:, cast_type: T.unsafe(nil), previous_type: T.unsafe(nil)); end

  def key_provider(*arg, **arg1, &arg2); end

  def previous_schemes(*arg, **arg1, &arg2); end

  def previous_types(); end

  def scheme(); end

  def with_context(*arg, **arg1, &arg2); end
end

class ActiveRecord::Encryption::EncryptedAttributeType
end

module ActiveRecord::Encryption::EncryptedFixtures
  def initialize(fixture, model_class); end
end

module ActiveRecord::Encryption::EncryptedFixtures
end

class ActiveRecord::Encryption::EncryptingOnlyEncryptor
end

class ActiveRecord::Encryption::EncryptingOnlyEncryptor
end

class ActiveRecord::Encryption::Encryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clear_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
  DECRYPT_ERRORS = ::T.let(nil, ::T.untyped)
  ENCODING_ERRORS = ::T.let(nil, ::T.untyped)
  THRESHOLD_TO_JUSTIFY_COMPRESSION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::EnvelopeEncryptionKeyProvider
  def active_primary_key(); end

  def decryption_keys(encrypted_message); end

  def encryption_key(); end
end

class ActiveRecord::Encryption::EnvelopeEncryptionKeyProvider
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries
end

class ActiveRecord::Encryption::ExtendedDeterministicQueries::AdditionalValue
  def initialize(value, type); end

  def type(); end

  def value(); end
end

class ActiveRecord::Encryption::ExtendedDeterministicQueries::AdditionalValue
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
  include ::ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
  def find_by(*args); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::ExtendedEncryptableType
  def serialize(data); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::ExtendedEncryptableType
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::InWithAdditionalValues
  def encryption_aware_type_caster(); end

  def proc_for_binds(); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::InWithAdditionalValues
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::RelationQueries
  include ::ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQueryArgumentProcessor
  def exists?(*args); end

  def find_or_create_by(attributes, &block); end

  def find_or_create_by!(attributes, &block); end

  def where(*args); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::RelationQueries
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries
  def self.install_support(); end
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator::EncryptedUniquenessValidator
  def validate_each(record, attribute, value); end
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator::EncryptedUniquenessValidator
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator
  def self.install_support(); end
end

class ActiveRecord::Encryption::Key
  def id(); end

  def initialize(secret); end

  def public_tags(); end

  def secret(); end
end

class ActiveRecord::Encryption::Key
  def self.derive_from(password); end
end

class ActiveRecord::Encryption::KeyGenerator
  def derive_key_from(password, length: T.unsafe(nil)); end

  def generate_random_hex_key(length: T.unsafe(nil)); end

  def generate_random_key(length: T.unsafe(nil)); end
end

class ActiveRecord::Encryption::KeyProvider
  def decryption_keys(encrypted_message); end

  def encryption_key(); end

  def initialize(keys); end
end

class ActiveRecord::Encryption::Message
  def ==(other_message); end

  def headers(); end

  def headers=(headers); end

  def initialize(payload: T.unsafe(nil), headers: T.unsafe(nil)); end

  def payload(); end

  def payload=(payload); end
end

class ActiveRecord::Encryption::Message
end

class ActiveRecord::Encryption::MessageSerializer
  def dump(message); end

  def load(serialized_content); end
end

class ActiveRecord::Encryption::NullEncryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
end

class ActiveRecord::Encryption::NullEncryptor
end

class ActiveRecord::Encryption::Properties
  def ==(arg); end

  def []=(key, value); end

  def add(other_properties); end

  def auth_tag(); end

  def auth_tag=(value); end

  def compressed(); end

  def compressed=(value); end

  def encoding(); end

  def encoding=(value); end

  def encrypted_data_key(); end

  def encrypted_data_key=(value); end

  def encrypted_data_key_id(); end

  def encrypted_data_key_id=(value); end

  def initialize(initial_properties=T.unsafe(nil)); end

  def iv(); end

  def iv=(value); end

  def method_missing(method, *args, **arg, &block); end

  def to_h(); end

  def validate_value_type(value); end
  ALLOWED_VALUE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_PROPERTIES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Properties
end

class ActiveRecord::Encryption::ReadOnlyNullEncryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
end

class ActiveRecord::Encryption::ReadOnlyNullEncryptor
end

class ActiveRecord::Encryption::Scheme
  def deterministic?(); end

  def downcase?(); end

  def fixed?(); end

  def ignore_case?(); end

  def initialize(key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous_schemes: T.unsafe(nil), **context_properties); end

  def key_provider(); end

  def merge(other_scheme); end

  def previous_schemes(); end

  def previous_schemes=(previous_schemes); end

  def to_h(); end

  def with_context(&block); end
end

module ActiveRecord::Encryption
  def self.config(); end

  def self.custom_contexts(); end

  def self.custom_contexts=(obj); end

  def self.default_context(); end

  def self.encrypted_attribute_declaration_listeners(); end

  def self.encrypted_attribute_declaration_listeners=(val); end
end

module ActiveRecord::Enum
  def enum(name=T.unsafe(nil), values=T.unsafe(nil), **options); end

  def inherited(base); end
end

class ActiveRecord::Enum::EnumType
  def assert_valid_value(value); end

  def initialize(name, mapping, subtype); end

  def serializable?(value, &block); end

  def subtype(); end

  def type(*arg, **arg1, &arg2); end
end

module ActiveRecord::Enum
  def self.extended(base); end
end

class ActiveRecord::EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

class ActiveRecord::EnvironmentStorageError
  def initialize(); end
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

class ActiveRecord::ExplainRegistry
  def collect(); end

  def collect=(collect); end

  def collect?(); end

  def queries(); end

  def reset(); end
end

class ActiveRecord::ExplainRegistry
  def self.collect(*arg, **arg1, &arg2); end

  def self.collect=(arg); end

  def self.collect?(*arg, **arg1, &arg2); end

  def self.queries(*arg, **arg1, &arg2); end

  def self.reset(*arg, **arg1, &arg2); end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  def ignore_payload?(payload); end

  def start(name, id, payload); end
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(arg, *args); end

  def find_by!(arg, *args); end

  def find_sole_by(arg, *args); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def include?(record); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def member?(record); end

  def raise_record_not_found_exception!(ids=T.unsafe(nil), result_size=T.unsafe(nil), expected_size=T.unsafe(nil), key=T.unsafe(nil), not_found_ids=T.unsafe(nil)); end

  def second(); end

  def second!(); end

  def second_to_last(); end

  def second_to_last!(); end

  def sole(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end

  def third_to_last(); end

  def third_to_last!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Fixture
  def [](key); end

  def class_name(); end

  def each(&block); end

  def find(); end

  def fixture(); end

  def initialize(fixture, model_class); end

  def model_class(); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet
  def [](x); end

  def []=(k, v); end

  def all_loaded_fixtures(); end

  def all_loaded_fixtures=(val); end

  def config(); end

  def each(&block); end

  def fixtures(); end

  def ignored_fixtures(); end

  def initialize(_, name, class_name, path, config=T.unsafe(nil)); end

  def model_class(); end

  def name(); end

  def size(); end

  def table_name(); end

  def table_rows(); end
  MAX_ID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet::ClassCache
  def [](fs_name); end

  def initialize(class_names, config); end
end

class ActiveRecord::FixtureSet::File
  def each(&block); end

  def ignored_fixtures(); end

  def initialize(file); end

  def model_class(); end
end

class ActiveRecord::FixtureSet::File
  def self.open(file); end
end

class ActiveRecord::FixtureSet::ModelMetadata
  def has_primary_key_column?(); end

  def inheritance_column_name(); end

  def initialize(model_class); end

  def primary_key_name(); end

  def primary_key_type(); end

  def timestamp_column_names(); end
end

class ActiveRecord::FixtureSet::RenderContext
  def self.create_subclass(); end
end

class ActiveRecord::FixtureSet::TableRow
  def initialize(fixture, table_rows:, label:, now:); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy
  def lhs_key(); end

  def rhs_key(); end

  def timestamp_column_names(); end
end

class ActiveRecord::FixtureSet::TableRow::PrimaryKeyError
  def initialize(label, association, value); end
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  def initialize(association); end

  def join_table(); end

  def name(); end

  def primary_key_type(); end
end

class ActiveRecord::FixtureSet::TableRows
  def initialize(table_name, model_class:, fixtures:); end

  def model_class(); end

  def model_metadata(); end

  def tables(); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet
  def self.all_loaded_fixtures(); end

  def self.all_loaded_fixtures=(val); end

  def self.cache_fixtures(connection, fixtures_map); end

  def self.cache_for_connection(connection); end

  def self.cached_fixtures(connection, keys_to_fetch=T.unsafe(nil)); end

  def self.context_class(); end

  def self.create_fixtures(fixtures_directory, fixture_set_names, class_names=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.default_fixture_model_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.default_fixture_table_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.fixture_is_cached?(connection, table_name); end

  def self.identify(label, column_type=T.unsafe(nil)); end

  def self.instantiate_all_loaded_fixtures(object, load_instances=T.unsafe(nil)); end

  def self.instantiate_fixtures(object, fixture_set, load_instances=T.unsafe(nil)); end

  def self.reset_cache(); end
end

class ActiveRecord::FutureResult
  def cancel(); end

  def empty?(*arg, **arg1, &arg2); end

  def execute!(connection); end

  def execute_or_skip(); end

  def initialize(pool, *args, **kwargs); end

  def lock_wait(); end

  def pending?(); end

  def result(); end

  def schedule!(session); end

  def to_a(*arg, **arg1, &arg2); end
end

class ActiveRecord::FutureResult::Canceled
end

class ActiveRecord::FutureResult::Canceled
end

class ActiveRecord::FutureResult::EventBuffer
  def flush(); end

  def initialize(future_result, instrumenter); end

  def instrument(name, payload=T.unsafe(nil), &block); end
end

class ActiveRecord::FutureResult::EventBuffer
end

class ActiveRecord::FutureResult::SelectAll
end

class ActiveRecord::FutureResult::SelectAll
end

class ActiveRecord::FutureResult
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
  def initialize(owner_class=T.unsafe(nil), reflection=T.unsafe(nil)); end

  def owner_class(); end

  def reflection(); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughOrderError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::InsertAll
  def connection(); end

  def execute(); end

  def initialize(model, inserts, on_duplicate:, update_only: T.unsafe(nil), returning: T.unsafe(nil), unique_by: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  def inserts(); end

  def keys(); end

  def keys_including_timestamps(); end

  def map_key_with_value(); end

  def model(); end

  def on_duplicate(); end

  def primary_keys(); end

  def record_timestamps?(); end

  def returning(); end

  def skip_duplicates?(); end

  def unique_by(); end

  def updatable_columns(); end

  def update_duplicates?(); end

  def update_only(); end

  def update_sql(); end
end

class ActiveRecord::InsertAll::Builder
  def conflict_target(); end

  def initialize(insert_all); end

  def into(); end

  def keys(*arg, **arg1, &arg2); end

  def keys_including_timestamps(*arg, **arg1, &arg2); end

  def model(); end

  def raw_update_sql(); end

  def raw_update_sql?(); end

  def record_timestamps?(*arg, **arg1, &arg2); end

  def returning(); end

  def skip_duplicates?(*arg, **arg1, &arg2); end

  def touch_model_timestamps_unless(&block); end

  def updatable_columns(); end

  def update_duplicates?(*arg, **arg1, &arg2); end

  def values_list(); end
end

module ActiveRecord::Integration
  def cache_key(); end

  def cache_key_with_version(); end

  def cache_version(); end

  def to_param(); end
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::InternalMetadata
  def self.enabled?(); end
end

class ActiveRecord::InverseOfAssociationNotFoundError
  def associated_class(); end

  def initialize(reflection=T.unsafe(nil), associated_class=T.unsafe(nil)); end

  def reflection(); end
end

class ActiveRecord::InverseOfAssociationRecursiveError
  def initialize(reflection=T.unsafe(nil)); end

  def reflection(); end
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(coder); end
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Locking::LockingType
  def self.new(subtype); end
end

module ActiveRecord::Locking::Optimistic
  def increment!(*arg, **arg1); end

  def locking_enabled?(); end
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(backtrace_cleaner); end

  def backtrace_cleaner?(); end

  def sql(event); end

  def strict_loading_violation(event); end
end

class ActiveRecord::LogSubscriber
  def self.backtrace_cleaner(); end

  def self.backtrace_cleaner=(value); end

  def self.backtrace_cleaner?(); end

  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def update_context(response); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def save(response); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

class ActiveRecord::Middleware::ShardSelector
  def call(env); end

  def initialize(app, resolver, options=T.unsafe(nil)); end

  def options(); end

  def resolver(); end
end

class ActiveRecord::Middleware::ShardSelector
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, **arg, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes, &block); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def up_only(&block); end

  def verbose(); end

  def verbose=(val); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app, file_watcher: T.unsafe(nil)); end
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, **arg, &block); end

  def add_check_constraint(*args, **arg, &block); end

  def add_column(*args, **arg, &block); end

  def add_foreign_key(*args, **arg, &block); end

  def add_index(*args, **arg, &block); end

  def add_reference(*args, **arg, &block); end

  def add_timestamps(*args, **arg, &block); end

  def change_column(*args, **arg, &block); end

  def change_column_comment(*args, **arg, &block); end

  def change_column_default(*args, **arg, &block); end

  def change_column_null(*args, **arg, &block); end

  def change_table(table_name, **options); end

  def change_table_comment(*args, **arg, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, **arg, &block); end

  def create_table(*args, **arg, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, **arg, &block); end

  def drop_join_table(*args, **arg, &block); end

  def drop_table(*args, **arg, &block); end

  def enable_extension(*args, **arg, &block); end

  def execute(*args, **arg, &block); end

  def execute_block(*args, **arg, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, **arg, &block); end

  def remove_check_constraint(*args, **arg, &block); end

  def remove_column(*args, **arg, &block); end

  def remove_columns(*args, **arg, &block); end

  def remove_foreign_key(*args, **arg, &block); end

  def remove_index(*args, **arg, &block); end

  def remove_reference(*args, **arg, &block); end

  def remove_timestamps(*args, **arg, &block); end

  def rename_column(*args, **arg, &block); end

  def rename_index(*args, **arg, &block); end

  def rename_table(*args, **arg, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, **arg, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_check_constraint(args, &block); end

  def invert_add_column(args, &block); end

  def invert_add_foreign_key(args, &block); end

  def invert_add_index(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_check_constraint(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_foreign_key(args, &block); end

  def invert_remove_index(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, **options); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*arg, **options); end

  def references(*arg, **options); end

  def timestamps(**options); end
end

class ActiveRecord::Migration::Compatibility::V5_0
  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def column(name, type, index: T.unsafe(nil), **options); end

  def timestamps(**options); end
end

class ActiveRecord::Migration::Compatibility::V6_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_reference(table_name, ref_name, **options); end
end

module ActiveRecord::Migration::Compatibility::V6_0::TableDefinition
  def belongs_to(*args, **options); end

  def column(name, type, index: T.unsafe(nil), **options); end

  def references(*args, **options); end
end

class ActiveRecord::Migration::Compatibility::V6_1
  def add_column(table_name, column_name, type, **options); end

  def change_column(table_name, column_name, type, **options); end
end

class ActiveRecord::Migration::Compatibility::V6_1::PostgreSQLCompat
  def self.compatible_timestamp_type(type, connection); end
end

module ActiveRecord::Migration::Compatibility::V6_1::TableDefinition
  def change(name, type, index: T.unsafe(nil), **options); end

  def column(name, type, index: T.unsafe(nil), **options); end

  def new_column_definition(name, type, **options); end
end

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

class ActiveRecord::Migration::Current
  def compatible_table_definition(t); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def reverting(); end

  def reverting=(_); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.[](version); end

  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.current_version(); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.inherited(subclass); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, **arg, &block); end

  def self.migrate(direction); end

  def self.nearest_delegate(); end

  def self.verbose(); end

  def self.verbose=(val); end
end

class ActiveRecord::MigrationContext
  def current_environment(); end

  def current_version(); end

  def down(target_version=T.unsafe(nil), &block); end

  def forward(steps=T.unsafe(nil)); end

  def get_all_versions(); end

  def initialize(migrations_paths, schema_migration=T.unsafe(nil)); end

  def last_stored_environment(); end

  def migrate(target_version=T.unsafe(nil), &block); end

  def migrations(); end

  def migrations_paths(); end

  def migrations_status(); end

  def needs_migration?(); end

  def open(); end

  def pending_migration_versions(); end

  def protected_environment?(); end

  def rollback(steps=T.unsafe(nil)); end

  def run(direction, target_version); end

  def schema_migration(); end

  def up(target_version=T.unsafe(nil), &block); end
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MigrationProxy
  def announce(*arg, **arg1, &arg2); end

  def basename(); end

  def disable_ddl_transaction(*arg, **arg1, &arg2); end

  def filename(); end

  def filename=(_); end

  def initialize(name, version, filename, scope); end

  def migrate(*arg, **arg1, &arg2); end

  def name(); end

  def name=(_); end

  def scope(); end

  def scope=(_); end

  def version(); end

  def version=(_); end

  def write(*arg, **arg1, &arg2); end
end

class ActiveRecord::MigrationProxy
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::Migrator
  def current(); end

  def current_migration(); end

  def current_version(); end

  def initialize(direction, migrations, schema_migration, target_version=T.unsafe(nil)); end

  def load_migrated(); end

  def migrate(); end

  def migrated(); end

  def migrations(); end

  def pending_migrations(); end

  def run(); end

  def runnable(); end
end

class ActiveRecord::Migrator
  def self.current_version(); end

  def self.migrations_paths(); end

  def self.migrations_paths=(migrations_paths); end
end

module ActiveRecord::ModelSchema
  def self.derive_join_table_name(first_table, second_table); end
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::NoEnvironmentInSchemaError
  def initialize(); end
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*arg, **arg1); end

  def touch_later(*arg); end
end

module ActiveRecord::NoTouching
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
end

class ActiveRecord::PendingMigrationError
  def _actions(); end

  def _actions=(_actions); end

  def _actions?(); end
end

class ActiveRecord::PendingMigrationError
  def self._actions(); end

  def self._actions=(value); end

  def self._actions?(); end
end

module ActiveRecord::Persistence
  def previously_new_record?(); end

  def previously_persisted?(); end
end

class ActiveRecord::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class ActiveRecord::Point
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder
  def [](attr_name, value, operator=T.unsafe(nil)); end

  def build(attribute, value, operator=T.unsafe(nil)); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes, &block); end

  def expand_from_hash(attributes, &block); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_arel_attribute(table_name, column_name, &block); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def initialize(associated_table, value); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def begin(); end

  def begin=(_); end

  def end(); end

  def end=(_); end

  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::ProtectedEnvironmentError
  def initialize(env=T.unsafe(nil)); end
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

class ActiveRecord::QueryCache
  def self.complete(pools); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

module ActiveRecord::QueryLogs
end

module ActiveRecord::QueryLogs
  def self.cache_query_log_tags(); end

  def self.cache_query_log_tags=(val); end

  def self.cached_comment(); end

  def self.cached_comment=(obj); end

  def self.call(sql); end

  def self.clear_cache(); end

  def self.prepend_comment(); end

  def self.prepend_comment=(val); end

  def self.taggings(); end

  def self.taggings=(val); end

  def self.tags(); end

  def self.tags=(val); end
end

module ActiveRecord::QueryMethods
  def _select!(*fields); end

  def and(other); end

  def and!(other); end

  def annotate(*args); end

  def annotate!(*args); end

  def annotate_values(); end

  def annotate_values=(value); end

  def arel(aliases=T.unsafe(nil)); end

  def build_having_clause(opts, rest=T.unsafe(nil)); end

  def build_subquery(subquery_alias, select_value); end

  def build_where_clause(opts, rest=T.unsafe(nil)); end

  def construct_join_dependency(associations, join_type); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def excluding(*records); end

  def excluding!(records); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def extract_associated(association); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def in_order_of(column, values); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def invert_where(); end

  def invert_where!(); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end

  def optimizer_hints_values(); end

  def optimizer_hints_values=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reselect(*args); end

  def reselect!(*args); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def skip_preloading!(); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def strict_loading(value=T.unsafe(nil)); end

  def strict_loading!(value=T.unsafe(nil)); end

  def strict_loading_value(); end

  def strict_loading_value=(value); end

  def structurally_compatible?(other); end

  def uniq!(name); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(*args); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end

  def without(*records); end
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::QueryMethods::WhereChain
  def associated(*associations); end

  def initialize(scope); end

  def missing(*associations); end

  def not(opts, *rest); end
end

module ActiveRecord::Querying
  def _load_from_sql(result_set, &block); end

  def _query_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  def and(*arg, **arg1, &arg2); end

  def annotate(*arg, **arg1, &arg2); end

  def any?(*arg, **arg1, &arg2); end

  def average(*arg, **arg1, &arg2); end

  def calculate(*arg, **arg1, &arg2); end

  def count(*arg, **arg1, &arg2); end

  def count_by_sql(sql); end

  def create_or_find_by(*arg, **arg1, &arg2); end

  def create_or_find_by!(*arg, **arg1, &arg2); end

  def create_with(*arg, **arg1, &arg2); end

  def delete_all(*arg, **arg1, &arg2); end

  def delete_by(*arg, **arg1, &arg2); end

  def destroy_all(*arg, **arg1, &arg2); end

  def destroy_by(*arg, **arg1, &arg2); end

  def distinct(*arg, **arg1, &arg2); end

  def eager_load(*arg, **arg1, &arg2); end

  def except(*arg, **arg1, &arg2); end

  def excluding(*arg, **arg1, &arg2); end

  def exists?(*arg, **arg1, &arg2); end

  def extending(*arg, **arg1, &arg2); end

  def extract_associated(*arg, **arg1, &arg2); end

  def fifth(*arg, **arg1, &arg2); end

  def fifth!(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_by(*arg, **arg1, &arg2); end

  def find_by!(*arg, **arg1, &arg2); end

  def find_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*arg, **arg1, &arg2); end

  def find_in_batches(*arg, **arg1, &arg2); end

  def find_or_create_by(*arg, **arg1, &arg2); end

  def find_or_create_by!(*arg, **arg1, &arg2); end

  def find_or_initialize_by(*arg, **arg1, &arg2); end

  def find_sole_by(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def first!(*arg, **arg1, &arg2); end

  def first_or_create(*arg, **arg1, &arg2); end

  def first_or_create!(*arg, **arg1, &arg2); end

  def first_or_initialize(*arg, **arg1, &arg2); end

  def forty_two(*arg, **arg1, &arg2); end

  def forty_two!(*arg, **arg1, &arg2); end

  def fourth(*arg, **arg1, &arg2); end

  def fourth!(*arg, **arg1, &arg2); end

  def from(*arg, **arg1, &arg2); end

  def group(*arg, **arg1, &arg2); end

  def having(*arg, **arg1, &arg2); end

  def ids(*arg, **arg1, &arg2); end

  def in_batches(*arg, **arg1, &arg2); end

  def in_order_of(*arg, **arg1, &arg2); end

  def includes(*arg, **arg1, &arg2); end

  def invert_where(*arg, **arg1, &arg2); end

  def joins(*arg, **arg1, &arg2); end

  def last(*arg, **arg1, &arg2); end

  def last!(*arg, **arg1, &arg2); end

  def left_joins(*arg, **arg1, &arg2); end

  def left_outer_joins(*arg, **arg1, &arg2); end

  def limit(*arg, **arg1, &arg2); end

  def lock(*arg, **arg1, &arg2); end

  def many?(*arg, **arg1, &arg2); end

  def maximum(*arg, **arg1, &arg2); end

  def merge(*arg, **arg1, &arg2); end

  def minimum(*arg, **arg1, &arg2); end

  def none(*arg, **arg1, &arg2); end

  def none?(*arg, **arg1, &arg2); end

  def offset(*arg, **arg1, &arg2); end

  def one?(*arg, **arg1, &arg2); end

  def only(*arg, **arg1, &arg2); end

  def optimizer_hints(*arg, **arg1, &arg2); end

  def or(*arg, **arg1, &arg2); end

  def order(*arg, **arg1, &arg2); end

  def pick(*arg, **arg1, &arg2); end

  def pluck(*arg, **arg1, &arg2); end

  def preload(*arg, **arg1, &arg2); end

  def readonly(*arg, **arg1, &arg2); end

  def references(*arg, **arg1, &arg2); end

  def reorder(*arg, **arg1, &arg2); end

  def reselect(*arg, **arg1, &arg2); end

  def rewhere(*arg, **arg1, &arg2); end

  def second(*arg, **arg1, &arg2); end

  def second!(*arg, **arg1, &arg2); end

  def second_to_last(*arg, **arg1, &arg2); end

  def second_to_last!(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def sole(*arg, **arg1, &arg2); end

  def strict_loading(*arg, **arg1, &arg2); end

  def sum(*arg, **arg1, &arg2); end

  def take(*arg, **arg1, &arg2); end

  def take!(*arg, **arg1, &arg2); end

  def third(*arg, **arg1, &arg2); end

  def third!(*arg, **arg1, &arg2); end

  def third_to_last(*arg, **arg1, &arg2); end

  def third_to_last!(*arg, **arg1, &arg2); end

  def touch_all(*arg, **arg1, &arg2); end

  def unscope(*arg, **arg1, &arg2); end

  def update_all(*arg, **arg1, &arg2); end

  def where(*arg, **arg1, &arg2); end

  def without(*arg, **arg1, &arg2); end
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Railtie
  SQLITE3_PRODUCTION_WARN = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end
end

class ActiveRecord::RecordInvalid
  def initialize(record=T.unsafe(nil)); end
end

module ActiveRecord::Reflection
  extend ::ActiveStorage::Reflection::ReflectionExtension
end

class ActiveRecord::Relation
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  def ==(other); end

  def _exec_scope(*arg, **arg1, &arg2); end

  def alias_tracker(joins=T.unsafe(nil), aliases=T.unsafe(nil)); end

  def bind_attribute(name, value); end

  def build(attributes=T.unsafe(nil), &block); end

  def cache_key(timestamp_column=T.unsafe(nil)); end

  def cache_key_with_version(); end

  def cache_version(timestamp_column=T.unsafe(nil)); end

  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def create_or_find_by(attributes, &block); end

  def create_or_find_by!(attributes, &block); end

  def delete_by(*args); end

  def destroy_all(); end

  def destroy_by(*args); end

  def eager_loading?(); end

  def empty_scope?(); end

  def encode_with(coder); end

  def explain(); end

  def find_or_create_by(attributes, &block); end

  def find_or_create_by!(attributes, &block); end

  def find_or_initialize_by(attributes, &block); end

  def first_or_create(attributes=T.unsafe(nil), &block); end

  def first_or_create!(attributes=T.unsafe(nil), &block); end

  def first_or_initialize(attributes=T.unsafe(nil), &block); end

  def has_limit_or_offset?(); end

  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  def joined_includes_values(); end

  def klass(); end

  def load(&block); end

  def load_async(); end

  def load_records(records); end

  def loaded(); end

  def loaded?(); end

  def locked?(); end

  def model(); end

  def new(attributes=T.unsafe(nil), &block); end

  def null_relation?(); end

  def predicate_builder(); end

  def preload_associations(records); end

  def records(); end

  def reload(); end

  def reset(); end

  def scheduled?(); end

  def scope_for_create(); end

  def scoping(all_queries: T.unsafe(nil), &block); end

  def skip_preloading_value(); end

  def skip_preloading_value=(skip_preloading_value); end

  def table(); end

  def to_a(); end

  def to_ary(); end

  def to_sql(); end

  def touch_all(*names, time: T.unsafe(nil)); end

  def update(id=T.unsafe(nil), attributes); end

  def update!(id=T.unsafe(nil), attributes); end

  def update_all(updates); end

  def update_counters(counters); end

  def values(); end

  def values_for_queries(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::FromClause
  def ==(other); end

  def empty?(); end

  def initialize(value, name); end

  def merge(other); end

  def name(); end

  def value(); end
end

class ActiveRecord::Relation::FromClause
  def self.empty(); end
end

class ActiveRecord::Relation::HashMerger
  def initialize(relation, hash, rewhere=T.unsafe(nil)); end

  def merge(); end

  def other(); end

  def relation(); end
end

class ActiveRecord::Relation::Merger
  def initialize(relation, other, rewhere=T.unsafe(nil)); end

  def merge(); end

  def other(); end

  def relation(); end

  def values(); end
  NORMAL_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::QueryAttribute
  def infinite?(); end

  def initialize(*arg, **arg1, &arg2); end

  def type_cast(value); end

  def unboundable?(); end
end

class ActiveRecord::Relation::StrictLoadingScope
  def self.empty_scope?(); end

  def self.strict_loading_value(); end
end

class ActiveRecord::Relation::WhereClause
  def +(other); end

  def -(other); end

  def ==(other); end

  def any?(*arg, **arg1, &arg2); end

  def ast(); end

  def contradiction?(); end

  def empty?(*arg, **arg1, &arg2); end

  def eql?(other); end

  def except(*columns); end

  def extract_attributes(); end

  def initialize(predicates); end

  def invert(); end

  def merge(other, rewhere=T.unsafe(nil)); end

  def or(other); end

  def predicates(); end

  def referenced_columns(); end

  def to_h(table_name=T.unsafe(nil), equality_only: T.unsafe(nil)); end

  def |(other); end
  ARRAY_WITH_EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::WhereClause
  def self.empty(); end
end

class ActiveRecord::Result
  def [](idx); end

  def cancel(); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def column_types(); end

  def columns(); end

  def each(&block); end

  def empty?(); end

  def includes_column?(name); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(n=T.unsafe(nil)); end

  def length(); end

  def result(); end

  def rows(); end

  def to_a(); end

  def to_ary(); end
end

class ActiveRecord::Result
  def self.empty(); end
end

module ActiveRecord::RuntimeRegistry
  def sql_runtime(); end

  def sql_runtime=(runtime); end
end

module ActiveRecord::Schema::Definition
  def define(info, &block); end
end

module ActiveRecord::Schema::Definition::ClassMethods
  def define(info=T.unsafe(nil), &block); end
end

class ActiveRecord::SchemaDumper
  def chk_ignore_pattern(); end

  def chk_ignore_pattern=(val); end

  def dump(stream); end

  def fk_ignore_pattern(); end

  def fk_ignore_pattern=(val); end

  def ignore_tables(); end

  def ignore_tables=(val); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.chk_ignore_pattern(); end

  def self.chk_ignore_pattern=(val); end

  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.fk_ignore_pattern(); end

  def self.fk_ignore_pattern=(val); end

  def self.ignore_tables(); end

  def self.ignore_tables=(val); end
end

class ActiveRecord::SchemaMigration
  def version(); end
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::SchemaMigration
  def self.all_versions(); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end
end

module ActiveRecord::SecureToken
  MINIMUM_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveRecord::SignedId
  def signed_id(expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other, *rest); end

  def merge!(other, *rest); end

  def only(*onlies); end

  def spawn(); end
end

class ActiveRecord::StatementCache
  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil)); end

  def preparable(); end

  def preparable=(preparable); end

  def value(); end
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache
  def self.create(connection, callable=T.unsafe(nil), &block); end

  def self.partial_query(values); end

  def self.partial_query_collector(); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

module ActiveRecord::Suppressor
  def self.registry(); end
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_table(); end

  def associated_table(table_name); end

  def associated_with?(table_name); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, reflection=T.unsafe(nil)); end

  def join_foreign_key(*arg, **arg1, &arg2); end

  def join_foreign_type(*arg, **arg1, &arg2); end

  def join_primary_key(*arg, **arg1, &arg2); end

  def join_primary_type(*arg, **arg1, &arg2); end

  def polymorphic_association?(); end

  def polymorphic_name_association(); end

  def predicate_builder(); end

  def primary_key(); end

  def reflect_on_aggregation(aggregation_name); end

  def through_association?(); end

  def type(column_name); end
end

module ActiveRecord::Tasks::DatabaseTasks
  def cache_dump_filename(db_config_name, schema_cache_path: T.unsafe(nil)); end

  def charset(configuration, *arguments); end

  def charset_current(env_name=T.unsafe(nil), db_name=T.unsafe(nil)); end

  def check_protected_environments!(); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def clear_schema_cache(filename); end

  def collation(configuration, *arguments); end

  def collation_current(env_name=T.unsafe(nil), db_name=T.unsafe(nil)); end

  def create(configuration, *arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil), name=T.unsafe(nil)); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_configs_with_versions(db_configs); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(configuration, *arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_schema(db_config, format=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def for_each(databases); end

  def load_schema(db_config, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(version=T.unsafe(nil)); end

  def migrate_status(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def name(); end

  def prepare_all(); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def raise_for_multi_db(environment=T.unsafe(nil), command:); end

  def reconstruct_from_schema(db_config, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_dump_path(db_config, format=T.unsafe(nil)); end

  def schema_file_type(*args, **arg, &block); end

  def schema_up_to_date?(configuration, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def setup_initial_database_yaml(); end

  def structure_dump(configuration, *arguments); end

  def structure_load(configuration, *arguments); end

  def target_version(); end

  def truncate_all(environment=T.unsafe(nil)); end
end

module ActiveRecord::Tasks::DatabaseTasks
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(val); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(val); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*arg, **arg1, &arg2); end

  def create(); end

  def drop(); end

  def establish_connection(*arg, **arg1, &arg2); end

  def initialize(db_config); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def self.using_database_configurations?(); end
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*arg, **arg1, &arg2); end

  def collation(); end

  def connection(*arg, **arg1, &arg2); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*arg, **arg1, &arg2); end

  def initialize(db_config); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def self.using_database_configurations?(); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*arg, **arg1, &arg2); end

  def create(); end

  def drop(); end

  def establish_connection(*arg, **arg1, &arg2); end

  def initialize(db_config, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def self.using_database_configurations?(); end
end

module ActiveRecord::TestDatabases
  def self.create_and_load_schema(i, env_name:); end
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

module ActiveRecord::TouchLater
  def before_committed!(); end
end

module ActiveRecord::Transactions
  def before_committed!(); end

  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy(); end

  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(**arg); end

  def save!(**arg); end

  def touch(*arg, **arg1); end

  def transaction(**options, &block); end

  def trigger_transactional_callbacks?(); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Translation
  def i18n_scope(); end

  def lookup_ancestors(); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
  def add_modifier(options, klass, **args); end

  def lookup(symbol, *args, **kwargs); end

  def register(type_name, klass=T.unsafe(nil), **options, &block); end
end

class ActiveRecord::Type::DecorationRegistration
  def call(registry, *args, **kwargs); end

  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def matches?(*args, **kwargs); end
end

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def initialize(parent=T.unsafe(nil)); end

  def key?(key); end

  def keys(); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

ActiveRecord::Type::ImmutableString = ActiveModel::Type::ImmutableString

module ActiveRecord::Type::Internal::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

class ActiveRecord::Type::Json
  def accessor(); end
end

class ActiveRecord::Type::Registration
  def adapter(); end

  def block(); end

  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end

  def override(); end

  def priority(); end

  def priority_except_adapter(); end
end

class ActiveRecord::Type::Serialized
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def serialize(value); end

  def serialized?(); end

  def subtype(); end

  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Type::Time::Value
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def fetch(lookup_key, &block); end

  def initialize(parent=T.unsafe(nil)); end

  def lookup(lookup_key); end

  def perform_fetch(lookup_key, &block); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

module ActiveRecord::Type
  def self.adapter_name_from(model); end

  def self.add_modifier(*arg, **arg1, &arg2); end

  def self.default_value(); end

  def self.lookup(*args, adapter: T.unsafe(nil), **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

class ActiveRecord::TypeCaster::Connection
  def initialize(klass, table_name); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(attr_name); end
end

class ActiveRecord::TypeCaster::Map
  def initialize(klass); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(name); end
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Validations
  def save(**options); end

  def save!(**options); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end
end

class ActiveStorage::AnalyzeJob
  def perform(blob); end
end

class ActiveStorage::Analyzer::ImageAnalyzer::Vips
  ROTATIONS = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Attached
  def initialize(name, record); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DetachMany
  def attachments(); end

  def detach(); end

  def initialize(name, record, attachments); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::DetachMany
end

class ActiveStorage::Attached::Changes::DetachOne
  def attachment(); end

  def detach(); end

  def initialize(name, record, attachment); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::DetachOne
end

class ActiveStorage::Attached::Changes::PurgeMany
  def attachments(); end

  def initialize(name, record, attachments); end

  def name(); end

  def purge(); end

  def purge_later(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::PurgeMany
end

class ActiveStorage::Attached::Changes::PurgeOne
  def attachment(); end

  def initialize(name, record, attachment); end

  def name(); end

  def purge(); end

  def purge_later(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::PurgeOne
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, **arg, &block); end
end

module ActiveStorage::Attached::Model
  def attachment_changes(); end

  def changed_for_autosave?(); end

  def reload(*arg); end
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, **arg, &block); end
end

class ActiveStorage::Attachment
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_record(*args); end

  def purge(); end

  def purge_later(); end

  def signed_id(*arg, **arg1, &arg2); end

  def validate_associated_records_for_blob(*args); end

  def variant(transformations); end
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
  def blob(); end

  def blob=(value); end

  def blob_changed?(); end

  def blob_previously_changed?(); end

  def build_blob(*args, &block); end

  def create_blob(*args, &block); end

  def create_blob!(*args, &block); end

  def record(); end

  def record=(value); end

  def record_changed?(); end

  def record_previously_changed?(); end

  def reload_blob(); end

  def reload_record(); end
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveStorage::Attachment
  def self.with_all_variant_records(*args, **arg); end
end

class ActiveStorage::Blob
  def attachable_plain_text_representation(caption=T.unsafe(nil)); end

  def audio?(); end

  def autosave_associated_records_for_attachments(*args); end

  def autosave_associated_records_for_preview_image_attachment(*args); end

  def autosave_associated_records_for_preview_image_blob(*args); end

  def autosave_associated_records_for_variant_records(*args); end

  def compose(keys); end

  def content_type=(value); end

  def content_type_for_serving(); end

  def custom_metadata(); end

  def custom_metadata=(metadata); end

  def download(&block); end

  def download_chunk(range); end

  def filename(); end

  def forced_disposition_for_serving(); end

  def image?(); end

  def key(); end

  def mirror_later(); end

  def open(tmpdir: T.unsafe(nil), &block); end

  def purge(); end

  def purge_later(); end

  def regenerate_key(); end

  def service(); end

  def service_headers_for_direct_upload(); end

  def service_url_for_direct_upload(expires_in: T.unsafe(nil)); end

  def services(); end

  def services=(services); end

  def services?(); end

  def signed_id(purpose: T.unsafe(nil), expires_in: T.unsafe(nil)); end

  def text?(); end

  def unfurl(io, identify: T.unsafe(nil)); end

  def upload(io, identify: T.unsafe(nil)); end

  def upload_without_unfurling(io); end

  def url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil), filename: T.unsafe(nil), **options); end

  def validate_associated_records_for_attachments(*args); end

  def validate_associated_records_for_variant_records(*args); end

  def video?(); end
  INVALID_VARIABLE_CONTENT_TYPES_DEPRECATED_IN_RAILS_7 = ::T.let(nil, ::T.untyped)
  INVALID_VARIABLE_CONTENT_TYPES_TO_SERVE_AS_BINARY_DEPRECATED_IN_RAILS_7 = ::T.let(nil, ::T.untyped)
  MINIMUM_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::Blob::Analyzable
  def analyze(); end

  def analyze_later(); end

  def analyzed?(); end
end

module ActiveStorage::Blob::GeneratedAssociationMethods
  def attachment_ids(); end

  def attachment_ids=(ids); end

  def attachments(); end

  def attachments=(value); end

  def build_preview_image_attachment(*args, &block); end

  def build_preview_image_blob(*args, &block); end

  def create_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment!(*args, &block); end

  def create_preview_image_blob(*args, &block); end

  def create_preview_image_blob!(*args, &block); end

  def preview_image(); end

  def preview_image=(attachable); end

  def preview_image_attachment(); end

  def preview_image_attachment=(value); end

  def preview_image_blob(); end

  def preview_image_blob=(value); end

  def reload_preview_image_attachment(); end

  def reload_preview_image_blob(); end

  def variant_record_ids(); end

  def variant_record_ids=(ids); end

  def variant_records(); end

  def variant_records=(value); end
end

module ActiveStorage::Blob::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::Identifiable
  def identified?(); end

  def identify(); end

  def identify_without_saving(); end
end

module ActiveStorage::Blob::Representable
  def preview(transformations); end

  def previewable?(); end

  def representable?(); end

  def representation(transformations); end

  def variable?(); end
end

class ActiveStorage::Blob
  def self.build_after_unfurling(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.compose(blobs, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def self.create_after_unfurling!(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_and_upload!(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_before_direct_upload!(filename:, byte_size:, checksum:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.find_signed(id, record: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def self.find_signed!(id, record: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def self.scope_for_strict_loading(); end

  def self.service(); end

  def self.service=(value); end

  def self.service?(); end

  def self.services(); end

  def self.services=(value); end

  def self.services?(); end

  def self.unattached(*args, **arg); end

  def self.with_attached_preview_image(*args, **arg); end
end

class ActiveStorage::Blobs::ProxyController
  def show(); end
end

class ActiveStorage::Blobs::RedirectController
  def show(); end
end

class ActiveStorage::Current
  def host(); end

  def host=(host); end
end

class ActiveStorage::Current
  def self.url_options(); end

  def self.url_options=(value); end
end

class ActiveStorage::DirectUploadsController
  def create(); end
end

class ActiveStorage::DiskController
  def show(); end

  def update(); end
end

class ActiveStorage::Filename
  def as_json(*arg); end

  def base(); end

  def extension(); end

  def extension_with_delimiter(); end

  def extension_without_delimiter(); end

  def initialize(filename); end

  def sanitized(); end

  def to_json(); end
end

class ActiveStorage::Filename
  def self.wrap(filename); end
end

class ActiveStorage::FixtureSet
  def file_fixture_path(); end

  def file_fixture_path?(); end

  def prepare(instance, **attributes); end
end

class ActiveStorage::FixtureSet
  def self.blob(filename:, **attributes); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end
end

class ActiveStorage::LogSubscriber
  def service_delete(event); end

  def service_delete_prefixed(event); end

  def service_download(event); end

  def service_exist(event); end

  def service_mirror(event); end

  def service_streaming_download(event); end

  def service_upload(event); end

  def service_url(event); end
end

class ActiveStorage::MirrorJob
  def perform(key, checksum:); end
end

class ActiveStorage::Preview
  def blob(); end

  def download(&block); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def url(**options); end

  def variation(); end
end

class ActiveStorage::PurgeJob
  def perform(blob); end
end

module ActiveStorage::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveStorage::Representations::ProxyController
  def show(); end
end

class ActiveStorage::Representations::RedirectController
  def show(); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service::DiskService
  def compose(source_keys, destination_key, **arg); end

  def download(key, &block); end

  def headers_for_direct_upload(key, content_type:, **arg); end

  def initialize(root:, public: T.unsafe(nil), **options); end

  def path_for(key); end

  def root(); end

  def root=(root); end

  def upload(key, io, checksum: T.unsafe(nil), **arg); end
end

module ActiveStorage::Streaming
  DEFAULT_BLOB_STREAMING_DISPOSITION = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Variant
  def blob(); end

  def content_type(*arg, **arg1, &arg2); end

  def content_type_for_serving(*arg, **arg1, &arg2); end

  def download(&block); end

  def filename(); end

  def forced_disposition_for_serving(); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def service(*arg, **arg1, &arg2); end

  def url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil)); end

  def variation(); end
end

class ActiveStorage::VariantRecord
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_image_attachment(*args); end

  def autosave_associated_records_for_image_blob(*args); end
end

module ActiveStorage::VariantRecord::GeneratedAssociationMethods
  def blob(); end

  def blob=(value); end

  def blob_changed?(); end

  def blob_previously_changed?(); end

  def build_blob(*args, &block); end

  def build_image_attachment(*args, &block); end

  def build_image_blob(*args, &block); end

  def create_blob(*args, &block); end

  def create_blob!(*args, &block); end

  def create_image_attachment(*args, &block); end

  def create_image_attachment!(*args, &block); end

  def create_image_blob(*args, &block); end

  def create_image_blob!(*args, &block); end

  def image(); end

  def image=(attachable); end

  def image_attachment(); end

  def image_attachment=(value); end

  def image_blob(); end

  def image_blob=(value); end

  def reload_blob(); end

  def reload_image_attachment(); end

  def reload_image_blob(); end
end

module ActiveStorage::VariantRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveStorage::VariantRecord
  def self.with_attached_image(*args, **arg); end
end

class ActiveStorage::VariantWithRecord
  def blob(); end

  def download(*arg, **arg1, &arg2); end

  def image(); end

  def initialize(blob, variation); end

  def key(*arg, **arg1, &arg2); end

  def process(); end

  def processed(); end

  def processed?(); end

  def service(*arg, **arg1, &arg2); end

  def url(*arg, **arg1, &arg2); end

  def variation(); end
end

class ActiveStorage::Variation
  def content_type(); end

  def default_to(defaults); end

  def digest(); end

  def format(); end

  def initialize(transformations); end

  def key(); end

  def transform(file, &block); end

  def transformations(); end
end

class ActiveStorage::Variation
  def self.decode(key); end

  def self.encode(transformations); end

  def self.wrap(variator); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(val); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
  OPTION_ALIASES = ::T.let(nil, ::T.untyped)
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::Coders
  MARK_61 = ::T.let(nil, ::T.untyped)
  MARK_70_COMPRESSED = ::T.let(nil, ::T.untyped)
  MARK_70_UNCOMPRESSED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::Coders::Loader
  def load(payload); end
end

module ActiveSupport::Cache::Coders::Rails61Coder
  def dump(entry); end

  def dump_compressed(entry, threshold); end
end

module ActiveSupport::Cache::Coders::Rails70Coder
  def dump(entry); end

  def dump_compressed(entry, threshold); end
end

module ActiveSupport::Cache::Coders
  def self.[](version); end
end

class ActiveSupport::Cache::Entry
  def bytesize(); end

  def compressed(compress_threshold); end

  def compressed?(); end

  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compressed: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), expires_at: T.unsafe(nil), **arg); end

  def local?(); end

  def mismatched?(version); end

  def pack(); end

  def value(); end

  def version(); end
end

class ActiveSupport::Cache::Entry
  def self.unpack(members); end
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def initialize(cache_path, **options); end
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
end

module ActiveSupport::Cache::MemoryStore::DupCoder
  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def load(entry); end
end

class ActiveSupport::Cache::MemoryStore
  def self.supports_cache_versioning?(); end
end

module ActiveSupport::Cache::NullCoder
  def dump(entry); end

  def dump_compressed(entry, threshold); end

  def load(payload); end
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def delete_multi(names, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil), &block); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(val); end

  def mute(); end

  def new_entry(value, options=T.unsafe(nil)); end

  def options(); end

  def read(name, options=T.unsafe(nil)); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_multi(hash, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(val); end
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(**options); end

  def clear(**options); end

  def decrement(name, amount=T.unsafe(nil), **options); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), **options); end

  def middleware(); end

  def with_local_cache(&block); end
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.format_version(); end

  def self.format_version=(format_version); end

  def self.lookup_store(store=T.unsafe(nil), *parameters); end
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def define_cached_method(name, namespace:, as: T.unsafe(nil), &block); end

  def execute(); end

  def initialize(owner, path, line); end
end

class ActiveSupport::CodeGenerator::MethodSet
  def apply(owner, path, line); end

  def define_cached_method(name, as: T.unsafe(nil)); end

  def initialize(namespace); end
  METHOD_CACHES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def self.batch(owner, path, line); end
end

module ActiveSupport::CompareWithRange
  def ===(value); end

  def include?(value); end
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
  def synchronize(&block); end
end

class ActiveSupport::Concurrency::ShareLock
  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def initialize(); end

  def raw_state(); end

  def sharing(); end

  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def start_sharing(); end

  def stop_exclusive(compatible: T.unsafe(nil)); end

  def stop_sharing(); end

  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end
end

module ActiveSupport::Configurable
  def config(); end
end

class ActiveSupport::CurrentAttributes
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(&block); end

  def self.attribute(*names); end

  def self.before_reset(&block); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*arg, **arg1, &arg2); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*arg, **arg1, &arg2); end
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(&block); end

  def permit_concurrent_loads(&block); end

  def raw_state(&block); end

  def running(&block); end

  def start_running(); end

  def start_unloading(); end

  def unloading(&block); end
end

module ActiveSupport::Dependencies::RequireDependency
  def require_dependency(filename); end
end

module ActiveSupport::Dependencies
  def self._autoloaded_tracked_classes(); end

  def self._autoloaded_tracked_classes=(_autoloaded_tracked_classes); end

  def self._eager_load_paths(); end

  def self._eager_load_paths=(_eager_load_paths); end

  def self.autoload_once_paths(); end

  def self.autoload_once_paths=(autoload_once_paths); end

  def self.autoload_paths(); end

  def self.autoload_paths=(autoload_paths); end

  def self.autoloader(); end

  def self.autoloader=(autoloader); end

  def self.clear(); end

  def self.eager_load?(path); end

  def self.interlock(); end

  def self.interlock=(interlock); end

  def self.load_interlock(&block); end

  def self.run_interlock(&block); end

  def self.search_for_file(relpath); end

  def self.unload_interlock(&block); end
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
  VARIABLE_PARTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Serializer
end

module ActiveSupport::EachTimeWithZone
  def each(&block); end

  def step(n=T.unsafe(nil), &block); end
end

class ActiveSupport::EncryptedFile
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnvironmentInquirer
  DEFAULT_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ErrorReporter
  def handle(error_class=T.unsafe(nil), severity: T.unsafe(nil), context: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def initialize(*subscribers, logger: T.unsafe(nil)); end

  def logger(); end

  def logger=(logger); end

  def record(error_class=T.unsafe(nil), severity: T.unsafe(nil), context: T.unsafe(nil)); end

  def report(error, handled:, severity: T.unsafe(nil), context: T.unsafe(nil)); end

  def set_context(*arg, **arg1, &arg2); end

  def subscribe(subscriber); end
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::ExecutionContext
end

module ActiveSupport::ExecutionContext
  def self.[]=(key, value); end

  def self.after_change(&block); end

  def self.clear(); end

  def self.set(**options); end

  def self.to_h(); end
end

class ActiveSupport::ExecutionWrapper
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete(); end

  def complete!(); end

  def run(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active?(); end

  def self.active_key(); end

  def self.error_reporter(); end

  def self.perform(); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(reset: T.unsafe(nil)); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(); end
end

module ActiveSupport::Executor::TestHelper
  def run(*arg, **arg1, &arg2); end
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

module ActiveSupport::ForkTracker::CoreExt
  def fork(*arg, **arg1, &arg2); end
end

module ActiveSupport::ForkTracker::ModernCoreExt
  def _fork(); end
end

module ActiveSupport::ForkTracker
  def self.after_fork(&block); end

  def self.check!(); end

  def self.hook!(); end

  def self.unregister(callback); end
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
  def initialize(*arg); end
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

module ActiveSupport::HtmlSafeTranslation
  def translate(key, **options); end
end

module ActiveSupport::Inflector
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::IsolatedExecutionState
  def self.[](key); end

  def self.[]=(key, value); end

  def self.clear(); end

  def self.delete(key); end

  def self.isolation_level(); end

  def self.isolation_level=(level); end

  def self.key?(key); end

  def self.share_with(other); end

  def self.unique_id(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(val); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Chars
  def =~(*arg, **arg1, &arg2); end

  def acts_like_string?(*arg, **arg1, &arg2); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def match?(*arg, **arg1, &arg2); end

  def method_missing(method, *args, &block); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(value); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(value); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumericWithFormat
  def to_formatted_s(format=T.unsafe(nil), options=T.unsafe(nil)); end

  def to_fs(format=T.unsafe(nil), options=T.unsafe(nil)); end
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::ParameterFilter
  def filter(params); end

  def filter_param(key, value); end

  def initialize(filters=T.unsafe(nil), mask: T.unsafe(nil)); end
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(params, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end

  def deep_regexps(); end

  def initialize(regexps, deep_regexps, blocks, mask:); end

  def regexps(); end

  def value_for_key(key, value, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def self.compile(filters, mask:); end
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

module ActiveSupport::RangeWithFormat
  def to_formatted_s(format=T.unsafe(nil)); end

  def to_fs(format=T.unsafe(nil)); end
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(check); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(executor); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(value); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(value); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::RubyFeatures
  CLASS_SUBCLASSES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SecureCompareRotator
  include ::ActiveSupport::SecurityUtils
  include ::ActiveSupport::Messages::Rotator
  def secure_compare!(other_value, on_rotation: T.unsafe(nil)); end
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def publish_event(event); end

  def start(name, id, payload); end
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*arg, **arg1, &arg2); end

  def flush(); end

  def pop_tags(*arg, **arg1, &arg2); end

  def push_tags(*arg, **arg1, &arg2); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def current_tags(); end

  def current_tags=(current_tags); end
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def self.extended(base); end
end

module ActiveSupport::TaggedLogging
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def fixture_class_names(); end

  def fixture_class_names=(fixture_class_names); end

  def fixture_class_names?(); end

  def fixture_path(); end

  def fixture_path?(); end

  def fixture_table_names(); end

  def fixture_table_names=(fixture_table_names); end

  def fixture_table_names?(); end

  def lock_threads(); end

  def lock_threads=(lock_threads); end

  def lock_threads?(); end

  def method_name(); end

  def pre_loaded_fixtures(); end

  def pre_loaded_fixtures=(pre_loaded_fixtures); end

  def pre_loaded_fixtures?(); end

  def use_instantiated_fixtures(); end

  def use_instantiated_fixtures=(use_instantiated_fixtures); end

  def use_instantiated_fixtures?(); end

  def use_transactional_tests(); end

  def use_transactional_tests=(use_transactional_tests); end

  def use_transactional_tests?(); end
end

class ActiveSupport::TestCase
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.fixture_class_names(); end

  def self.fixture_class_names=(value); end

  def self.fixture_class_names?(); end

  def self.fixture_path(); end

  def self.fixture_path=(value); end

  def self.fixture_path?(); end

  def self.fixture_table_names(); end

  def self.fixture_table_names=(value); end

  def self.fixture_table_names?(); end

  def self.lock_threads(); end

  def self.lock_threads=(value); end

  def self.lock_threads?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil), threshold: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.pre_loaded_fixtures(); end

  def self.pre_loaded_fixtures=(value); end

  def self.pre_loaded_fixtures?(); end

  def self.test_order=(new_order); end

  def self.use_instantiated_fixtures(); end

  def self.use_instantiated_fixtures=(value); end

  def self.use_instantiated_fixtures?(); end

  def self.use_transactional_tests(); end

  def self.use_transactional_tests=(value); end

  def self.use_transactional_tests?(); end
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::Isolation
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

class ActiveSupport::Testing::Parallelization
  def <<(work); end

  def after_fork_hooks(); end

  def initialize(worker_count); end

  def run_cleanup_hooks(); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class ActiveSupport::Testing::Parallelization::Server
  def <<(o); end

  def active_workers?(); end

  def interrupt(); end

  def pop(); end

  def record(reporter, result); end

  def shutdown(); end

  def start_worker(worker_id); end

  def stop_worker(worker_id); end
end

class ActiveSupport::Testing::Parallelization::Worker
  def after_fork(); end

  def initialize(number, url); end

  def perform_job(job); end

  def run_cleanup(); end

  def safe_record(reporter, result); end

  def start(); end

  def work_from_queue(); end
end

class ActiveSupport::Testing::Parallelization
  def self.after_fork_hook(&blk); end

  def self.after_fork_hooks(); end

  def self.run_cleanup_hook(&blk); end

  def self.run_cleanup_hooks(); end
end

class ActiveSupport::Testing::ParallelizeExecutor
  def <<(work); end

  def initialize(size:, with:, threshold: T.unsafe(nil)); end

  def parallelize_with(); end

  def shutdown(); end

  def size(); end

  def start(); end

  def threshold(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbed?(); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end

  def unfreeze_time(); end
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  PRECISIONS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*arg, **arg1, &arg2); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport
  def self.escape_html_entities_in_json(*arg, **arg1, &arg2); end

  def self.escape_html_entities_in_json=(arg); end

  def self.json_encoder(*arg, **arg1, &arg2); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(val); end

  def self.time_precision(*arg, **arg1, &arg2); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*arg, **arg1, &arg2); end

  def self.use_standard_json_time_format=(arg); end
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAttributeMethods
  include ::ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAttributeMethods
end

module ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

Arel::Attribute = Arel::Attributes::Attribute

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil)); end

  def value(); end
end

class Arel::Collectors::Composite
  def <<(str); end

  def add_bind(bind, &block); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil), &block); end

  def initialize(left, right); end

  def preparable(); end

  def preparable=(preparable); end

  def value(); end
end

class Arel::Collectors::SubstituteBinds
  def <<(str); end

  def add_bind(bind); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil)); end

  def initialize(quoter, delegate_collector); end

  def preparable(); end

  def preparable=(preparable); end

  def value(); end
end

class Arel::SelectManager
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  def deconstruct(); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end

  def to_h(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def n_significant_digits(); end

  def precision(); end

  def precision_scale(); end

  def scale(); end

  def to_digits(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(arg); end
end

class Binding
  def b(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def break(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def clone(); end
end

module Bootsnap
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bootsnap::CompileCache
  UNCOMPILABLE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::CompileCache::YAML
  SUPPORTED_INTERNAL_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Bootsnap::ExplicitRequire
  ARCHDIR = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  RUBYLIBDIR = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache
  CACHED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  DLEXT2 = ::T.let(nil, ::T.untyped)
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DOT_RB = ::T.let(nil, ::T.untyped)
  DOT_SO = ::T.let(nil, ::T.untyped)
  FALLBACK_SCAN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Cache
  AGE_THRESHOLD = ::T.let(nil, ::T.untyped)
  BUILTIN_FEATURES = ::T.let(nil, ::T.untyped)
  TRUFFLERUBY_LIB_DIR_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Path
  RUBY_LIBDIR = ::T.let(nil, ::T.untyped)
  RUBY_SITEDIR = ::T.let(nil, ::T.untyped)
  STABLE = ::T.let(nil, ::T.untyped)
  VOLATILE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache::PathScanner
  ALTERNATIVE_NATIVE_EXTENSIONS_PATTERN = ::T.let(nil, ::T.untyped)
  BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  NORMALIZE_NATIVE_EXTENSIONS = ::T.let(nil, ::T.untyped)
  REQUIRABLE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Store
  CURRENT_VERSION = ::T.let(nil, ::T.untyped)
  VERSION_KEY = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Bundler::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Bundler::CLI
  def add(*gems); end

  def binstubs(*gems); end

  def cache(); end

  def check(); end

  def clean(); end

  def cli_help(); end

  def config(*args); end

  def console(group=T.unsafe(nil)); end

  def doctor(); end

  def env(); end

  def exec(*args); end

  def fund(); end

  def help(cli=T.unsafe(nil)); end

  def info(gem_name); end

  def init(); end

  def initialize(*args); end

  def inject(name, version); end

  def install(); end

  def issue(); end

  def licenses(); end

  def list(); end

  def lock(); end

  def open(name); end

  def outdated(*gems); end

  def platform(); end

  def plugin(*args); end

  def pristine(*gems); end

  def remove(*gems); end

  def show(gem_name=T.unsafe(nil)); end

  def update(*gems); end

  def version(); end

  def viz(); end
  AUTO_INSTALL_CMDS = ::T.let(nil, ::T.untyped)
  COMMAND_ALIASES = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  PARSEABLE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Bundler::CLI::Common
end

module Bundler::CLI::Common
  def self.ask_for_spec_from(specs); end

  def self.clean_after_install?(); end

  def self.configure_gem_version_promoter(definition, options); end

  def self.default_gem_spec(name); end

  def self.ensure_all_gems_in_lockfile!(names, locked_gems=T.unsafe(nil)); end

  def self.gem_not_found_message(missing_gem_name, alternatives); end

  def self.output_fund_metadata_summary(); end

  def self.output_post_install_messages(messages); end

  def self.output_without_groups_message(command); end

  def self.patch_level_options(options); end

  def self.print_post_install_message(name, msg); end

  def self.select_spec(name, regex_match=T.unsafe(nil)); end

  def self.verbalize_groups(groups); end

  def self.without_groups_message(command); end
end

class Bundler::CLI::Config
  def base(name=T.unsafe(nil), *value); end

  def get(name); end

  def list(); end

  def set(name, value, *value_); end

  def unset(name); end
end

class Bundler::CLI::Config::Base
  def confirm(name); end

  def confirm_all(); end

  def explicit_scope?(); end

  def initialize(options, name, value, thor); end

  def message(); end

  def name(); end

  def new_value(); end

  def options(); end

  def run(); end

  def scope(); end

  def show_pretty_values_for(setting); end

  def thor(); end

  def validate_scope!(); end

  def value(); end

  def warn_unused_scope(msg); end
end

class Bundler::CLI::Config::Base
end

class Bundler::CLI::Config
end

class Bundler::CLI::Install
  def initialize(options); end

  def options(); end

  def run(); end
end

class Bundler::CLI::Install
end

class Bundler::CLI::Plugin
  def install(*plugins); end

  def list(); end

  def uninstall(*plugins); end
end

class Bundler::CLI::Plugin
end

class Bundler::CLI
  def self.aliases_for(command_name); end

  def self.all_aliases(); end

  def self.check_deprecated_ext_option(arguments); end

  def self.deprecated_ext_value?(arguments); end

  def self.dispatch(*arg); end

  def self.reformatted_help_args(args); end

  def self.source_root(); end

  def self.start(*arg); end
end

class Bundler::Checksum
  def ==(other); end

  def algo(); end

  def digest(); end

  def eql?(other); end

  def formatted_sources(); end

  def initialize(algo, digest, source); end

  def match?(other); end

  def merge!(other); end

  def removable?(); end

  def removal_instructions(); end

  def same_source?(other); end

  def sources(); end

  def to_lock(); end
  ALGO_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Checksum::Source
  def ==(other); end

  def initialize(type, location); end

  def location(); end

  def removable?(); end

  def removal(); end

  def type(); end
end

class Bundler::Checksum::Source
end

class Bundler::Checksum::Store
  def merge!(other); end

  def register(spec, checksum); end

  def replace(spec, checksum); end

  def store(); end

  def to_lock(spec); end
end

class Bundler::Checksum::Store
end

class Bundler::Checksum
  def self.from_api(digest, source_uri, algo=T.unsafe(nil)); end

  def self.from_gem(io, pathname, algo=T.unsafe(nil)); end

  def self.from_gem_package(gem_package, algo=T.unsafe(nil)); end

  def self.from_lock(lock_checksum, lockfile_location); end

  def self.to_hexdigest(digest, algo=T.unsafe(nil)); end
end

class Bundler::ChecksumMismatchError
  def initialize(lock_name, existing, checksum); end

  def mismatch_resolution_instructions(); end
end

class Bundler::ChecksumMismatchError
end

class Bundler::CompactIndexClient
  def available?(); end

  def dependencies(names); end

  def info(name); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def latest_version(name); end

  def names(); end

  def reset!(); end

  def versions(); end
  DEBUG_MUTEX = ::T.let(nil, ::T.untyped)
  INFO_DEPS = ::T.let(nil, ::T.untyped)
  INFO_NAME = ::T.let(nil, ::T.untyped)
  INFO_PLATFORM = ::T.let(nil, ::T.untyped)
  INFO_REQS = ::T.let(nil, ::T.untyped)
  INFO_VERSION = ::T.let(nil, ::T.untyped)
  SUPPORTED_DIGESTS = ::T.let(nil, ::T.untyped)
end

class Bundler::CompactIndexClient::Cache
  def directory(); end

  def info(name, remote_checksum=T.unsafe(nil)); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def names(); end

  def reset!(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Cache
end

class Bundler::CompactIndexClient::CacheFile
  def append(data); end

  def close(); end

  def commit(); end

  def commit!(); end

  def digests=(expected_digests); end

  def digests?(); end

  def initialize(original_path, &block); end

  def initialize_digests(keys=T.unsafe(nil)); end

  def md5(); end

  def open(write_mode=T.unsafe(nil), perm=T.unsafe(nil), &block); end

  def original_path(); end

  def path(); end

  def reset_digests(); end

  def size(); end

  def verify(); end

  def write(data); end
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
  def initialize(digests, expected_digests); end
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile
  def self.copy(path, &block); end

  def self.write(path, data, digests=T.unsafe(nil)); end
end

class Bundler::CompactIndexClient::Error
end

class Bundler::CompactIndexClient::Error
end

Bundler::CompactIndexClient::GemParser = Gem::Resolver::APISet::GemParser

class Bundler::CompactIndexClient::Parser
  def available?(); end

  def info(name); end

  def initialize(compact_index); end

  def names(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Parser
end

class Bundler::CompactIndexClient::Updater
  def initialize(fetcher); end

  def update(remote_path, local_path, etag_path); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
  def initialize(path, message); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
end

class Bundler::CompactIndexClient::Updater
end

class Bundler::CompactIndexClient
  def self.debug(); end
end

class Bundler::ConnectionPool
  def auto_reload_after_fork(); end

  def available(); end

  def checkin(force: T.unsafe(nil)); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def reload(&block); end

  def shutdown(&block); end

  def size(); end

  def then(options=T.unsafe(nil)); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(reload: T.unsafe(nil), &block); end
end

class Bundler::ConnectionPool::TimedStack
end

class Bundler::ConnectionPool
  def self.after_fork(); end

  def self.wrap(options, &block); end
end

class Bundler::CorruptBundlerInstallError
  def initialize(loaded_spec); end

  def status_code(); end
end

class Bundler::CorruptBundlerInstallError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_32?(); end

  def mingw_33?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_32?(); end

  def mri_33?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_32?(); end

  def mswin64_33?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_32?(); end

  def mswin_33?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_32?(); end

  def ruby_33?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_3?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_19?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_21?(); end

  def windows_22?(); end

  def windows_23?(); end

  def windows_24?(); end

  def windows_25?(); end

  def windows_26?(); end

  def windows_27?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_31?(); end

  def windows_32?(); end

  def windows_33?(); end

  def windows_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_32?(); end

  def x64_mingw_33?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def bundler_version_to_lock(); end

  def current_locked_dependencies(); end

  def deleted_deps(); end

  def dependencies_for(groups); end

  def filter_relevant(dependencies); end

  def locked_checksums(); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def new_deps(); end

  def no_resolve_needed?(); end

  def prefer_local!(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def gemspec_dev_dep?(); end

  def git(); end

  def github(); end

  def glob(); end

  def path(); end

  def ref(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end

  def gemfile(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
  GITLAB_MERGE_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.from_env(); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def api_fetcher?(); end

  def fetch_spec(spec); end

  def gem_remote_fetcher(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationForbiddenError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationForbiddenError
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def gem_remote_fetcher(); end

  def initialize(downloader, remote, display_uri, gem_remote_fetcher); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
end

module Bundler::ForcePlatform
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.force_ruby_platform(specs); end

  def self.generic_local_platform_is_ruby?(); end

  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end

  def self.sort_best_platform_match(matching, platform); end
end

class Bundler::GemVersionPromoter
  def filter_versions(package, specs); end

  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
  def add(spec); end

  def duplicates(); end

  def merge!(other); end

  def subset?(other); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InsecureInstallPathError
  def initialize(path); end

  def status_code(); end
end

class Bundler::InsecureInstallPathError
end

class Bundler::Installer
  def definition(); end
end

class Bundler::LazySpecification
  include ::Bundler::ForcePlatform
  def dependencies=(dependencies); end

  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform!(); end

  def force_ruby_platform=(force_ruby_platform); end

  def lock_name(); end

  def materialize_for_installation(); end

  def name_tuple(); end

  def required_ruby_version(); end

  def required_ruby_version=(required_ruby_version); end

  def required_rubygems_version(); end

  def required_rubygems_version=(required_rubygems_version); end

  def runtime_dependencies(); end
end

class Bundler::LazySpecification
  def self.from_spec(s); end
end

class Bundler::LockfileParser
  def checksums(); end

  def may_include_redundant_platform_specific_gems?(); end
  CHECKSUMS = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser::Position
  def advance!(string); end

  def column(); end

  def initialize(line, column); end

  def line(); end
end

class Bundler::LockfileParser::Position
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def matches_current_metadata?(); end

  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def checksum_store(); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_in_plugin_root?(name); end

  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Path
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Path
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.from_lock(locked_opts); end

  def self.list(); end

  def self.loaded?(plugin); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
  def runtime_dependencies(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def all_versions_for(package); end

  def bundler_pinned_to_current_version?(); end

  def default_bundler_source(); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_not_found!(package); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def generic!(); end

  def initialize(version, specs: T.unsafe(nil)); end

  def platform_specific!(); end

  def prerelease?(); end

  def segments(); end

  def sort_obj(); end

  def to_specs(package); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), dependency: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platforms(); end

  def prerelease_specified?(); end

  def root?(); end

  def top_level?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def sorted_spec_names(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def normalize_ruby_file(filename); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def all_specs(); end

  def default_specs(); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def installed_specs(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

module Bundler::SafeMarshal
  ALLOWED_CLASSES = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  PROC = ::T.let(nil, ::T.untyped)
end

module Bundler::SafeMarshal
end

class Bundler::Settings
  def processor_count(); end
  FALLBACK_TIMEOUT_URI_OPTION = ::T.let(nil, ::T.untyped)
  REMEMBERED_KEYS = ::T.let(nil, ::T.untyped)
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end

  def self.key_to_s(key); end
end

module Bundler::SharedHelpers
  def bundle_bin_path(); end

  def checksum_for_file(path, digest); end

  def relative_gemfile_path(); end

  def relative_lockfile_path(); end

  def relative_path_to(destination, from: T.unsafe(nil)); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def checksum_store(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end

  def to_gemfile(); end

  def uri_with_specifiers(specifiers); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def default_specs(); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_fetchers(); end

  def remote_names(); end

  def remotes=(remotes); end

  def to_gemfile(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local!(); end

  def local_mode?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def add_extra_platforms!(platforms); end

  def complete_platforms!(platforms); end

  def delete(specs); end

  def delete_by_name(name); end

  def incomplete_for_platform?(deps, platform); end

  def incomplete_specs(); end

  def missing_specs(); end

  def names(); end

  def validate_deps(s); end
end

class Bundler::StubSpecification
  def checksum(); end

  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def content(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def replacement_present?(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def enum_to_s(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def print_default(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, wrap_long_description, usage, options=T.unsafe(nil), options_relation=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def slice(*keys); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

module Bundler::Thor::Correctable
  def corrections(); end

  def to_s(); end
end

module Bundler::Thor::Correctable
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def aliases_for_usage(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_at_least_one!(); end

  def check_exclusive!(); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil), relations=T.unsafe(nil)); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::Bundler::Thor::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::Bundler::Thor::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  def self.at_least_one(*args, &block); end

  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.exclusive(*args, &block); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.sort_commands!(list); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def warn?(); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

module Bundler
  def self.auto_install(); end

  def self.auto_switch(); end

  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.gem_version(); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

class CGI
  VERSION = ::T.let(nil, ::T.untyped)
end

class CGI::Cookie
  DOMAIN_VALUE_RE = ::T.let(nil, ::T.untyped)
  PATH_VALUE_RE = ::T.let(nil, ::T.untyped)
  TOKEN_RE = ::T.let(nil, ::T.untyped)
end

module CGI::Escape
  def escapeURIComponent(arg); end

  def unescapeURIComponent(*arg); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CGI::Util
  def escapeURIComponent(arg); end

  def unescapeURIComponent(*arg); end
end

class Class
  def json_creatable?(); end
end

class Complex
  def to_d(*args); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::FiberLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

Concurrent::LockLocalVar = Concurrent::FiberLocalVar

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::ThreadLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  DEFAULT_INTERVAL_TYPE = ::T.let(nil, ::T.untyped)
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  FIXED_DELAY = ::T.let(nil, ::T.untyped)
  FIXED_RATE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class Contact
  include ::Contact::GeneratedAttributeMethods
  include ::Contact::GeneratedAssociationMethods
end

module Contact::GeneratedAssociationMethods
end

module Contact::GeneratedAssociationMethods
end

module Contact::GeneratedAttributeMethods
  def clear_created_at_change(); end

  def clear_email_change(); end

  def clear_id_change(); end

  def clear_name_change(); end

  def clear_phone_change(); end

  def clear_updated_at_change(); end

  def created_at(); end

  def created_at=(value); end

  def created_at?(); end

  def created_at_before_last_save(); end

  def created_at_before_type_cast(); end

  def created_at_came_from_user?(); end

  def created_at_change(); end

  def created_at_change_to_be_saved(); end

  def created_at_changed?(**options); end

  def created_at_for_database(); end

  def created_at_in_database(); end

  def created_at_previous_change(); end

  def created_at_previously_changed?(**options); end

  def created_at_previously_was(); end

  def created_at_was(); end

  def created_at_will_change!(); end

  def email(); end

  def email=(value); end

  def email?(); end

  def email_before_last_save(); end

  def email_before_type_cast(); end

  def email_came_from_user?(); end

  def email_change(); end

  def email_change_to_be_saved(); end

  def email_changed?(**options); end

  def email_for_database(); end

  def email_in_database(); end

  def email_previous_change(); end

  def email_previously_changed?(**options); end

  def email_previously_was(); end

  def email_was(); end

  def email_will_change!(); end

  def id_before_last_save(); end

  def id_came_from_user?(); end

  def id_change(); end

  def id_change_to_be_saved(); end

  def id_changed?(**options); end

  def id_previous_change(); end

  def id_previously_changed?(**options); end

  def id_previously_was(); end

  def id_will_change!(); end

  def name(); end

  def name=(value); end

  def name?(); end

  def name_before_last_save(); end

  def name_before_type_cast(); end

  def name_came_from_user?(); end

  def name_change(); end

  def name_change_to_be_saved(); end

  def name_changed?(**options); end

  def name_for_database(); end

  def name_in_database(); end

  def name_previous_change(); end

  def name_previously_changed?(**options); end

  def name_previously_was(); end

  def name_was(); end

  def name_will_change!(); end

  def phone(); end

  def phone=(value); end

  def phone?(); end

  def phone_before_last_save(); end

  def phone_before_type_cast(); end

  def phone_came_from_user?(); end

  def phone_change(); end

  def phone_change_to_be_saved(); end

  def phone_changed?(**options); end

  def phone_for_database(); end

  def phone_in_database(); end

  def phone_previous_change(); end

  def phone_previously_changed?(**options); end

  def phone_previously_was(); end

  def phone_was(); end

  def phone_will_change!(); end

  def restore_created_at!(); end

  def restore_email!(); end

  def restore_id!(); end

  def restore_name!(); end

  def restore_phone!(); end

  def restore_updated_at!(); end

  def saved_change_to_created_at(); end

  def saved_change_to_created_at?(**options); end

  def saved_change_to_email(); end

  def saved_change_to_email?(**options); end

  def saved_change_to_id(); end

  def saved_change_to_id?(**options); end

  def saved_change_to_name(); end

  def saved_change_to_name?(**options); end

  def saved_change_to_phone(); end

  def saved_change_to_phone?(**options); end

  def saved_change_to_updated_at(); end

  def saved_change_to_updated_at?(**options); end

  def updated_at(); end

  def updated_at=(value); end

  def updated_at?(); end

  def updated_at_before_last_save(); end

  def updated_at_before_type_cast(); end

  def updated_at_came_from_user?(); end

  def updated_at_change(); end

  def updated_at_change_to_be_saved(); end

  def updated_at_changed?(**options); end

  def updated_at_for_database(); end

  def updated_at_in_database(); end

  def updated_at_previous_change(); end

  def updated_at_previously_changed?(**options); end

  def updated_at_previously_was(); end

  def updated_at_was(); end

  def updated_at_will_change!(); end

  def will_save_change_to_created_at?(**options); end

  def will_save_change_to_email?(**options); end

  def will_save_change_to_id?(**options); end

  def will_save_change_to_name?(**options); end

  def will_save_change_to_phone?(**options); end

  def will_save_change_to_updated_at?(**options); end
end

module Contact::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Crass::Parser
  def consume_at_rule(input=T.unsafe(nil)); end

  def consume_component_value(input=T.unsafe(nil)); end

  def consume_declaration(input=T.unsafe(nil)); end

  def consume_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def consume_function(input=T.unsafe(nil)); end

  def consume_qualified_rule(input=T.unsafe(nil)); end

  def consume_rules(flags=T.unsafe(nil)); end

  def consume_simple_block(input=T.unsafe(nil)); end

  def create_node(type, properties=T.unsafe(nil)); end

  def create_selector(input); end

  def create_style_rule(rule); end

  def initialize(input, options=T.unsafe(nil)); end

  def parse_component_value(input=T.unsafe(nil)); end

  def parse_component_values(input=T.unsafe(nil)); end

  def parse_declaration(input=T.unsafe(nil)); end

  def parse_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse_properties(input=T.unsafe(nil)); end

  def parse_rule(input=T.unsafe(nil)); end

  def parse_value(nodes); end

  def tokens(); end
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  def self.parse_properties(input, options=T.unsafe(nil)); end

  def self.parse_rules(input, options=T.unsafe(nil)); end

  def self.parse_stylesheet(input, options=T.unsafe(nil)); end

  def self.stringify(nodes, options=T.unsafe(nil)); end
end

class Crass::Scanner
  def consume(); end

  def consume_rest(); end

  def current(); end

  def eos?(); end

  def initialize(input); end

  def mark(); end

  def marked(); end

  def marker(); end

  def marker=(marker); end

  def peek(length=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def reconsume(); end

  def reset(); end

  def scan(pattern); end

  def scan_until(pattern); end

  def string(); end
end

class Crass::TokenScanner
  def collect(); end

  def consume(); end

  def current(); end

  def initialize(tokens); end

  def peek(); end

  def pos(); end

  def reconsume(); end

  def reset(); end

  def tokens(); end
end

class Crass::Tokenizer
  def consume(); end

  def consume_bad_url(); end

  def consume_comments(); end

  def consume_escaped(); end

  def consume_ident(); end

  def consume_name(); end

  def consume_number(); end

  def consume_numeric(); end

  def consume_string(ending=T.unsafe(nil)); end

  def consume_unicode_range(); end

  def consume_url(); end

  def convert_string_to_number(str); end

  def create_token(type, properties=T.unsafe(nil)); end

  def initialize(input, options=T.unsafe(nil)); end

  def preprocess(input); end

  def start_identifier?(text=T.unsafe(nil)); end

  def start_number?(text=T.unsafe(nil)); end

  def tokenize(); end

  def valid_escape?(text=T.unsafe(nil)); end
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  def self.tokenize(input, options=T.unsafe(nil)); end
end

module Crass
  def self.parse(input, options=T.unsafe(nil)); end

  def self.parse_properties(input, options=T.unsafe(nil)); end
end

module DEBUGGER__
  CONFIG = ::T.let(nil, ::T.untyped)
  CONFIG_MAP = ::T.let(nil, ::T.untyped)
  CONFIG_SET = ::T.let(nil, ::T.untyped)
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
  M_CLASS = ::T.let(nil, ::T.untyped)
  M_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  M_INSTANCE_VARIABLE_GET = ::T.let(nil, ::T.untyped)
  M_KIND_OF_P = ::T.let(nil, ::T.untyped)
  M_METHOD = ::T.let(nil, ::T.untyped)
  M_NAME = ::T.let(nil, ::T.untyped)
  M_OBJECT_ID = ::T.let(nil, ::T.untyped)
  M_RESPOND_TO_P = ::T.let(nil, ::T.untyped)
  M_SINGLETON_CLASS = ::T.let(nil, ::T.untyped)
  SESSION = ::T.let(nil, ::T.untyped)
  SHORT_INSPECT_LENGTH = ::T.let(nil, ::T.untyped)
  SO_VERSION = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::Color
  SUPPORT_COLORABLE_OPTION = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::Console
  def deactivate(); end

  def history(); end

  def history_file(); end

  def load_history(); end

  def load_history_if_not_loaded(); end

  def parse_input(buff, commands); end

  def read_history_file(); end

  def readline(prompt); end

  def readline_setup(prompt); end
  FH = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::ForkInterceptor
  def _fork(); end
end

module DEBUGGER__::ForkInterceptor::DaemonInterceptor
  def daemon(*args); end
end

class DEBUGGER__::FrameInfo
  BLOCK_LABL_REGEXP = ::T.let(nil, ::T.untyped)
  HOME = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::GlobalVariablesHelper
  SKIP_GLOBAL_LIST = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::LimitedPP
  def <<(other); end

  def buf(); end

  def initialize(max); end
end

class DEBUGGER__::LimitedPP
  def self.pp(obj, max=T.unsafe(nil)); end
end

module DEBUGGER__::MultiProcessGroup
  def after_fork(child: T.unsafe(nil)); end

  def info(msg); end

  def lock(); end

  def locked?(); end

  def multi_process!(); end

  def sync(&b); end

  def unlock(); end
end

class DEBUGGER__::ProcessGroup
  def after_fork(); end

  def lock(); end

  def locked?(); end

  def multi?(); end

  def multi_process!(); end

  def sync(); end

  def trylock(); end

  def unlock(); end
end

class DEBUGGER__::Session
  def activate_irb_integration(); end

  def after_fork_parent(); end

  def before_fork(need_lock=T.unsafe(nil)); end

  def capture_exception_frames(*exclude_path); end

  def check_postmortem(); end

  def check_unsafe(); end

  def enter_postmortem_session(exc); end

  def extend_feature(session: T.unsafe(nil), thread_client: T.unsafe(nil), ui: T.unsafe(nil)); end

  def intercept_trap_sigint(flag, &b); end

  def intercept_trap_sigint?(); end

  def intercept_trap_sigint_end(); end

  def intercept_trap_sigint_start(prev); end

  def postmortem=(is_enable); end

  def process_info(); end

  def save_int_trap(cmd); end

  def set_no_sigint_hook(old, new); end

  def width(); end
  BREAK_KEYWORDS = ::T.let(nil, ::T.untyped)
  METHOD_ADDED_TRACKERS = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::Session
  def self.activate_method_added_trackers(); end

  def self.create_method_added_tracker(mod, method_added_id, method_accessor=T.unsafe(nil)); end

  def self.deactivate_method_added_trackers(); end
end

class DEBUGGER__::ThreadClient
  SPECIAL_LOCAL_VARS = ::T.let(nil, ::T.untyped)
  SUPPORT_TARGET_THREAD = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::TrapInterceptor
  def trap(sig, *command, &command_proc); end
end

class DEBUGGER__::UI_Base
  def event(type, *args); end

  def flush(); end

  def ignore_output_on_suspend?(); end
end

class DEBUGGER__::UI_LocalConsole
  def activate(session, on_fork: T.unsafe(nil)); end

  def activate_sigint(); end

  def after_fork_parent(); end

  def ask(prompt); end

  def deactivate(); end

  def deactivate_sigint(); end

  def puts(str=T.unsafe(nil)); end

  def quit(n); end

  def readline(prompt=T.unsafe(nil)); end

  def remote?(); end

  def setup_interrupt(); end

  def width(); end
end

module DEBUGGER__
  def self.add_catch_breakpoint(pat); end

  def self.add_line_breakpoint(file, line, **kw); end

  def self.check_loglevel(level); end

  def self.compare_path(a, b); end

  def self.debug(&b); end

  def self.info(msg); end

  def self.initialize_session(&init_ui); end

  def self.load_rc(); end

  def self.log(level, msg); end

  def self.open(host: T.unsafe(nil), port: T.unsafe(nil), sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end

  def self.open_tcp(port:, host: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end

  def self.open_unix(sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end

  def self.require_location(); end

  def self.safe_inspect(obj, max_length: T.unsafe(nil), short: T.unsafe(nil)); end

  def self.setup_initial_suspend(); end

  def self.skip?(); end

  def self.skip_all(); end

  def self.start(nonstop: T.unsafe(nil), **kw); end

  def self.step_in(&b); end

  def self.warn(msg); end
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

class DRb::ThreadObject
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  VERSION = ::T.let(nil, ::T.untyped)
end

class DateTime
  def acts_like_time?(); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  def self.use_rfc4122_namespaced_uuids(); end

  def self.use_rfc4122_namespaced_uuids=(val); end

  def self.uuid_from_hash(hash_class, namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Escape
end

module ERB::Escape
  def self.html_escape(arg); end
end

module ERB::Util
  include ::ERB::Escape
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_FOLLOWING_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
  TAG_NAME_START_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_START_REGEXP_SET = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def compact(); end
end

module Enumerable
  extend ::ActiveSupport::EnumerableCoreExt::Constants
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

module Erubi
  FREEZE_TEMPLATE_LITERALS = ::T.let(nil, ::T.untyped)
  MATCH_METHOD = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  SKIP_DEFINED_FOR_INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Erubi::Engine
  def bufvar(); end

  def filename(); end

  def initialize(input, properties=T.unsafe(nil)); end

  def src(); end
  DEFAULT_REGEXP = ::T.let(nil, ::T.untyped)
end

module Erubi
  def self.h(arg); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid=(_); end

  def mem=(_); end

  def name=(_); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

module FactoryBot
  Deprecation = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Attribute
  def alias_for?(attr); end

  def association?(); end

  def ignored(); end

  def initialize(name, ignored); end

  def name(); end

  def to_proc(); end
end

class FactoryBot::Attribute::Association
  def factory(); end

  def initialize(name, factory, overrides); end
end

class FactoryBot::Attribute::Dynamic
  def initialize(name, ignored, block); end
end

class FactoryBot::Attribute::Sequence
  def initialize(name, sequence, ignored); end
end

class FactoryBot::AttributeAssigner
  def initialize(evaluator, build_class, &instance_builder); end

  def object(); end
end

class FactoryBot::AttributeList
  def apply_attributes(attributes_to_apply); end

  def associations(); end

  def define_attribute(attribute); end

  def each(&block); end

  def ignored(); end

  def initialize(name=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def names(); end

  def non_ignored(); end
end

class FactoryBot::Callback
  def ==(other); end

  def block(); end

  def initialize(name, block); end

  def name(); end

  def run(instance, evaluator); end
end

class FactoryBot::CallbacksObserver
  def initialize(callbacks, evaluator); end

  def update(name, result_instance); end
end

class FactoryBot::Configuration
  def after(*arg, **arg1, &arg2); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def callback_names(); end

  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def factories(); end

  def initialize_with(&block); end

  def inline_sequences(); end

  def sequences(); end

  def skip_create(*arg, **arg1, &arg2); end

  def strategies(); end

  def to_create(*arg, **arg1, &arg2); end

  def traits(); end
end

class FactoryBot::Declaration
  def ignored(); end

  def initialize(name, ignored=T.unsafe(nil)); end

  def name(); end

  def to_attributes(); end
end

class FactoryBot::Declaration::Association
  def ==(other); end

  def initialize(name, *options); end

  def options(); end
end

class FactoryBot::Declaration::Dynamic
  def ==(other); end

  def block(); end

  def initialize(name, ignored=T.unsafe(nil), block=T.unsafe(nil)); end
end

class FactoryBot::Declaration::Implicit
  def ==(other); end

  def factory(); end

  def initialize(name, factory=T.unsafe(nil), ignored=T.unsafe(nil)); end
end

class FactoryBot::DeclarationList
  def attributes(); end

  def declare_attribute(declaration); end

  def each(&block); end

  def initialize(name=T.unsafe(nil)); end

  def overridable(); end
end

class FactoryBot::Decorator
  def initialize(component); end

  def method_missing(*arg, **arg1, &arg2); end

  def send(*arg, **arg1, &arg2); end
end

class FactoryBot::Decorator::AttributeHash
  def attributes(); end

  def initialize(component, attributes=T.unsafe(nil)); end
end

class FactoryBot::Decorator::DisallowsDuplicatesRegistry
  def register(name, item); end
end

class FactoryBot::Decorator::InvocationTracker
  def __invoked_methods__(); end

  def method_missing(name, *args, **arg, &block); end
end

class FactoryBot::Decorator::NewConstructor
  def initialize(component, build_class); end

  def new(*arg, **arg1, &arg2); end
end

class FactoryBot::Decorator
  def self.const_missing(name); end
end

class FactoryBot::Definition
  def add_callback(callback); end

  def after(*names, &block); end

  def append_traits(new_traits); end

  def attributes(); end

  def before(*names, &block); end

  def callback(*names, &block); end

  def callbacks(); end

  def compile(klass=T.unsafe(nil)); end

  def constructor(); end

  def declarations(); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_constructor(&block); end

  def define_trait(trait); end

  def defined_traits(); end

  def inherit_traits(new_traits); end

  def initialize(name, base_traits=T.unsafe(nil)); end

  def klass(); end

  def klass=(klass); end

  def name(); end

  def overridable(); end

  def register_enum(enum); end

  def registered_enums(); end

  def skip_create(); end

  def to_create(&block); end
end

class FactoryBot::DefinitionHierarchy
  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def to_create(*arg, **arg1, &arg2); end
end

class FactoryBot::DefinitionHierarchy
  def self.build_from_definition(definition); end
end

class FactoryBot::DefinitionProxy
  def add_attribute(name, &block); end

  def after(*arg, **arg1, &arg2); end

  def association(name, *options); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def child_factories(); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize(definition, ignore=T.unsafe(nil)); end

  def initialize_with(&block); end

  def method_missing(name, *args, &block); end

  def sequence(name, *arg, **arg1, &arg2); end

  def singleton_method_added(name); end

  def skip_create(); end

  def to_create(&block); end

  def trait(name, &block); end

  def traits_for_enum(attribute_name, values=T.unsafe(nil)); end

  def transient(&block); end
  UNPROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Enum
  def build_traits(klass); end

  def initialize(attribute_name, values=T.unsafe(nil)); end
end

class FactoryBot::Evaluation
  def create(result_instance); end

  def hash(*arg, **arg1, &arg2); end

  def initialize(evaluator, attribute_assigner, to_create, observer); end

  def notify(name, result_instance); end

  def object(*arg, **arg1, &arg2); end
end

class FactoryBot::Evaluator
  def __override_names__(); end

  def association(factory_name, *traits_and_overrides); end

  def attribute_lists(); end

  def attribute_lists=(attribute_lists); end

  def attribute_lists?(); end

  def increment_sequence(sequence); end

  def initialize(build_strategy, overrides=T.unsafe(nil)); end

  def instance(); end

  def instance=(instance); end

  def method_missing(method_name, *arg, **arg1, &arg2); end
end

class FactoryBot::Evaluator
  def self.attribute_list(); end

  def self.attribute_lists(); end

  def self.attribute_lists=(value); end

  def self.attribute_lists?(); end

  def self.define_attribute(name, &block); end
end

class FactoryBot::EvaluatorClassDefiner
  def evaluator_class(); end

  def initialize(attributes, parent_class); end
end

class FactoryBot::Factory
  def add_callback(*arg, **arg1, &arg2); end

  def append_traits(*arg, **arg1, &arg2); end

  def associations(); end

  def attributes(); end

  def build_class(); end

  def build_hierarchy(); end

  def callbacks(); end

  def class_name(); end

  def compile(); end

  def compiled_constructor(); end

  def compiled_to_create(); end

  def constructor(*arg, **arg1, &arg2); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_trait(*arg, **arg1, &arg2); end

  def defined_traits(*arg, **arg1, &arg2); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def hierarchy_instance(); end

  def human_names(); end

  def inherit_traits(*arg, **arg1, &arg2); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def names(); end

  def run(build_strategy, overrides, &block); end

  def to_create(*arg, **arg1, &arg2); end

  def with_traits(traits); end
end

class FactoryBot::FactoryRunner
  def initialize(name, strategy, traits_and_overrides); end

  def run(runner_strategy=T.unsafe(nil), &block); end
end

module FactoryBot::Internal
  def self.after(*arg, **arg1, &arg2); end

  def self.before(*arg, **arg1, &arg2); end

  def self.callbacks(*arg, **arg1, &arg2); end

  def self.configuration(); end

  def self.constructor(*arg, **arg1, &arg2); end

  def self.factories(*arg, **arg1, &arg2); end

  def self.factory_by_name(name); end

  def self.initialize_with(*arg, **arg1, &arg2); end

  def self.inline_sequences(*arg, **arg1, &arg2); end

  def self.register_default_strategies(); end

  def self.register_factory(factory); end

  def self.register_inline_sequence(sequence); end

  def self.register_sequence(sequence); end

  def self.register_strategy(strategy_name, strategy_class); end

  def self.register_trait(trait); end

  def self.reset_configuration(); end

  def self.rewind_inline_sequences(); end

  def self.rewind_sequences(); end

  def self.sequence_by_name(name); end

  def self.sequences(*arg, **arg1, &arg2); end

  def self.skip_create(*arg, **arg1, &arg2); end

  def self.strategies(*arg, **arg1, &arg2); end

  def self.strategy_by_name(name); end

  def self.to_create(*arg, **arg1, &arg2); end

  def self.trait_by_name(name, klass); end

  def self.traits(*arg, **arg1, &arg2); end
end

class FactoryBot::Linter
  def initialize(factories, strategy: T.unsafe(nil), traits: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def lint!(); end
end

class FactoryBot::Linter::FactoryError
  def initialize(wrapped_error, factory); end

  def location(); end

  def message(); end

  def verbose_message(); end
end

class FactoryBot::Linter::FactoryTraitError
  def initialize(wrapped_error, factory, trait_name); end
end

class FactoryBot::NullFactory
  def attributes(*arg, **arg1, &arg2); end

  def callbacks(*arg, **arg1, &arg2); end

  def class_name(); end

  def compile(); end

  def constructor(*arg, **arg1, &arg2); end

  def defined_traits(*arg, **arg1, &arg2); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def to_create(*arg, **arg1, &arg2); end
end

class FactoryBot::NullObject
  def initialize(methods_to_respond_to); end

  def method_missing(name, *args, &block); end

  def respond_to?(method); end
end

class FactoryBot::Registry
  def [](name); end

  def clear(); end

  def each(&block); end

  def find(name); end

  def initialize(name); end

  def name(); end

  def register(name, item); end

  def registered?(name); end
end

class FactoryBot::Sequence
  def initialize(name, *args, &proc); end

  def name(); end

  def names(); end

  def next(scope=T.unsafe(nil)); end

  def rewind(); end
end

class FactoryBot::Sequence::EnumeratorAdapter
  def initialize(value); end

  def next(); end

  def peek(); end

  def rewind(); end
end

class FactoryBot::Strategy::AttributesFor
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Build
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Create
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Null
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Stub
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
  DISABLED_PERSISTENCE_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Strategy::Stub
  def self.next_id=(id); end
end

class FactoryBot::StrategyCalculator
  def initialize(name_or_object); end

  def strategy(); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def define_strategy_methods(); end

  def initialize(strategy_name); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def self.with_index(block, index); end
end

module FactoryBot::Syntax::Default
  def define(&block); end

  def modify(&block); end
end

class FactoryBot::Syntax::Default::DSL
  def after(*arg, **arg1, &arg2); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize_with(*arg, **arg1, &arg2); end

  def sequence(name, *arg, **arg1, &arg2); end

  def skip_create(*arg, **arg1, &arg2); end

  def to_create(*arg, **arg1, &arg2); end

  def trait(name, &block); end
end

class FactoryBot::Syntax::Default::DSL
  def self.run(block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def factory(name, _options=T.unsafe(nil), &block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def self.run(block); end
end

module FactoryBot::Syntax::Methods
  def attributes_for(name, *traits_and_overrides, &block); end

  def attributes_for_list(name, amount, *traits_and_overrides, &block); end

  def attributes_for_pair(name, *traits_and_overrides, &block); end

  def build(name, *traits_and_overrides, &block); end

  def build_list(name, amount, *traits_and_overrides, &block); end

  def build_pair(name, *traits_and_overrides, &block); end

  def build_stubbed(name, *traits_and_overrides, &block); end

  def build_stubbed_list(name, amount, *traits_and_overrides, &block); end

  def build_stubbed_pair(name, *traits_and_overrides, &block); end

  def create(name, *traits_and_overrides, &block); end

  def create_list(name, amount, *traits_and_overrides, &block); end

  def create_pair(name, *traits_and_overrides, &block); end

  def generate(name); end

  def generate_list(name, count); end

  def null(name, *traits_and_overrides, &block); end

  def null_list(name, amount, *traits_and_overrides, &block); end

  def null_pair(name, *traits_and_overrides, &block); end
end

class FactoryBot::Trait
  def ==(other); end

  def add_callback(*arg, **arg1, &arg2); end

  def attributes(*arg, **arg1, &arg2); end

  def block(); end

  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_trait(*arg, **arg1, &arg2); end

  def definition(); end

  def initialize(name, &block); end

  def klass(*arg, **arg1, &arg2); end

  def klass=(arg); end

  def name(); end

  def names(); end

  def to_create(*arg, **arg1, &arg2); end
end

module FactoryBot
  def self.aliases(); end

  def self.aliases=(aliases); end

  def self.aliases_for(attribute); end

  def self.automatically_define_enum_traits(); end

  def self.automatically_define_enum_traits=(val); end

  def self.build_stubbed_starting_id=(starting_id); end

  def self.definition_file_paths(); end

  def self.definition_file_paths=(definition_file_paths); end

  def self.factories(*arg, **arg1, &arg2); end

  def self.find_definitions(); end

  def self.lint(*args); end

  def self.register_strategy(*arg, **arg1, &arg2); end

  def self.reload(); end

  def self.rewind_sequences(*arg, **arg1, &arg2); end

  def self.strategy_by_name(*arg, **arg1, &arg2); end

  def self.use_parent_strategy(); end

  def self.use_parent_strategy=(val); end
end

class FactoryBotRails::DefinitionFilePaths
  def any?(); end

  def directories(); end

  def files(); end

  def initialize(definition_file_paths); end
end

class FactoryBotRails::FactoryValidator
  def add_validator(validator); end

  def initialize(validators=T.unsafe(nil)); end

  def run(); end
end

class FactoryBotRails::Generator
  def factory_bot_disabled?(); end

  def generator(); end

  def initialize(config); end

  def rails_options(); end

  def run(); end

  def test_framework(); end
end

class FactoryBotRails::Generators::NonRSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Generators::NullGenerator
  def initialize(*arg); end

  def run(); end
end

class FactoryBotRails::Generators::RSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Reloader
  def initialize(app); end

  def run(); end
end

module Faker
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faker::Address
  def self.building_number(); end

  def self.city(options: T.unsafe(nil)); end

  def self.city_prefix(); end

  def self.city_suffix(); end

  def self.community(); end

  def self.country(); end

  def self.country_by_code(code: T.unsafe(nil)); end

  def self.country_code(); end

  def self.country_code_long(); end

  def self.country_name_to_code(name: T.unsafe(nil)); end

  def self.full_address(); end

  def self.full_address_as_hash(*attrs, **attrs_params); end

  def self.latitude(); end

  def self.longitude(); end

  def self.mail_box(); end

  def self.postcode(state_abbreviation: T.unsafe(nil)); end

  def self.secondary_address(); end

  def self.state(); end

  def self.state_abbr(); end

  def self.street_address(include_secondary: T.unsafe(nil)); end

  def self.street_name(); end

  def self.street_suffix(); end

  def self.time_zone(); end

  def self.zip(state_abbreviation: T.unsafe(nil)); end

  def self.zip_code(state_abbreviation: T.unsafe(nil)); end
end

class Faker::Adjective
  def self.negative(); end

  def self.positive(); end
end

class Faker::Alphanumeric
  ALPHANUMS = ::T.let(nil, ::T.untyped)
end

class Faker::Alphanumeric
  def self.alpha(number: T.unsafe(nil)); end

  def self.alphanumeric(number: T.unsafe(nil), min_alpha: T.unsafe(nil), min_numeric: T.unsafe(nil)); end
end

class Faker::Ancient
  def self.god(); end

  def self.hero(); end

  def self.primordial(); end

  def self.titan(); end
end

class Faker::App
  def self.author(); end

  def self.semantic_version(major: T.unsafe(nil), minor: T.unsafe(nil), patch: T.unsafe(nil)); end

  def self.version(); end
end

class Faker::Appliance
  def self.brand(); end

  def self.equipment(); end
end

class Faker::Avatar
  def self.image(slug: T.unsafe(nil), size: T.unsafe(nil), format: T.unsafe(nil), set: T.unsafe(nil), bgset: T.unsafe(nil)); end
end

class Faker::Bank
  def self.account_number(digits: T.unsafe(nil)); end

  def self.bsb_number(); end

  def self.iban(country_code: T.unsafe(nil)); end

  def self.iban_country_code(); end

  def self.routing_number(); end

  def self.routing_number_with_format(); end

  def self.swift_bic(); end
end

class Faker::Barcode
  def self.ean(length=T.unsafe(nil)); end

  def self.ean_with_composite_symbology(length=T.unsafe(nil)); end

  def self.isbn(); end

  def self.ismn(); end

  def self.issn(); end

  def self.upc_a(); end

  def self.upc_a_with_composite_symbology(); end

  def self.upc_e(); end

  def self.upc_e_with_composite_symbology(); end
end

class Faker::Base
  LLetters = ::T.let(nil, ::T.untyped)
  Letters = ::T.let(nil, ::T.untyped)
  Numbers = ::T.let(nil, ::T.untyped)
  ULetters = ::T.let(nil, ::T.untyped)
end

class Faker::Base
  def self.bothify(string); end

  def self.disable_enforce_available_locales(); end

  def self.fetch(key); end

  def self.fetch_all(key); end

  def self.flexible(key); end

  def self.flexible_key(); end

  def self.generate(as_type, &block); end

  def self.letterify(letter_string); end

  def self.method_missing(mth, *args, &block); end

  def self.numerify(number_string, leading_zero: T.unsafe(nil)); end

  def self.parse(key); end

  def self.rand(max=T.unsafe(nil)); end

  def self.rand_in_range(from, to); end

  def self.regexify(reg); end

  def self.resolve(value); end

  def self.respond_to_missing?(method_name, include_private=T.unsafe(nil)); end

  def self.sample(list, num=T.unsafe(nil)); end

  def self.shuffle(list); end

  def self.translate(*args, **opts); end

  def self.unique(max_retries=T.unsafe(nil)); end

  def self.with_locale(tmp_locale=T.unsafe(nil), &block); end
end

module Faker::Base58
  def self.encode(str); end
end

class Faker::Beer
  def self.alcohol(); end

  def self.blg(); end

  def self.hop(); end

  def self.ibu(); end

  def self.malts(); end

  def self.style(); end

  def self.yeast(); end
end

class Faker::Blockchain::Aeternity
  def self.address(); end

  def self.contract(); end

  def self.oracle(); end

  def self.rand_strings(length=T.unsafe(nil)); end

  def self.transaction(); end
end

class Faker::Blockchain::Bitcoin
  def self.address(); end

  def self.address_for(network); end

  def self.testnet_address(); end
end

class Faker::Blockchain::Ethereum
  def self.address(); end
end

class Faker::Blockchain::Tezos
  def self.account(); end

  def self.block(); end

  def self.contract(); end

  def self.encode_tz(prefix, payload_size); end

  def self.operation(); end

  def self.public_key(); end

  def self.secret_key(); end

  def self.signature(); end
end

class Faker::Blood
  def self.group(); end

  def self.rh_factor(); end

  def self.type(); end
end

class Faker::Book
  def self.author(); end

  def self.genre(); end

  def self.publisher(); end

  def self.title(); end
end

class Faker::Books::CultureSeries
  def self.book(); end

  def self.civ(); end

  def self.culture_ship(); end

  def self.culture_ship_class(); end

  def self.culture_ship_class_abv(); end

  def self.planet(); end
end

class Faker::Books::Dune
  def self.character(); end

  def self.city(); end

  def self.planet(); end

  def self.quote(character: T.unsafe(nil)); end

  def self.saying(source: T.unsafe(nil)); end

  def self.title(); end
end

class Faker::Books::Lovecraft
  def self.deity(); end

  def self.fhtagn(number: T.unsafe(nil)); end

  def self.location(); end

  def self.paragraph(sentence_count: T.unsafe(nil), random_sentences_to_add: T.unsafe(nil)); end

  def self.paragraph_by_chars(characters: T.unsafe(nil)); end

  def self.paragraphs(number: T.unsafe(nil)); end

  def self.sentence(word_count: T.unsafe(nil), random_words_to_add: T.unsafe(nil), open_compounds_allowed: T.unsafe(nil)); end

  def self.sentences(number: T.unsafe(nil)); end

  def self.tome(); end

  def self.word(); end

  def self.words(number: T.unsafe(nil), spaces_allowed: T.unsafe(nil)); end
end

class Faker::Books::TheKingkillerChronicle
  def self.book(); end

  def self.character(); end

  def self.creature(); end

  def self.location(); end
end

class Faker::Boolean
  def self.boolean(true_ratio: T.unsafe(nil)); end
end

class Faker::BossaNova
  def self.artist(); end

  def self.song(); end
end

class Faker::Business
  def self.credit_card_expiry_date(); end

  def self.credit_card_number(); end

  def self.credit_card_type(); end
end

class Faker::Camera
  def self.brand(); end

  def self.brand_with_model(); end

  def self.model(); end
end

class Faker::Cannabis
  def self.brand(); end

  def self.buzzword(); end

  def self.cannabinoid(); end

  def self.cannabinoid_abbreviation(); end

  def self.category(); end

  def self.health_benefit(); end

  def self.medical_use(); end

  def self.strain(); end

  def self.terpene(); end

  def self.type(); end
end

module Faker::Char
  def self.fix_umlauts(string); end

  def self.prepare(string); end

  def self.romanize_cyrillic(string); end
end

class Faker::ChileRut
  def self.check_digit(); end

  def self.dv(); end

  def self.full_rut(min_rut: T.unsafe(nil), max_rut: T.unsafe(nil), fixed: T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.last_rut(); end

  def self.rut(min_rut: T.unsafe(nil), max_rut: T.unsafe(nil), fixed: T.unsafe(nil)); end
end

class Faker::ChuckNorris
  def self.fact(); end
end

class Faker::Code
  def self.asin(); end

  def self.ean(base: T.unsafe(nil)); end

  def self.imei(); end

  def self.isbn(base: T.unsafe(nil)); end

  def self.npi(); end

  def self.nric(min_age: T.unsafe(nil), max_age: T.unsafe(nil)); end

  def self.rut(); end

  def self.sin(); end
end

class Faker::Coffee
  def self.blend_name(); end

  def self.intensifier(); end

  def self.notes(); end

  def self.origin(); end

  def self.variety(); end
end

class Faker::Coin
  def self.flip(); end
end

class Faker::Color
  def self.color_name(); end

  def self.hex_color(args=T.unsafe(nil)); end

  def self.hsl_color(hue: T.unsafe(nil), saturation: T.unsafe(nil), lightness: T.unsafe(nil)); end

  def self.hsla_color(); end

  def self.rgb_color(); end

  def self.single_rgb_color(); end
end

class Faker::Commerce
  def self.brand(); end

  def self.color(); end

  def self.department(max: T.unsafe(nil), fixed_amount: T.unsafe(nil)); end

  def self.material(); end

  def self.price(range: T.unsafe(nil), as_string: T.unsafe(nil)); end

  def self.product_name(); end

  def self.promotion_code(digits: T.unsafe(nil)); end

  def self.vendor(); end
end

class Faker::Company
  def self.australian_business_number(); end

  def self.brazilian_company_number(formatted: T.unsafe(nil)); end

  def self.bs(); end

  def self.buzzword(); end

  def self.catch_phrase(); end

  def self.czech_organisation_number(); end

  def self.department(); end

  def self.duns_number(); end

  def self.ein(); end

  def self.french_siren_number(); end

  def self.french_siret_number(); end

  def self.indian_gst_number(state_code: T.unsafe(nil)); end

  def self.industry(); end

  def self.logo(); end

  def self.norwegian_organisation_number(); end

  def self.polish_register_of_national_economy(length: T.unsafe(nil)); end

  def self.polish_taxpayer_identification_number(); end

  def self.profession(); end

  def self.russian_tax_number(region: T.unsafe(nil), type: T.unsafe(nil)); end

  def self.sic_code(); end

  def self.south_african_close_corporation_registration_number(); end

  def self.south_african_listed_company_registration_number(); end

  def self.south_african_pty_ltd_registration_number(); end

  def self.south_african_trust_registration_number(); end

  def self.spanish_organisation_number(organization_type: T.unsafe(nil)); end

  def self.suffix(); end

  def self.swedish_organisation_number(); end

  def self.type(); end
end

class Faker::Compass
  def self.abbreviation(); end

  def self.azimuth(); end

  def self.cardinal(); end

  def self.cardinal_abbreviation(); end

  def self.cardinal_azimuth(); end

  def self.direction(); end

  def self.half_wind(); end

  def self.half_wind_abbreviation(); end

  def self.half_wind_azimuth(); end

  def self.ordinal(); end

  def self.ordinal_abbreviation(); end

  def self.ordinal_azimuth(); end

  def self.quarter_wind(); end

  def self.quarter_wind_abbreviation(); end

  def self.quarter_wind_azimuth(); end
end

class Faker::Computer
  def self.os(platform: T.unsafe(nil)); end

  def self.platform(); end

  def self.stack(); end

  def self.type(); end
end

module Faker::Config
  def self.default_locale=(default_locale); end

  def self.locale(); end

  def self.locale=(new_locale); end

  def self.own_locale(); end

  def self.random(); end

  def self.random=(new_random); end
end

class Faker::Construction
  def self.heavy_equipment(); end

  def self.material(); end

  def self.role(); end

  def self.standard_cost_code(); end

  def self.subcontract_category(); end

  def self.trade(); end
end

class Faker::Cosmere
  def self.allomancer(); end

  def self.aon(); end

  def self.feruchemist(); end

  def self.herald(); end

  def self.knight_radiant(); end

  def self.metal(); end

  def self.shard(); end

  def self.shard_world(); end

  def self.spren(); end

  def self.surge(); end
end

class Faker::Creature::Bird
  def self.adjective(); end

  def self.anatomy(); end

  def self.anatomy_past_tense(); end

  def self.color(); end

  def self.common_family_name(); end

  def self.common_name(tax_order=T.unsafe(nil)); end

  def self.emotional_adjective(); end

  def self.geo(); end

  def self.implausible_common_name(); end

  def self.order(); end

  def self.order_with_common_name(tax_order=T.unsafe(nil)); end

  def self.plausible_common_name(); end

  def self.silly_adjective(); end
end

class Faker::Creature::Cat
  def self.breed(); end

  def self.registry(); end
end

class Faker::Creature::Dog
  def self.age(); end

  def self.breed(); end

  def self.coat_length(); end

  def self.gender(); end

  def self.meme_phrase(); end

  def self.size(); end

  def self.sound(); end
end

class Faker::Creature::Horse
  def self.breed(); end
end

class Faker::Crypto
  def self.md5(); end

  def self.sha1(); end

  def self.sha256(); end

  def self.sha512(); end
end

class Faker::CryptoCoin
  def self.acronym(coin: T.unsafe(nil)); end

  def self.coin_array(); end

  def self.coin_hash(); end

  def self.coin_name(coin: T.unsafe(nil)); end

  def self.url_logo(coin: T.unsafe(nil)); end
end

class Faker::Currency
  def self.code(); end

  def self.symbol(); end
end

class Faker::Date
  DAYS_OF_WEEK = ::T.let(nil, ::T.untyped)
end

class Faker::Date
  def self.backward(days: T.unsafe(nil)); end

  def self.between(from:, to:); end

  def self.between_except(from:, to:, excepted:); end

  def self.birthday(min_age: T.unsafe(nil), max_age: T.unsafe(nil)); end

  def self.forward(from: T.unsafe(nil), days: T.unsafe(nil)); end

  def self.in_date_period(month: T.unsafe(nil), year: T.unsafe(nil)); end

  def self.on_day_of_week_between(day:, from:, to:); end
end

class Faker::DcComics
  def self.hero(); end

  def self.heroine(); end

  def self.title(); end

  def self.villain(); end
end

class Faker::Demographic
  def self.demonym(); end

  def self.educational_attainment(); end

  def self.height(unit: T.unsafe(nil)); end

  def self.marital_status(); end

  def self.race(); end

  def self.sex(); end
end

module Faker::Deprecator
  def self.included(base); end

  def self.skip(); end

  def self.skip=(value); end

  def self.skip_warning(); end

  def self.skip_warning?(); end
end

class Faker::Dessert
  def self.flavor(); end

  def self.topping(); end

  def self.variety(); end
end

class Faker::Device
  def self.build_number(); end

  def self.manufacturer(); end

  def self.model_name(); end

  def self.platform(); end

  def self.serial(); end

  def self.version(); end
end

class Faker::DrivingLicence
  GB_PADDING = ::T.let(nil, ::T.untyped)
  NI_CHANCE = ::T.let(nil, ::T.untyped)
end

class Faker::DrivingLicence
  def self.british_driving_licence(last_name: T.unsafe(nil), initials: T.unsafe(nil), gender: T.unsafe(nil), date_of_birth: T.unsafe(nil)); end

  def self.northern_irish_driving_licence(); end

  def self.uk_driving_licence(*args); end

  def self.usa_driving_licence(state=T.unsafe(nil)); end
end

class Faker::Drone
  def self.battery_capacity(); end

  def self.battery_type(); end

  def self.battery_voltage(); end

  def self.battery_weight(); end

  def self.charging_temperature(); end

  def self.flight_time(); end

  def self.iso(); end

  def self.max_altitude(); end

  def self.max_angular_velocity(); end

  def self.max_ascent_speed(); end

  def self.max_charging_power(); end

  def self.max_descent_speed(); end

  def self.max_flight_distance(); end

  def self.max_resolution(); end

  def self.max_shutter_speed(); end

  def self.max_speed(); end

  def self.max_tilt_angle(); end

  def self.max_wind_resistance(); end

  def self.min_shutter_speed(); end

  def self.operating_temperature(); end

  def self.photo_format(); end

  def self.shutter_speed_range(); end

  def self.video_format(); end

  def self.weight(); end
end

class Faker::Educator
  def self.campus(); end

  def self.course(); end

  def self.course_name(); end

  def self.degree(); end

  def self.primary_school(); end

  def self.secondary_school(); end

  def self.subject(); end

  def self.university(); end
end

class Faker::ElectricalComponents
  def self.active(); end

  def self.electromechanical(); end

  def self.passive(); end
end

class Faker::Emotion
  def self.adjective(); end

  def self.noun(); end
end

class Faker::Esport
  def self.event(); end

  def self.game(); end

  def self.league(); end

  def self.player(); end

  def self.team(); end
end

class Faker::Fantasy::Tolkien
  def self.character(); end

  def self.location(); end

  def self.poem(); end

  def self.race(); end
end

class Faker::File
  def self.dir(segment_count: T.unsafe(nil), root: T.unsafe(nil), directory_separator: T.unsafe(nil)); end

  def self.extension(); end

  def self.file_name(dir: T.unsafe(nil), name: T.unsafe(nil), ext: T.unsafe(nil), directory_separator: T.unsafe(nil)); end

  def self.mime_type(media_type: T.unsafe(nil)); end
end

class Faker::Finance
  CREDIT_CARD_TYPES = ::T.let(nil, ::T.untyped)
  MARKET_LIST = ::T.let(nil, ::T.untyped)
end

class Faker::Finance
  def self.condominium_fiscal_code(country: T.unsafe(nil)); end

  def self.credit_card(*types); end

  def self.stock_market(); end

  def self.ticker(*markets); end

  def self.vat_number(country: T.unsafe(nil)); end

  def self.vat_number_keys(); end
end

class Faker::Food
  def self.allergen(); end

  def self.description(); end

  def self.dish(); end

  def self.ethnic_category(); end

  def self.fruits(); end

  def self.ingredient(); end

  def self.measurement(); end

  def self.metric_measurement(); end

  def self.spice(); end

  def self.vegetables(); end
end

class Faker::FunnyName
  def self.four_word_name(); end

  def self.name_with_initial(); end

  def self.three_word_name(); end

  def self.two_word_name(); end
end

class Faker::Game
  def self.genre(); end

  def self.platform(); end

  def self.title(); end
end

class Faker::Games::ClashOfClans
  def self.defensive_building(); end

  def self.rank(); end

  def self.troop(); end
end

class Faker::Games::Control
  def self.altered_item(); end

  def self.altered_world_event(); end

  def self.character(); end

  def self.hiss(); end

  def self.location(); end

  def self.object_of_power(); end

  def self.quote(); end

  def self.the_board(); end
end

class Faker::Games::DnD
  def self.alignment(); end

  def self.background(); end

  def self.city(); end

  def self.first_name(); end

  def self.klass(); end

  def self.language(); end

  def self.last_name(); end

  def self.melee_weapon(); end

  def self.monster(); end

  def self.race(); end

  def self.ranged_weapon(); end

  def self.title_name(); end
end

class Faker::Games::Dota
  def self.building(); end

  def self.hero(); end

  def self.item(); end

  def self.player(); end

  def self.quote(hero: T.unsafe(nil)); end

  def self.team(); end
end

class Faker::Games::ElderScrolls
  def self.city(); end

  def self.creature(); end

  def self.dragon(); end

  def self.first_name(); end

  def self.jewelry(); end

  def self.last_name(); end

  def self.race(); end

  def self.region(); end

  def self.weapon(); end
end

class Faker::Games::Fallout
  def self.character(); end

  def self.faction(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Games::FinalFantasyXIV
  def self.character(); end

  def self.data_center(); end

  def self.job(); end

  def self.race(); end

  def self.zone(); end
end

class Faker::Games::HalfLife
  def self.character(); end

  def self.enemy(); end

  def self.location(); end
end

class Faker::Games::Heroes
  def self.artifact(); end

  def self.klass(); end

  def self.specialty(); end
end

class Faker::Games::HeroesOfTheStorm
  def self.battleground(); end

  def self.class_name(); end

  def self.hero(); end

  def self.quote(); end
end

class Faker::Games::LeagueOfLegends
  def self.champion(); end

  def self.location(); end

  def self.masteries(); end

  def self.quote(); end

  def self.rank(); end

  def self.summoner_spell(); end
end

class Faker::Games::Minecraft
  def self.achievement(); end

  def self.biome(); end

  def self.block(); end

  def self.enchantment(); end

  def self.game_mode(); end

  def self.item(); end

  def self.mob(); end

  def self.status_effect(); end
end

class Faker::Games::Myst
  def self.age(); end

  def self.character(); end

  def self.creature(); end

  def self.game(); end

  def self.quote(); end
end

class Faker::Games::Overwatch
  def self.hero(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Games::Pokemon
  def self.location(); end

  def self.move(); end
end

class Faker::Games::SonicTheHedgehog
  def self.character(); end

  def self.game(); end

  def self.zone(); end
end

class Faker::Games::StreetFighter
  def self.character(); end

  def self.move(); end

  def self.quote(); end

  def self.stage(); end
end

class Faker::Games::SuperMario
  def self.character(); end

  def self.game(); end

  def self.location(); end
end

class Faker::Games::SuperSmashBros
  def self.fighter(); end

  def self.stage(); end
end

class Faker::Games::Tarkov
  def self.boss(); end

  def self.faction(); end

  def self.fence_quest(); end

  def self.item(); end

  def self.jaeger_quest(); end

  def self.location(); end

  def self.mechanic_quest(); end

  def self.peacekeeper_quest(); end

  def self.prapor_quest(); end

  def self.quest(); end

  def self.ragman_quest(); end

  def self.skier_quest(); end

  def self.therapist_quest(); end

  def self.trader(); end

  def self.weapon(); end
end

class Faker::Games::Touhou
  def self.character(); end

  def self.game(); end

  def self.location(); end

  def self.song(); end

  def self.spell_card(); end
end

class Faker::Games::WarhammerFantasy
  def self.creature(); end

  def self.faction(); end

  def self.hero(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Games::Witcher
  def self.book(); end

  def self.character(); end

  def self.location(); end

  def self.monster(); end

  def self.potion(); end

  def self.quote(); end

  def self.school(); end

  def self.sign(); end

  def self.witcher(); end
end

class Faker::Games::WorldOfWarcraft
  def self.class_name(); end

  def self.hero(); end

  def self.quote(); end

  def self.race(); end
end

class Faker::Games::Zelda
  def self.character(); end

  def self.game(); end

  def self.item(); end

  def self.location(); end
end

class Faker::Gender
  def self.binary_type(); end

  def self.short_binary_type(); end

  def self.type(); end
end

class Faker::GreekPhilosophers
  def self.quote(); end
end

class Faker::HTML
  def self.code(); end

  def self.element(tag: T.unsafe(nil), content: T.unsafe(nil), attributes: T.unsafe(nil)); end

  def self.emphasis(); end

  def self.heading(); end

  def self.link(rel: T.unsafe(nil)); end

  def self.ordered_list(); end

  def self.paragraph(sentence_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_sentences_to_add: T.unsafe(nil), exclude_words: T.unsafe(nil)); end

  def self.random(exclude: T.unsafe(nil)); end

  def self.sandwich(sentences: T.unsafe(nil), repeat: T.unsafe(nil)); end

  def self.script(); end

  def self.table(); end

  def self.unordered_list(); end
end

class Faker::Hacker
  def self.abbreviation(); end

  def self.adjective(); end

  def self.ingverb(); end

  def self.noun(); end

  def self.phrases(); end

  def self.say_something_smart(); end

  def self.verb(); end
end

class Faker::Hipster
  def self.paragraph(sentence_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_sentences_to_add: T.unsafe(nil)); end

  def self.paragraph_by_chars(characters: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.paragraphs(number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.sentence(word_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_words_to_add: T.unsafe(nil), open_compounds_allowed: T.unsafe(nil)); end

  def self.sentences(number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.word(); end

  def self.words(number: T.unsafe(nil), supplemental: T.unsafe(nil), spaces_allowed: T.unsafe(nil)); end
end

class Faker::Hobby
  def self.activity(); end
end

class Faker::House
  def self.furniture(); end

  def self.room(); end
end

class Faker::IdNumber
  BRAZILIAN_ID_FORMAT = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_FROM = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_TO = ::T.let(nil, ::T.untyped)
  CHECKS = ::T.let(nil, ::T.untyped)
  CHILEAN_MODULO = ::T.let(nil, ::T.untyped)
  INVALID_SSN = ::T.let(nil, ::T.untyped)
  ZA_CITIZENSHIP_DIGITS = ::T.let(nil, ::T.untyped)
  ZA_RACE_DIGIT = ::T.let(nil, ::T.untyped)
end

class Faker::IdNumber
  def self.brazilian_citizen_number(formatted: T.unsafe(nil)); end

  def self.brazilian_cpf(formatted: T.unsafe(nil)); end

  def self.brazilian_id(formatted: T.unsafe(nil)); end

  def self.brazilian_rg(formatted: T.unsafe(nil)); end

  def self.chilean_id(); end

  def self.croatian_id(international: T.unsafe(nil)); end

  def self.danish_id_number(formatted: T.unsafe(nil), birthday: T.unsafe(nil), gender: T.unsafe(nil)); end

  def self.french_insee_number(); end

  def self.invalid(); end

  def self.invalid_south_african_id_number(); end

  def self.south_african_id_number(); end

  def self.spanish_citizen_number(); end

  def self.spanish_foreign_citizen_number(); end

  def self.ssn_valid(); end

  def self.valid(); end

  def self.valid_south_african_id_number(); end
end

class Faker::IndustrySegments
  def self.industry(); end

  def self.sector(); end

  def self.sub_sector(); end

  def self.super_sector(); end
end

class Faker::Internet
  PRIVATE_IPV4_ADDRESS_RANGES = ::T.let(nil, ::T.untyped)
end

class Faker::Internet::HTTP
  STATUS_CODES = ::T.let(nil, ::T.untyped)
  STATUS_CODES_GROUPS = ::T.let(nil, ::T.untyped)
end

class Faker::Internet::HTTP
  def self.status_code(group: T.unsafe(nil)); end
end

class Faker::Internet
  def self.base64(length: T.unsafe(nil), padding: T.unsafe(nil), urlsafe: T.unsafe(nil)); end

  def self.bot_user_agent(vendor: T.unsafe(nil)); end

  def self.device_token(); end

  def self.domain_name(subdomain: T.unsafe(nil), domain: T.unsafe(nil)); end

  def self.domain_suffix(safe: T.unsafe(nil)); end

  def self.domain_word(); end

  def self.email(name: T.unsafe(nil), separators: T.unsafe(nil), domain: T.unsafe(nil)); end

  def self.fix_umlauts(string: T.unsafe(nil)); end

  def self.ip_v4_address(); end

  def self.ip_v4_cidr(); end

  def self.ip_v6_address(); end

  def self.ip_v6_cidr(); end

  def self.mac_address(prefix: T.unsafe(nil)); end

  def self.password(min_length: T.unsafe(nil), max_length: T.unsafe(nil), mix_case: T.unsafe(nil), special_characters: T.unsafe(nil)); end

  def self.private_ip_v4_address(); end

  def self.private_net_checker(); end

  def self.private_nets_regex(); end

  def self.public_ip_v4_address(); end

  def self.reserved_net_checker(); end

  def self.reserved_nets_regex(); end

  def self.slug(words: T.unsafe(nil), glue: T.unsafe(nil)); end

  def self.url(host: T.unsafe(nil), path: T.unsafe(nil), scheme: T.unsafe(nil)); end

  def self.user(*args); end

  def self.user_agent(vendor: T.unsafe(nil)); end

  def self.user_name(specifier: T.unsafe(nil), separators: T.unsafe(nil)); end

  def self.username(specifier: T.unsafe(nil), separators: T.unsafe(nil)); end

  def self.uuid(); end
end

class Faker::InvalidStatePassed
  def initialize(msg=T.unsafe(nil)); end
end

class Faker::Invoice
  def self.amount_between(from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.creditor_reference(ref: T.unsafe(nil)); end

  def self.reference(ref: T.unsafe(nil)); end
end

class Faker::JapaneseMedia::Conan
  def self.character(); end

  def self.gadget(); end

  def self.vehicle(); end
end

class Faker::JapaneseMedia::CowboyBebop
  def self.character(); end

  def self.episode(); end

  def self.quote(); end

  def self.song(); end
end

class Faker::JapaneseMedia::Doraemon
  def self.character(); end

  def self.gadget(); end

  def self.location(); end
end

class Faker::JapaneseMedia::DragonBall
  def self.character(); end

  def self.planet(); end

  def self.race(); end
end

class Faker::JapaneseMedia::FullmetalAlchemistBrotherhood
  def self.character(); end

  def self.city(); end

  def self.country(); end
end

class Faker::JapaneseMedia::KamenRider
  def self.collectible_device(*eras); end

  def self.eras=(new_eras); end

  def self.kamen_rider(*eras); end

  def self.series(*eras); end

  def self.transformation_device(*eras); end

  def self.user(*eras); end
end

class Faker::JapaneseMedia::Naruto
  def self.character(); end

  def self.demon(); end

  def self.eye(); end

  def self.village(); end
end

class Faker::JapaneseMedia::OnePiece
  def self.akuma_no_mi(); end

  def self.character(); end

  def self.island(); end

  def self.location(); end

  def self.quote(); end

  def self.sea(); end
end

class Faker::JapaneseMedia::StudioGhibli
  def self.character(); end

  def self.movie(); end

  def self.quote(); end
end

class Faker::JapaneseMedia::SwordArtOnline
  def self.game_name(); end

  def self.item(); end

  def self.location(); end

  def self.real_name(); end
end

class Faker::Job
  def self.field(); end

  def self.key_skill(); end

  def self.position(); end

  def self.title(); end
end

class Faker::Json
  def self.add_depth_to_json(json: T.unsafe(nil), width: T.unsafe(nil), options: T.unsafe(nil)); end

  def self.shallow_json(width: T.unsafe(nil), options: T.unsafe(nil)); end
end

class Faker::Kpop
  def self.boy_bands(); end

  def self.girl_groups(); end

  def self.i_groups(); end

  def self.ii_groups(); end

  def self.iii_groups(); end

  def self.solo(); end
end

class Faker::Locations::Australia
  def self.animal(); end

  def self.location(); end

  def self.state(); end
end

class Faker::Lorem
  def self.character(); end

  def self.characters(number: T.unsafe(nil), min_alpha: T.unsafe(nil), min_numeric: T.unsafe(nil)); end

  def self.multibyte(); end

  def self.paragraph(sentence_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_sentences_to_add: T.unsafe(nil), exclude_words: T.unsafe(nil)); end

  def self.paragraph_by_chars(number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.paragraphs(number: T.unsafe(nil), supplemental: T.unsafe(nil), exclude_words: T.unsafe(nil)); end

  def self.question(word_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_words_to_add: T.unsafe(nil), exclude_words: T.unsafe(nil)); end

  def self.questions(number: T.unsafe(nil), supplemental: T.unsafe(nil), exclude_words: T.unsafe(nil)); end

  def self.sentence(word_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_words_to_add: T.unsafe(nil), exclude_words: T.unsafe(nil)); end

  def self.sentences(number: T.unsafe(nil), supplemental: T.unsafe(nil), exclude_words: T.unsafe(nil)); end

  def self.word(exclude_words: T.unsafe(nil)); end

  def self.words(number: T.unsafe(nil), supplemental: T.unsafe(nil), exclude_words: T.unsafe(nil)); end
end

class Faker::LoremFlickr
  def self.colorized_image(size: T.unsafe(nil), color: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end

  def self.grayscale_image(size: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end

  def self.image(size: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end

  def self.pixelated_image(size: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end
end

class Faker::Markdown
  def self.block_code(); end

  def self.emphasis(); end

  def self.headers(); end

  def self.inline_code(); end

  def self.ordered_list(); end

  def self.random(*args); end

  def self.sandwich(sentences: T.unsafe(nil), repeat: T.unsafe(nil)); end

  def self.table(); end

  def self.unordered_list(); end
end

class Faker::Marketing
  def self.buzzwords(); end
end

class Faker::Measurement
  def self.height(amount: T.unsafe(nil)); end

  def self.length(amount: T.unsafe(nil)); end

  def self.metric_height(amount: T.unsafe(nil)); end

  def self.metric_length(amount: T.unsafe(nil)); end

  def self.metric_volume(amount: T.unsafe(nil)); end

  def self.metric_weight(amount: T.unsafe(nil)); end

  def self.volume(amount: T.unsafe(nil)); end

  def self.weight(amount: T.unsafe(nil)); end
end

class Faker::Military
  def self.air_force_rank(); end

  def self.army_rank(); end

  def self.coast_guard_rank(); end

  def self.dod_paygrade(); end

  def self.marines_rank(); end

  def self.navy_rank(); end

  def self.space_force_rank(); end
end

class Faker::Mountain
  def self.range(); end
end

class Faker::Movie
  def self.quote(); end

  def self.title(); end
end

class Faker::Movies::Avatar
  def self.character(); end

  def self.date(); end

  def self.quote(); end
end

class Faker::Movies::BackToTheFuture
  def self.character(); end

  def self.date(); end

  def self.quote(); end
end

class Faker::Movies::Departed
  def self.actor(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::Movies::Ghostbusters
  def self.actor(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::Movies::Hackers
  def self.character(); end

  def self.handle(); end

  def self.quote(); end
end

class Faker::Movies::HarryPotter
  def self.book(); end

  def self.character(); end

  def self.house(); end

  def self.location(); end

  def self.quote(); end

  def self.spell(); end
end

class Faker::Movies::HitchhikersGuideToTheGalaxy
  def self.character(); end

  def self.location(); end

  def self.marvin_quote(); end

  def self.planet(); end

  def self.quote(); end

  def self.specie(); end

  def self.starship(); end
end

class Faker::Movies::Hobbit
  def self.character(); end

  def self.location(); end

  def self.quote(); end

  def self.thorins_company(); end
end

class Faker::Movies::HowToTrainYourDragon
  def self.character(); end

  def self.dragon(); end

  def self.location(); end
end

class Faker::Movies::Lebowski
  def self.actor(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::Movies::LordOfTheRings
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Movies::PrincessBride
  def self.character(); end

  def self.quote(); end
end

class Faker::Movies::StarWars
  def self.call_number(); end

  def self.call_numbers(); end

  def self.call_sign(); end

  def self.call_squadron(); end

  def self.call_squadrons(); end

  def self.character(); end

  def self.characters(); end

  def self.droid(); end

  def self.droids(); end

  def self.planet(); end

  def self.planets(); end

  def self.quote(character: T.unsafe(nil)); end

  def self.specie(); end

  def self.species(); end

  def self.vehicle(); end

  def self.vehicles(); end

  def self.wookie_sentence(); end

  def self.wookie_words(); end

  def self.wookiee_sentence(); end

  def self.wookiee_words(); end
end

class Faker::Movies::TheRoom
  def self.actor(); end

  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Movies::Tron
  def self.character(); end

  def self.characters(); end

  def self.game(); end

  def self.games(); end

  def self.location(); end

  def self.locations(); end

  def self.program(); end

  def self.programs(); end

  def self.quote(character: T.unsafe(nil)); end

  def self.tagline(); end

  def self.taglines(); end

  def self.user(); end

  def self.users(); end

  def self.vehicle(); end

  def self.vehicles(); end
end

class Faker::Movies::VForVendetta
  def self.character(); end

  def self.quote(); end

  def self.speech(); end
end

class Faker::Music::GratefulDead
  def self.player(); end

  def self.song(); end
end

class Faker::Music::Hiphop
  def self.artist(); end

  def self.groups(); end

  def self.subgenres(); end
end

class Faker::Music::Opera
  def self.beethoven(); end

  def self.bellini(); end

  def self.berg(); end

  def self.berlioz(); end

  def self.bizet(); end

  def self.donizetti(); end

  def self.gluck(); end

  def self.gluck_french(); end

  def self.gluck_italian(); end

  def self.gounod(); end

  def self.mozart(); end

  def self.mozart_german(); end

  def self.mozart_italian(); end

  def self.ravel(); end

  def self.rossini(); end

  def self.saint_saens(); end

  def self.schubert(); end

  def self.schumann(); end

  def self.strauss(); end

  def self.verdi(); end

  def self.wagner(); end

  def self.weber(); end
end

class Faker::Music::PearlJam
  def self.album(); end

  def self.musician(); end

  def self.song(); end
end

class Faker::Music::Phish
  def self.album(); end

  def self.musician(); end

  def self.song(); end
end

class Faker::Music::Prince
  def self.album(); end

  def self.band(); end

  def self.lyric(); end

  def self.song(); end
end

class Faker::Music::RockBand
  def self.song(); end
end

class Faker::Music::Rush
  def self.album(); end

  def self.player(); end
end

class Faker::Music::SmashingPumpkins
  def self.album(); end

  def self.lyric(); end

  def self.musician(); end

  def self.song(); end
end

class Faker::Music::UmphreysMcgee
  def self.song(); end
end

class Faker::Music
  def self.album(); end

  def self.band(); end

  def self.chord(); end

  def self.chord_types(); end

  def self.genre(); end

  def self.instrument(); end

  def self.key(); end

  def self.key_types(); end

  def self.key_variants(); end

  def self.keys(); end

  def self.mambo_no_5(); end
end

class Faker::Name
  def self.female_first_name(); end

  def self.feminine_name(); end

  def self.first_name(); end

  def self.first_name_men(); end

  def self.first_name_neutral(); end

  def self.first_name_women(); end

  def self.gender_neutral_first_name(); end

  def self.initials(number: T.unsafe(nil)); end

  def self.last_name(); end

  def self.male_first_name(); end

  def self.masculine_name(); end

  def self.middle_name(); end

  def self.name_with_middle(); end

  def self.neutral_first_name(); end

  def self.prefix(); end

  def self.suffix(); end
end

class Faker::Nation
  def self.capital_city(); end

  def self.flag(); end

  def self.language(); end

  def self.national_sport(); end

  def self.nationality(); end
end

class Faker::NationalHealthService
  def self.british_number(); end
end

class Faker::NatoPhoneticAlphabet
  def self.code_word(); end
end

class Faker::Number
  def self.between(from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.binary(digits: T.unsafe(nil)); end

  def self.decimal(l_digits: T.unsafe(nil), r_digits: T.unsafe(nil)); end

  def self.decimal_part(digits: T.unsafe(nil)); end

  def self.digit(); end

  def self.hexadecimal(digits: T.unsafe(nil)); end

  def self.leading_zero_number(digits: T.unsafe(nil)); end

  def self.negative(from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.non_zero_digit(); end

  def self.normal(mean: T.unsafe(nil), standard_deviation: T.unsafe(nil)); end

  def self.number(digits: T.unsafe(nil)); end

  def self.positive(from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.within(range: T.unsafe(nil)); end
end

class Faker::Omniauth
  def email(); end

  def first_name(); end

  def initialize(name: T.unsafe(nil), email: T.unsafe(nil)); end

  def last_name(); end

  def name(); end
end

class Faker::Omniauth
  def self.apple(name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.auth0(name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.facebook(name: T.unsafe(nil), email: T.unsafe(nil), username: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.github(name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.google(name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.linkedin(name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.twitter(name: T.unsafe(nil), nickname: T.unsafe(nil), uid: T.unsafe(nil)); end
end

class Faker::PhoneNumber
  def self.area_code(); end

  def self.cell_phone(); end

  def self.cell_phone_in_e164(); end

  def self.cell_phone_with_country_code(); end

  def self.country_code(); end

  def self.exchange_code(); end

  def self.extension(length: T.unsafe(nil)); end

  def self.phone_number(); end

  def self.phone_number_with_country_code(); end

  def self.subscriber_number(length: T.unsafe(nil)); end
end

class Faker::Placeholdit
  def self.image(size: T.unsafe(nil), format: T.unsafe(nil), background_color: T.unsafe(nil), text_color: T.unsafe(nil), text: T.unsafe(nil)); end
end

class Faker::ProgrammingLanguage
  def self.creator(); end
end

class Faker::Quote
  def self.famous_last_words(); end

  def self.fortune_cookie(); end

  def self.jack_handey(); end

  def self.matz(); end

  def self.mitch_hedberg(); end

  def self.most_interesting_man_in_the_world(); end

  def self.robin(); end

  def self.singular_siegler(); end

  def self.yoda(); end
end

class Faker::Quotes::Chiquito
  def self.expression(); end

  def self.joke(); end

  def self.sentence(); end

  def self.term(); end
end

class Faker::Quotes::Rajnikanth
  def self.joke(); end
end

class Faker::Quotes::Shakespeare
  def self.as_you_like_it(); end

  def self.as_you_like_it_quote(); end

  def self.hamlet(); end

  def self.hamlet_quote(); end

  def self.king_richard_iii(); end

  def self.king_richard_iii_quote(); end

  def self.romeo_and_juliet(); end

  def self.romeo_and_juliet_quote(); end
end

class Faker::Relationship
  def self.familial(connection: T.unsafe(nil)); end

  def self.in_law(); end

  def self.parent(); end

  def self.sibling(); end

  def self.spouse(); end
end

class Faker::Religion::Bible
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Restaurant
  def self.description(); end

  def self.review(); end

  def self.type(); end
end

class Faker::Science
  def self.element(); end

  def self.element_state(); end

  def self.element_subcategory(); end

  def self.element_symbol(); end

  def self.modifier(); end

  def self.science(*branches); end

  def self.scientist(); end

  def self.tool(simple: T.unsafe(nil)); end
end

class Faker::SlackEmoji
  def self.activity(); end

  def self.celebration(); end

  def self.custom(); end

  def self.emoji(); end

  def self.food_and_drink(); end

  def self.nature(); end

  def self.objects_and_symbols(); end

  def self.people(); end

  def self.travel_and_places(); end
end

class Faker::Source
  def self.hello_world(lang: T.unsafe(nil)); end

  def self.print(str: T.unsafe(nil), lang: T.unsafe(nil)); end

  def self.print_1_to_10(lang: T.unsafe(nil)); end
end

class Faker::SouthAfrica
  def self.cell_phone(); end

  def self.close_corporation_registration_number(); end

  def self.id_number(); end

  def self.invalid_id_number(); end

  def self.listed_company_registration_number(); end

  def self.phone_number(); end

  def self.pty_ltd_registration_number(); end

  def self.trust_registration_number(); end

  def self.valid_id_number(); end

  def self.vat_number(); end
end

class Faker::Space
  def self.agency(); end

  def self.agency_abv(); end

  def self.company(); end

  def self.constellation(); end

  def self.distance_measurement(); end

  def self.galaxy(); end

  def self.launch_vehicle(); end

  def self.meteorite(); end

  def self.moon(); end

  def self.nasa_space_craft(); end

  def self.nebula(); end

  def self.planet(); end

  def self.star(); end

  def self.star_cluster(); end
end

class Faker::Sport
  def self.ancient_olympics_sport(); end

  def self.sport(include_ancient: T.unsafe(nil), include_unusual: T.unsafe(nil)); end

  def self.summer_olympics_sport(); end

  def self.summer_paralympics_sport(); end

  def self.unusual_sport(); end

  def self.winter_olympics_sport(); end

  def self.winter_paralympics_sport(); end
end

class Faker::Sports::Basketball
  def self.coach(); end

  def self.player(); end

  def self.position(); end

  def self.team(); end
end

class Faker::Sports::Chess
  def self.federation(); end

  def self.opening(); end

  def self.player(); end

  def self.rating(from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.title(); end

  def self.tournament(); end
end

class Faker::Sports::Football
  def self.coach(); end

  def self.competition(); end

  def self.player(); end

  def self.position(); end

  def self.team(); end
end

class Faker::Sports::Mountaineering
  def self.mountaineer(); end
end

class Faker::Sports::Volleyball
  def self.coach(); end

  def self.formation(); end

  def self.player(); end

  def self.position(); end

  def self.team(); end
end

class Faker::String
  def self.random(length: T.unsafe(nil)); end
end

class Faker::Stripe
  def self.ccv(card_type: T.unsafe(nil)); end

  def self.invalid_card(card_error: T.unsafe(nil)); end

  def self.month(); end

  def self.valid_card(card_type: T.unsafe(nil)); end

  def self.valid_token(card_type: T.unsafe(nil)); end

  def self.year(); end
end

class Faker::Subscription
  def self.payment_method(); end

  def self.payment_term(); end

  def self.plan(); end

  def self.status(); end

  def self.subscription_term(); end
end

class Faker::Superhero
  def self.descriptor(); end

  def self.power(); end

  def self.prefix(); end

  def self.suffix(); end
end

class Faker::Tea
  def self.type(); end

  def self.variety(type: T.unsafe(nil)); end
end

class Faker::Team
  def self.creature(); end

  def self.mascot(); end

  def self.sport(); end

  def self.state(); end
end

class Faker::Theater
  def self.adult_musical(); end

  def self.kids_musical(); end

  def self.play(); end
end

class Faker::Time
  TIME_RANGES = ::T.let(nil, ::T.untyped)
end

class Faker::Time
  def self.backward(days: T.unsafe(nil), period: T.unsafe(nil), format: T.unsafe(nil)); end

  def self.between(from:, to:, format: T.unsafe(nil)); end

  def self.between_dates(from:, to:, period: T.unsafe(nil), format: T.unsafe(nil)); end

  def self.forward(days: T.unsafe(nil), period: T.unsafe(nil), format: T.unsafe(nil)); end
end

class Faker::Travel::Airport
  def self.iata(size:, region:); end

  def self.name(size:, region:); end
end

class Faker::Travel::TrainStation
  def self.name(region: T.unsafe(nil), type: T.unsafe(nil)); end
end

class Faker::TvShows::AquaTeenHungerForce
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::Archer
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::BigBangTheory
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::BojackHorseman
  def self.character(); end

  def self.quote(); end

  def self.tongue_twister(); end
end

class Faker::TvShows::BreakingBad
  def self.character(); end

  def self.episode(); end
end

class Faker::TvShows::BrooklynNineNine
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::Buffy
  def self.actor(); end

  def self.big_bad(); end

  def self.celebrity(); end

  def self.character(); end

  def self.episode(); end

  def self.quote(); end
end

class Faker::TvShows::Community
  def self.characters(); end

  def self.quotes(); end
end

class Faker::TvShows::DrWho
  def self.actor(); end

  def self.catch_phrase(); end

  def self.character(); end

  def self.quote(); end

  def self.specie(); end

  def self.the_doctor(); end

  def self.villain(); end

  def self.villian(); end
end

class Faker::TvShows::DumbAndDumber
  def self.actor(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::FamilyGuy
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::FinalSpace
  def self.character(); end

  def self.quote(); end

  def self.vehicle(); end
end

class Faker::TvShows::Friends
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::Futurama
  def self.character(); end

  def self.hermes_catchphrase(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::GameOfThrones
  def self.character(); end

  def self.city(); end

  def self.dragon(); end

  def self.house(); end

  def self.quote(); end
end

class Faker::TvShows::HeyArnold
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::HowIMetYourMother
  def self.catch_phrase(); end

  def self.character(); end

  def self.high_five(); end

  def self.quote(); end
end

class Faker::TvShows::MichaelScott
  def self.quote(); end
end

class Faker::TvShows::NewGirl
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::ParksAndRec
  def self.character(); end

  def self.city(); end
end

class Faker::TvShows::RickAndMorty
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::RuPaul
  def self.queen(); end

  def self.quote(); end
end

class Faker::TvShows::Seinfeld
  def self.business(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::SiliconValley
  def self.app(); end

  def self.character(); end

  def self.company(); end

  def self.email(); end

  def self.invention(); end

  def self.motto(); end

  def self.quote(); end

  def self.url(); end
end

class Faker::TvShows::Simpsons
  def self.character(); end

  def self.episode_title(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::SouthPark
  def self.character(); end

  def self.episode_name(); end

  def self.quote(); end
end

class Faker::TvShows::Spongebob
  def self.character(); end

  def self.episode(); end

  def self.quote(); end
end

class Faker::TvShows::StarTrek
  def self.character(); end

  def self.location(); end

  def self.specie(); end

  def self.villain(); end
end

class Faker::TvShows::Stargate
  def self.character(); end

  def self.planet(); end

  def self.quote(); end
end

class Faker::TvShows::StrangerThings
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::Suits
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::Supernatural
  def self.character(); end

  def self.creature(); end

  def self.weapon(); end
end

class Faker::TvShows::TheExpanse
  def self.character(); end

  def self.location(); end

  def self.quote(); end

  def self.ship(); end
end

class Faker::TvShows::TheFreshPrinceOfBelAir
  def self.actor(); end

  def self.celebrity(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::TheITCrowd
  def self.actor(); end

  def self.character(); end

  def self.email(); end

  def self.quote(); end
end

class Faker::TvShows::TheOffice
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::TheThickOfIt
  def self.character(); end

  def self.department(); end

  def self.position(); end
end

class Faker::TvShows::TwinPeaks
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::VentureBros
  def self.character(); end

  def self.organization(); end

  def self.quote(); end

  def self.vehicle(); end
end

class Faker::Twitter
  def self.screen_name(); end

  def self.status(include_user: T.unsafe(nil), include_photo: T.unsafe(nil)); end

  def self.user(include_status: T.unsafe(nil), include_email: T.unsafe(nil)); end
end

class Faker::Types
  CHARACTERS = ::T.let(nil, ::T.untyped)
  COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  SIMPLE_TYPES = ::T.let(nil, ::T.untyped)
end

class Faker::Types
  def self.character(); end

  def self.complex_rb_hash(number: T.unsafe(nil)); end

  def self.random_complex_type(); end

  def self.random_type(); end

  def self.rb_array(len: T.unsafe(nil), type: T.unsafe(nil)); end

  def self.rb_hash(number: T.unsafe(nil), type: T.unsafe(nil)); end

  def self.rb_integer(from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.rb_string(words: T.unsafe(nil)); end
end

class Faker::UniqueGenerator
  def clear(); end

  def exclude(name, arguments, values); end

  def initialize(generator, max_retries); end

  def method_missing(name, *arguments, **arg); end

  def previous_results(); end
end

class Faker::UniqueGenerator
  def self.clear(); end

  def self.marked_unique(); end
end

class Faker::University
  def self.greek_alphabet(); end

  def self.greek_organization(); end

  def self.prefix(); end

  def self.suffix(); end
end

class Faker::Vehicle
  MILEAGE_MAX = ::T.let(nil, ::T.untyped)
  MILEAGE_MIN = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_CHARS = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_WEIGHTS = ::T.let(nil, ::T.untyped)
  VIN_KEYSPACE = ::T.let(nil, ::T.untyped)
  VIN_TRANSLITERATION = ::T.let(nil, ::T.untyped)
  VIN_WEIGHT = ::T.let(nil, ::T.untyped)
end

class Faker::Vehicle
  def self.car_options(); end

  def self.car_type(); end

  def self.color(); end

  def self.door_count(); end

  def self.doors(); end

  def self.drive_type(); end

  def self.engine(); end

  def self.engine_size(); end

  def self.fuel_type(); end

  def self.kilometrage(min: T.unsafe(nil), max: T.unsafe(nil)); end

  def self.license_plate(state_abbreviation: T.unsafe(nil)); end

  def self.make(); end

  def self.make_and_model(); end

  def self.manufacture(); end

  def self.manufacturer(); end

  def self.mileage(min: T.unsafe(nil), max: T.unsafe(nil)); end

  def self.model(make_of_model: T.unsafe(nil)); end

  def self.singapore_license_plate(); end

  def self.standard_specs(); end

  def self.style(); end

  def self.transmission(); end

  def self.version(); end

  def self.vin(); end

  def self.year(); end
end

class Faker::Verb
  def self.base(); end

  def self.ing_form(); end

  def self.past(); end

  def self.past_participle(); end

  def self.simple_present(); end
end

class Faker::VulnerabilityIdentifier
  def self.cve(year: T.unsafe(nil)); end
end

class Faker::WorldCup
  def self.city(); end

  def self.group(group: T.unsafe(nil)); end

  def self.roster(country: T.unsafe(nil), type: T.unsafe(nil)); end

  def self.stadium(); end

  def self.team(); end
end

class Fiber
  def active_support_execution_state(); end

  def active_support_execution_state=(active_support_execution_state); end

  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def storage(); end

  def storage=(storage); end

  def transfer(*arg); end
end

class Fiber
  def self.blocking(); end

  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

module Fiddle
  ALIGN_INT16_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT32_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT64_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT8_T = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  Qfalse = ::T.let(nil, ::T.untyped)
  Qnil = ::T.let(nil, ::T.untyped)
  Qtrue = ::T.let(nil, ::T.untyped)
  Qundef = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  SIZEOF_CONST_STRING = ::T.let(nil, ::T.untyped)
  SIZEOF_INT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UCHAR = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG_LONG = ::T.let(nil, ::T.untyped)
  SIZEOF_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_CONST_STRING = ::T.let(nil, ::T.untyped)
  TYPE_INT16_T = ::T.let(nil, ::T.untyped)
  TYPE_INT32_T = ::T.let(nil, ::T.untyped)
  TYPE_INT64_T = ::T.let(nil, ::T.untyped)
  TYPE_INT8_T = ::T.let(nil, ::T.untyped)
  TYPE_UCHAR = ::T.let(nil, ::T.untyped)
  TYPE_UINT = ::T.let(nil, ::T.untyped)
  TYPE_UINT16_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT32_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT64_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT8_T = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_ULONG_LONG = ::T.let(nil, ::T.untyped)
  TYPE_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_VARIADIC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Fiddle::CStruct
  include ::Enumerable
  def each(&blk); end

  def each_pair(); end

  def replace(another); end

  def to_h(); end
end

class Fiddle::CStruct
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

module Fiddle::CStructBuilder
end

module Fiddle::CStructBuilder
  def self.create(klass, types, members); end
end

class Fiddle::CStructEntity
  include ::Fiddle::PackInfo
  include ::Fiddle::ValueUtil
  def [](*args); end

  def []=(*args); end

  def assign_names(members); end

  def initialize(addr, types, func=T.unsafe(nil)); end

  def set_ctypes(types); end

  def to_s(); end
end

class Fiddle::CStructEntity
  def self.alignment(types); end

  def self.malloc(types, func=T.unsafe(nil), size=T.unsafe(nil), &block); end

  def self.size(types); end
end

class Fiddle::CUnion
end

class Fiddle::CUnion
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

class Fiddle::CUnionEntity
end

class Fiddle::CUnionEntity
end

class Fiddle::ClearedReferenceError
end

class Fiddle::ClearedReferenceError
end

class Fiddle::Closure
  def free(); end

  def freed?(); end
end

class Fiddle::Closure
  def self.create(*args); end
end

class Fiddle::CompositeHandler
  def [](symbol); end

  def handlers(); end

  def initialize(handlers); end

  def sym(symbol); end
end

class Fiddle::CompositeHandler
end

class Fiddle::Error
end

class Fiddle::Error
end

class Fiddle::Function
  def need_gvl?(); end

  def to_proc(); end
end

class Fiddle::Handle
  def file_name(); end

  def sym_defined?(arg); end

  def to_ptr(); end
end

class Fiddle::Handle
  def self.sym_defined?(arg); end
end

module Fiddle::Importer
  include ::Fiddle
  include ::Fiddle::CParser
end

module Fiddle::Importer
  extend ::Fiddle::Importer
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Fiddle::MemoryView
  def [](*arg); end

  def byte_size(); end

  def format(); end

  def initialize(arg); end

  def item_size(); end

  def ndim(); end

  def obj(); end

  def readonly?(); end

  def release(); end

  def shape(); end

  def strides(); end

  def sub_offsets(); end
end

class Fiddle::MemoryView
  def self.export(arg); end
end

module Fiddle::PackInfo
  ALIGN_MAP = ::T.let(nil, ::T.untyped)
  PACK_MAP = ::T.let(nil, ::T.untyped)
  SIZE_MAP = ::T.let(nil, ::T.untyped)
end

module Fiddle::PackInfo
  def self.align(addr, align); end
end

class Fiddle::Packer
  include ::Fiddle::PackInfo
  def initialize(types); end

  def pack(ary); end

  def size(); end

  def unpack(ary); end
end

class Fiddle::Packer
  def self.[](*types); end
end

class Fiddle::Pinned
  def clear(); end

  def cleared?(); end

  def initialize(arg); end

  def ref(); end
end

class Fiddle::Pinned
end

class Fiddle::Pointer
  def call_free(); end

  def freed?(); end
end

class Fiddle::StructArray
  include ::Fiddle::ValueUtil
  def []=(index, value); end

  def initialize(ptr, type, initial_values); end

  def to_ptr(); end
end

class Fiddle::StructArray
end

module Fiddle::Types
  CHAR = ::T.let(nil, ::T.untyped)
  CONST_STRING = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16_T = ::T.let(nil, ::T.untyped)
  INT32_T = ::T.let(nil, ::T.untyped)
  INT64_T = ::T.let(nil, ::T.untyped)
  INT8_T = ::T.let(nil, ::T.untyped)
  INTPTR_T = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  PTRDIFF_T = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SIZE_T = ::T.let(nil, ::T.untyped)
  SSIZE_T = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16_T = ::T.let(nil, ::T.untyped)
  UINT32_T = ::T.let(nil, ::T.untyped)
  UINT64_T = ::T.let(nil, ::T.untyped)
  UINT8_T = ::T.let(nil, ::T.untyped)
  UINTPTR_T = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARIADIC = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
  VOIDP = ::T.let(nil, ::T.untyped)
end

module Fiddle::Types
end

module Fiddle::ValueUtil
  def signed_value(val, ty); end

  def unsigned_value(val, ty); end

  def wrap_arg(arg, ty, funcs=T.unsafe(nil), &block); end

  def wrap_args(args, tys, funcs, &block); end
end

module Fiddle::ValueUtil
end

class File
  def self.absolute_path?(arg); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.probe_stat_in(dir); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

class Float
  include ::ActiveSupport::NumericWithFormat
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end

  def self.using_rvargc?(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def base_dir_priority(gem_path); end

  def default_gem_priority(); end

  def full_name_with_location(); end

  def plugins(); end
end

module Gem::BetterPermissionError
  def data(); end
end

module Gem::BetterPermissionError
end

module Gem::BundlerVersionFinder
  def self.prioritize!(specs); end
end

module Gem::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Gem::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
  def self.dump_with_rubygems_yaml(content); end

  def self.load_with_rubygems_config_hash(yaml); end
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  DEPRECATED_EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_EXCEPTION_REGEXP = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_REGEXP = ::T.let(nil, ::T.untyped)
  LICENSE_REF = ::T.let(nil, ::T.untyped)
  VALID_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  def self.deprecated_exception_id?(license); end

  def self.deprecated_license_id?(license); end
end

module Gem::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(vertices); end
end

class Gem::Molinillo::CircularDependencyError
end

module Gem::Molinillo::Delegates
end

module Gem::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end

  def unused_unwind_options(); end
end

module Gem::Molinillo::Delegates::ResolutionState
end

module Gem::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::Delegates::SpecificationProvider
end

module Gem::Molinillo::Delegates
end

class Gem::Molinillo::DependencyGraph
  include ::Enumerable
  include ::Gem::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(arg); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Molinillo::DependencyGraph::AddVertex
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Molinillo::DependencyGraph::Edge
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Molinillo::DependencyGraph::SetPayload
end

class Gem::Molinillo::DependencyGraph::Tag
  def initialize(tag); end

  def tag(); end
end

class Gem::Molinillo::DependencyGraph::Tag
end

class Gem::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Molinillo::DependencyGraph::Vertex
end

class Gem::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Molinillo::DependencyState
end

class Gem::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Molinillo::NoSuchDependencyError
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end

  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Molinillo::ResolutionState
  def self.[](*arg); end

  def self.empty(); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Molinillo::Resolver::Resolution
  include ::Gem::Molinillo::Delegates::ResolutionState
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility_set(); end

  def possibility_set=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution
end

class Gem::Molinillo::Resolver
end

class Gem::Molinillo::ResolverError
end

class Gem::Molinillo::ResolverError
end

module Gem::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::SpecificationProvider
end

module Gem::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Molinillo::UI
end

class Gem::Molinillo::VersionConflict
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def conflicts(); end

  def initialize(conflicts, specification_provider); end

  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Molinillo::VersionConflict
end

module Gem::Molinillo
end

class Gem::NameTuple
  def lock_name(); end
end

module Gem::Net
end

class Gem::Net::BufferedIO
  def <<(*strs); end

  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def eof?(); end

  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  def io(); end

  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  def read_all(dest=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readline(); end

  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  def write(*strs); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end

  def writeline(str); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class Gem::Net::BufferedIO
end

class Gem::Net::HTTP
  def active?(); end

  def address(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def ca_path(); end

  def ca_path=(ca_path); end

  def cert(); end

  def cert=(cert); end

  def cert_store(); end

  def cert_store=(cert_store); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def close_on_empty_response(); end

  def close_on_empty_response=(close_on_empty_response); end

  def continue_timeout(); end

  def continue_timeout=(sec); end

  def copy(path, initheader=T.unsafe(nil)); end

  def delete(path, initheader=T.unsafe(nil)); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(); end

  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def get2(path, initheader=T.unsafe(nil), &block); end

  def head(path, initheader=T.unsafe(nil)); end

  def head2(path, initheader=T.unsafe(nil), &block); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(address, port=T.unsafe(nil)); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def key(); end

  def key=(key); end

  def local_host(); end

  def local_host=(local_host); end

  def local_port(); end

  def local_port=(local_port); end

  def lock(path, body, initheader=T.unsafe(nil)); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def move(path, initheader=T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def options(path, initheader=T.unsafe(nil)); end

  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def peer_cert(); end

  def port(); end

  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def post2(path, data, initheader=T.unsafe(nil), &block); end

  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def proppatch(path, body, initheader=T.unsafe(nil)); end

  def proxy?(); end

  def proxy_address(); end

  def proxy_address=(proxy_address); end

  def proxy_from_env=(proxy_from_env); end

  def proxy_from_env?(); end

  def proxy_pass(); end

  def proxy_pass=(proxy_pass); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_uri(); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def proxyaddr(); end

  def proxyport(); end

  def put(path, data, initheader=T.unsafe(nil)); end

  def put2(path, data, initheader=T.unsafe(nil), &block); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def request(req, body=T.unsafe(nil), &block); end

  def request_get(path, initheader=T.unsafe(nil), &block); end

  def request_head(path, initheader=T.unsafe(nil), &block); end

  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  def set_debug_output(output); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(); end

  def started?(); end

  def trace(path, initheader=T.unsafe(nil)); end

  def unlock(path, body, initheader=T.unsafe(nil)); end

  def use_ssl=(flag); end

  def use_ssl?(); end

  def verify_callback(); end

  def verify_callback=(verify_callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(sec); end
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
end

class Gem::Net::HTTP::Delete
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Delete
end

class Gem::Net::HTTP::Get
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Get
end

class Gem::Net::HTTP::Head
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Head
end

class Gem::Net::HTTP::Lock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Lock
end

class Gem::Net::HTTP::Mkcol
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Mkcol
end

class Gem::Net::HTTP::Move
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Move
end

class Gem::Net::HTTP::Options
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Options
end

class Gem::Net::HTTP::Patch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Patch
end

class Gem::Net::HTTP::Persistent
  def ca_file(); end

  def ca_file=(file); end

  def ca_path(); end

  def ca_path=(path); end

  def cert(); end

  def cert=(certificate); end

  def cert_store(); end

  def cert_store=(store); end

  def certificate(); end

  def certificate=(certificate); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def connection_for(uri); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def escape(str); end

  def expired?(connection); end

  def finish(connection); end

  def generation(); end

  def headers(); end

  def http_version(uri); end

  def http_versions(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(name: T.unsafe(nil), proxy: T.unsafe(nil), pool_size: T.unsafe(nil)); end

  def keep_alive(); end

  def keep_alive=(keep_alive); end

  def key(); end

  def key=(key); end

  def max_requests(); end

  def max_requests=(max_requests); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def name(); end

  def no_proxy(); end

  def normalize_uri(uri); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def override_headers(); end

  def pool(); end

  def private_key(); end

  def private_key=(key); end

  def proxy=(proxy); end

  def proxy_bypass?(host, port); end

  def proxy_from_env(); end

  def proxy_uri(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def reconnect(); end

  def reconnect_ssl(); end

  def request(uri, req=T.unsafe(nil), &block); end

  def request_setup(req_or_uri); end

  def reset(connection); end

  def reuse_ssl_sessions(); end

  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  def shutdown(); end

  def socket_options(); end

  def ssl(connection); end

  def ssl_generation(); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(http); end

  def timeout_key(); end

  def unescape(str); end

  def verify_callback(); end

  def verify_callback=(callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Persistent::Connection
  def close(); end

  def finish(); end

  def http(); end

  def http=(http); end

  def initialize(http_class, http_args, ssl_generation); end

  def last_use(); end

  def last_use=(last_use); end

  def requests(); end

  def requests=(requests); end

  def reset(); end

  def ressl(ssl_generation); end

  def ssl_generation(); end

  def ssl_generation=(ssl_generation); end
end

class Gem::Net::HTTP::Persistent::Connection
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Pool
  def checkin(net_http_args); end

  def checkout(net_http_args); end

  def key(); end

  def shutdown(); end
end

class Gem::Net::HTTP::Persistent::Pool
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
  def self.hash_of_arrays(); end
end

class Gem::Net::HTTP::Persistent
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Gem::Net::HTTP::Post
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Post
end

class Gem::Net::HTTP::Propfind
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Propfind
end

class Gem::Net::HTTP::Proppatch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Proppatch
end

module Gem::Net::HTTP::ProxyDelta
end

module Gem::Net::HTTP::ProxyDelta
end

Gem::Net::HTTP::ProxyMod = Gem::Net::HTTP::ProxyDelta

class Gem::Net::HTTP::Put
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Put
end

class Gem::Net::HTTP::Trace
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Trace
end

class Gem::Net::HTTP::Unlock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Unlock
end

class Gem::Net::HTTP
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  def self.default_port(); end

  def self.get(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_print(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_response(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil), &block); end

  def self.http_default_port(); end

  def self.https_default_port(); end

  def self.is_version_1_1?(); end

  def self.is_version_1_2?(); end

  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_no_proxy=T.unsafe(nil)); end

  def self.newobj(*arg, **arg1); end

  def self.post(url, data, header=T.unsafe(nil)); end

  def self.post_form(url, params); end

  def self.proxy_address(); end

  def self.proxy_class?(); end

  def self.proxy_pass(); end

  def self.proxy_port(); end

  def self.proxy_user(); end

  def self.socket_type(); end

  def self.start(address, *arg, &block); end

  def self.version_1_1?(); end

  def self.version_1_2(); end

  def self.version_1_2?(); end
end

class Gem::Net::HTTPAccepted
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAccepted
end

class Gem::Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAlreadyReported
end

class Gem::Net::HTTPBadGateway
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadGateway
end

class Gem::Net::HTTPBadRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadRequest
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPClientError::EXCEPTION_TYPE = Gem::Net::HTTPClientException

class Gem::Net::HTTPClientError
end

Gem::Net::HTTPClientErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPClientException
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPClientException
end

class Gem::Net::HTTPConflict
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPConflict
end

class Gem::Net::HTTPContinue
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPContinue
end

class Gem::Net::HTTPCreated
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPCreated
end

class Gem::Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPEarlyHints
end

class Gem::Net::HTTPError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPError
end

module Gem::Net::HTTPExceptions
  def data(); end

  def initialize(msg, res); end

  def response(); end
end

module Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPExpectationFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPExpectationFailed
end

class Gem::Net::HTTPFailedDependency
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFailedDependency
end

class Gem::Net::HTTPFatalError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPFatalError
end

Gem::Net::HTTPFatalErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPForbidden
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPForbidden
end

class Gem::Net::HTTPFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFound
end

Gem::Net::HTTPGatewayTimeOut = Gem::Net::HTTPGatewayTimeout

class Gem::Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGatewayTimeout
end

class Gem::Net::HTTPGenericRequest
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(str); end

  def body_exist?(); end

  def body_stream(); end

  def body_stream=(input); end

  def decode_content(); end

  def exec(sock, ver, path); end

  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  def method(); end

  def path(); end

  def request_body_permitted?(); end

  def response_body_permitted?(); end

  def set_body_internal(str); end

  def update_uri(addr, port, ssl); end

  def uri(); end
end

class Gem::Net::HTTPGenericRequest::Chunker
  def finish(); end

  def initialize(sock); end

  def write(buf); end
end

class Gem::Net::HTTPGenericRequest::Chunker
end

class Gem::Net::HTTPGenericRequest
end

class Gem::Net::HTTPGone
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGone
end

module Gem::Net::HTTPHeader
  def [](key); end

  def []=(key, val); end

  def add_field(key, val); end

  def basic_auth(account, password); end

  def canonical_each(); end

  def chunked?(); end

  def connection_close?(); end

  def connection_keep_alive?(); end

  def content_length(); end

  def content_length=(len); end

  def content_range(); end

  def content_type(); end

  def content_type=(type, params=T.unsafe(nil)); end

  def delete(key); end

  def each(&blk); end

  def each_capitalized(); end

  def each_capitalized_name(); end

  def each_header(); end

  def each_key(&block); end

  def each_name(&block); end

  def each_value(); end

  def fetch(key, *args, &block); end

  def form_data=(params, sep=T.unsafe(nil)); end

  def get_fields(key); end

  def initialize_http_header(initheader); end

  def key?(key); end

  def length(); end

  def main_type(); end

  def proxy_basic_auth(account, password); end

  def range(); end

  def range=(r, e=T.unsafe(nil)); end

  def range_length(); end

  def set_content_type(type, params=T.unsafe(nil)); end

  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  def set_form_data(params, sep=T.unsafe(nil)); end

  def set_range(r, e=T.unsafe(nil)); end

  def size(); end

  def sub_type(); end

  def to_hash(); end

  def type_params(); end
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

module Gem::Net::HTTPHeader
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPIMUsed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPIMUsed
end

class Gem::Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPInformation::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPInformation
end

Gem::Net::HTTPInformationCode = Gem::Net::HTTPInformation

class Gem::Net::HTTPInsufficientStorage
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInsufficientStorage
end

class Gem::Net::HTTPInternalServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInternalServerError
end

class Gem::Net::HTTPLengthRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLengthRequired
end

class Gem::Net::HTTPLocked
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLocked
end

class Gem::Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLoopDetected
end

class Gem::Net::HTTPMethodNotAllowed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMethodNotAllowed
end

class Gem::Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMisdirectedRequest
end

class Gem::Net::HTTPMovedPermanently
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMovedPermanently
end

Gem::Net::HTTPMovedTemporarily = Gem::Net::HTTPFound

class Gem::Net::HTTPMultiStatus
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultiStatus
end

Gem::Net::HTTPMultipleChoice = Gem::Net::HTTPMultipleChoices

class Gem::Net::HTTPMultipleChoices
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultipleChoices
end

class Gem::Net::HTTPNetworkAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNetworkAuthenticationRequired
end

class Gem::Net::HTTPNoContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNoContent
end

class Gem::Net::HTTPNonAuthoritativeInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNonAuthoritativeInformation
end

class Gem::Net::HTTPNotAcceptable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotAcceptable
end

class Gem::Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotExtended
end

class Gem::Net::HTTPNotFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotFound
end

class Gem::Net::HTTPNotImplemented
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotImplemented
end

class Gem::Net::HTTPNotModified
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotModified
end

class Gem::Net::HTTPOK
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPOK
end

class Gem::Net::HTTPPartialContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPartialContent
end

class Gem::Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPayloadTooLarge
end

class Gem::Net::HTTPPaymentRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPaymentRequired
end

class Gem::Net::HTTPPermanentRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPermanentRedirect
end

class Gem::Net::HTTPPreconditionFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionFailed
end

class Gem::Net::HTTPPreconditionRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionRequired
end

class Gem::Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProcessing
end

class Gem::Net::HTTPProxyAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProxyAuthenticationRequired
end

class Gem::Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRangeNotSatisfiable
end

class Gem::Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPRedirection::EXCEPTION_TYPE = Gem::Net::HTTPRetriableError

class Gem::Net::HTTPRedirection
end

Gem::Net::HTTPRedirectionCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRequest
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Gem::Net::HTTPRequest
end

Gem::Net::HTTPRequestEntityTooLarge = Gem::Net::HTTPPayloadTooLarge

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
end

Gem::Net::HTTPRequestTimeOut = Gem::Net::HTTPRequestTimeout

class Gem::Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestTimeout
end

Gem::Net::HTTPRequestURITooLarge = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestURITooLong = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestedRangeNotSatisfiable = Gem::Net::HTTPRangeNotSatisfiable

class Gem::Net::HTTPResetContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResetContent
end

Gem::Net::HTTPResponceReceiver = Gem::Net::HTTPResponse

class Gem::Net::HTTPResponse
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(value); end

  def body_encoding(); end

  def body_encoding=(value); end

  def code(); end

  def code_type(); end

  def decode_content(); end

  def decode_content=(decode_content); end

  def entity(); end

  def error!(); end

  def error_type(); end

  def header(); end

  def http_version(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(httpv, code, msg); end

  def message(); end

  def msg(); end

  def read_body(dest=T.unsafe(nil), &block); end

  def read_header(); end

  def reading_body(sock, reqmethodallowbody); end

  def response(); end

  def uri(); end

  def uri=(uri); end

  def value(); end
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResponse::Inflater
  def bytes_inflated(); end

  def finish(); end

  def inflate_adapter(dest); end

  def initialize(socket); end

  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  def read_all(dest); end
end

class Gem::Net::HTTPResponse::Inflater
end

class Gem::Net::HTTPResponse
  def self.body_permitted?(); end

  def self.exception_type(); end

  def self.read_new(sock); end
end

Gem::Net::HTTPResponseReceiver = Gem::Net::HTTPResponse

Gem::Net::HTTPRetriableCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRetriableError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPRetriableError
end

class Gem::Net::HTTPSeeOther
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSeeOther
end

class Gem::Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPServerError::EXCEPTION_TYPE = Gem::Net::HTTPFatalError

class Gem::Net::HTTPServerError
end

Gem::Net::HTTPServerErrorCode = Gem::Net::HTTPServerError

Gem::Net::HTTPServerException = Gem::Net::HTTPClientException

class Gem::Net::HTTPServiceUnavailable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServiceUnavailable
end

Gem::Net::HTTPSession = Gem::Net::HTTP

class Gem::Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPSuccess::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPSuccess
end

Gem::Net::HTTPSuccessCode = Gem::Net::HTTPSuccess

class Gem::Net::HTTPSwitchProtocol
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSwitchProtocol
end

class Gem::Net::HTTPTemporaryRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTemporaryRedirect
end

class Gem::Net::HTTPTooManyRequests
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTooManyRequests
end

class Gem::Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPURITooLong
end

class Gem::Net::HTTPUnauthorized
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnauthorized
end

class Gem::Net::HTTPUnavailableForLegalReasons
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnavailableForLegalReasons
end

class Gem::Net::HTTPUnknownResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPUnknownResponse::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPUnknownResponse
end

class Gem::Net::HTTPUnprocessableEntity
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnprocessableEntity
end

class Gem::Net::HTTPUnsupportedMediaType
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnsupportedMediaType
end

class Gem::Net::HTTPUpgradeRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUpgradeRequired
end

class Gem::Net::HTTPUseProxy
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUseProxy
end

class Gem::Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVariantAlsoNegotiates
end

class Gem::Net::HTTPVersionNotSupported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVersionNotSupported
end

class Gem::Net::InternetMessageIO
  def each_list_item(); end

  def each_message_chunk(); end

  def initialize(*arg, **arg1); end

  def write_message(src); end

  def write_message_0(src); end

  def write_message_by_block(&block); end
end

class Gem::Net::InternetMessageIO
end

module Gem::Net::NetPrivate
end

Gem::Net::NetPrivate::HTTPRequest = Gem::Net::HTTPRequest

Gem::Net::NetPrivate::Socket = Gem::Net::InternetMessageIO

module Gem::Net::NetPrivate
end

class Gem::Net::OpenTimeout
end

class Gem::Net::OpenTimeout
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoUnknownError
end

class Gem::Net::ProtoUnknownError
end

Gem::Net::ProtocRetryError = Gem::Net::ProtoRetriableError

class Gem::Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::Protocol
  def self.protocol_param(name, val); end
end

class Gem::Net::ProtocolError
end

class Gem::Net::ProtocolError
end

class Gem::Net::ReadAdapter
  def <<(str); end

  def initialize(block); end
end

class Gem::Net::ReadAdapter
end

class Gem::Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::ReadTimeout
end

class Gem::Net::WriteAdapter
  def <<(str); end

  def initialize(writer); end

  def print(str); end

  def printf(*args); end

  def puts(str=T.unsafe(nil)); end

  def write(str); end
end

class Gem::Net::WriteAdapter
end

class Gem::Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::WriteTimeout
end

module Gem::Net
end

class Gem::Package
  def copy_stream(src, dst); end

  def gem(); end

  def limit_read(io, name, limit); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::SymlinkError
  def initialize(name, destination, destination_dir); end
end

class Gem::Package::SymlinkError
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def pos=(new_pos); end

  def read(maxlen=T.unsafe(nil)); end

  def readpartial(maxlen, outbuf=T.unsafe(nil)); end

  def rewind(); end

  def seek(offset, whence=T.unsafe(nil)); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
  def self.open(header, io, &block); end
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end

  def normalized_linux_version_ext(); end
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self._deprecated_match(platform); end

  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolv
  def each_address(name); end

  def each_name(address); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(resolvers=T.unsafe(nil), use_ipv6: T.unsafe(nil)); end
  AddressRegex = ::T.let(nil, ::T.untyped)
  DefaultResolver = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS
  def close(); end

  def each_address(name); end

  def each_name(address); end

  def each_resource(name, typeclass, &proc); end

  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def getresource(name, typeclass); end

  def getresources(name, typeclass); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end

  def timeouts=(values); end
  Port = ::T.let(nil, ::T.untyped)
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
  UDPSize = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end

  def use_ipv6?(); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::EncodeError
end

class Gem::Resolv::DNS::EncodeError
end

module Gem::Resolv::DNS::Label
end

class Gem::Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Gem::Resolv::DNS::Label::Str
end

module Gem::Resolv::DNS::Label
  def self.split(arg); end
end

class Gem::Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_list(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
end

class Gem::Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d, compress: T.unsafe(nil)); end

  def put_length16(); end

  def put_name(d, compress: T.unsafe(nil)); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Gem::Resolv::DNS::Message::MessageEncoder
end

class Gem::Resolv::DNS::Message
  def self.decode(m); end
end

class Gem::Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def absolute?(); end

  def eql?(other); end

  def initialize(labels, absolute=T.unsafe(nil)); end

  def length(); end

  def subdomain_of?(other); end

  def to_a(); end
end

class Gem::Resolv::DNS::Name
  def self.create(arg); end
end

module Gem::Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::OpCode
end

class Gem::Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Gem::Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Gem::Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::RCode
end

class Gem::Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Gem::Resolv::DNS::Requester::Sender
end

class Gem::Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
end

class Gem::Resolv::DNS::Requester::TCP
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
end

class Gem::Resolv::DNS::Requester
end

class Gem::Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end

  def ttl(); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
end

class Gem::Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CNAME
end

class Gem::Resolv::DNS::Resource::DomainName
  def initialize(name); end

  def name(); end
end

class Gem::Resolv::DNS::Resource::DomainName
end

class Gem::Resolv::DNS::Resource::Generic
  def data(); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Gem::Resolv::DNS::Resource::HINFO
  def cpu(); end

  def initialize(cpu, os); end

  def os(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::HINFO
end

module Gem::Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
end

class Gem::Resolv::DNS::Resource::IN::AAAA
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::AAAA
end

class Gem::Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::ANY
end

class Gem::Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::CNAME
end

class Gem::Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HINFO
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
end

class Gem::Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::LOC
end

class Gem::Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MINFO
end

class Gem::Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MX
end

class Gem::Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::NS
end

class Gem::Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::PTR
end

class Gem::Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SOA
end

class Gem::Resolv::DNS::Resource::IN::SRV
  def initialize(priority, weight, port, target); end

  def port(); end

  def priority(); end

  def target(); end

  def weight(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SRV
end

class Gem::Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SVCB
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Gem::Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::TXT
end

class Gem::Resolv::DNS::Resource::IN::WKS
  def address(); end

  def bitmap(); end

  def initialize(address, protocol, bitmap); end

  def protocol(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::WKS
end

module Gem::Resolv::DNS::Resource::IN
end

class Gem::Resolv::DNS::Resource::LOC
  def altitude(); end

  def hprecision(); end

  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end

  def latitude(); end

  def longitude(); end

  def ssize(); end

  def version(); end

  def vprecision(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::LOC
end

class Gem::Resolv::DNS::Resource::MINFO
  def emailbx(); end

  def initialize(rmailbx, emailbx); end

  def rmailbx(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MINFO
end

class Gem::Resolv::DNS::Resource::MX
  def exchange(); end

  def initialize(preference, exchange); end

  def preference(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MX
end

class Gem::Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::NS
end

class Gem::Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::PTR
end

class Gem::Resolv::DNS::Resource::SOA
  def expire(); end

  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end

  def minimum(); end

  def mname(); end

  def refresh(); end

  def retry(); end

  def rname(); end

  def serial(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::SOA
end

class Gem::Resolv::DNS::Resource::TXT
  def data(); end

  def initialize(first_string, *rest_strings); end

  def strings(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::TXT
end

class Gem::Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Gem::Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Gem::Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Gem::Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.open(*args); end

  def self.random(arg); end
end

class Gem::Resolv::Hosts
  def each_address(name, &proc); end

  def each_name(address, &proc); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(filename=T.unsafe(nil)); end

  def lazy_initialize(); end
  DefaultFileName = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::Hosts
end

class Gem::Resolv::IPv4
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex256 = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv4
  def self.create(arg); end
end

class Gem::Resolv::IPv6
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex_6Hex4Dec = ::T.let(nil, ::T.untyped)
  Regex_8Hex = ::T.let(nil, ::T.untyped)
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex4Dec = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv6
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::LOC::Alt
  def ==(other); end

  def altitude(); end

  def eql?(other); end

  def initialize(altitude); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Alt
  def self.create(arg); end
end

class Gem::Resolv::LOC::Coord
  def ==(other); end

  def coordinates(); end

  def eql?(other); end

  def initialize(coordinates, orientation); end

  def orientation(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Coord
  def self.create(arg); end
end

class Gem::Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end

  def initialize(scalar); end

  def scalar(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Size
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::MDNS
  AddressV4 = ::T.let(nil, ::T.untyped)
  AddressV6 = ::T.let(nil, ::T.untyped)
  Addresses = ::T.let(nil, ::T.untyped)
  Port = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::MDNS
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv
  def self.each_address(name, &block); end

  def self.each_name(address, &proc); end

  def self.getaddress(name); end

  def self.getaddresses(name); end

  def self.getname(address); end

  def self.getnames(address); end
end

class Gem::Resolver
  include ::Gem::Molinillo::UI
  include ::Gem::Molinillo::SpecificationProvider
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::Security
  DEFAULT_KEY_ALGORITHM = ::T.let(nil, ::T.untyped)
  EC_NAME = ::T.let(nil, ::T.untyped)
  RSA_DSA_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_digest(algorithm=T.unsafe(nil)); end

  def self.create_key(algorithm); end

  def self.email_to_name(email_address); end

  def self.get_public_key(key); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def flatten_require_paths(); end

  def removed_method_calls(); end

  def to_ruby(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.find_by_full_name(full_name); end

  def self.gemspec_stubs_in(dir, pattern); end

  def self.latest_spec_for(name); end

  def self.remove_spec(spec); end

  def self.specification_record(); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end

  def validate_required_ruby_version(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::SpecificationRecord
  include ::Enumerable
  def add_spec(spec); end

  def all(); end

  def all=(specs); end

  def all_names(); end

  def each(&blk); end

  def find_active_stub_by_path(path); end

  def find_all_by_name(name, *requirements); end

  def find_by_path(path); end

  def find_inactive_by_path(path); end

  def initialize(dirs); end

  def latest_spec_for(name); end

  def latest_specs(prerelease); end

  def remove_spec(spec); end

  def stubs(); end

  def stubs_for(name); end

  def stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationRecord
  def self.dirs_from(paths); end

  def self.from_path(path); end
end

class Gem::StubSpecification
  include ::Gem::BetterPermissionError
  def ==(other); end

  def build_extensions(); end

  def eql?(other); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def sort_obj(); end

  def spec(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::TSort::Cyclic
end

class Gem::TSort::Cyclic
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

module Gem::Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Timeout::Error
end

class Gem::Timeout::Error
  def self.handle_timeout(message); end
end

class Gem::Timeout::ExitException
  def exception(*arg); end
end

class Gem::Timeout::ExitException
end

module Gem::Timeout
  def self.ensure_timeout_thread_created(); end

  def self.timeout(sec, klass=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Gem::URI::BadURIError
end

class Gem::URI::BadURIError
end

class Gem::URI::Error
end

class Gem::URI::Error
end

class Gem::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Gem::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Gem::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::File
end

class Gem::URI::Generic
  include ::Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def to_str(); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Gem::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Gem::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTP
end

class Gem::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTPS
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAP
end

class Gem::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAPS
end

class Gem::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::URI::MailTo
end

Gem::URI::Parser = Gem::URI::RFC2396_Parser

Gem::URI::REGEXP = Gem::URI::RFC2396_REGEXP

class Gem::URI::RFC2396_Parser
  include ::Gem::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Gem::URI::RFC2396_Parser
end

module Gem::URI::RFC2396_REGEXP
end

module Gem::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Gem::URI::RFC2396_REGEXP::PATTERN
end

module Gem::URI::RFC2396_REGEXP
end

class Gem::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC3986_Parser
end

module Gem::URI::Util
end

module Gem::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Gem::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WS
end

class Gem::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WSS
end

module Gem::URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

class Gem::Version
  def partition_segments(ver); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::WebauthnVerificationError
  def initialize(message); end
end

class Gem::WebauthnVerificationError
end

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.default_user_install(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.dynamic_library_suffixes(); end

  def self.find_config_file(); end

  def self.find_default_spec(path); end

  def self.freebsd_platform?(); end

  def self.load_safe_marshal(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end

  def self.state_file(); end

  def self.state_home(); end
end

class GetText::PoParser
  def _(x); end

  def _reduce_10(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def on_comment(comment); end

  def on_message(msgid, msgstr); end

  def parse(str, data, ignore_fuzzy=T.unsafe(nil)); end

  def unescape(orig); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module GlobalID::FixtureSet
  def global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end

  def signed_global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid, options=T.unsafe(nil)); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid, options=T.unsafe(nil)); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::InvalidModelIdError
end

class GlobalID::Locator::InvalidModelIdError
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class Hash
  def deconstruct_keys(arg); end

  def deep_transform_values(&block); end

  def deep_transform_values!(&block); end
end

class Hash
  def self.from_xml(xml, disallowed_types=T.unsafe(nil)); end

  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Base
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def resolve_entry(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Chain::Implementation
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(token); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::Flatten
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::LazyLoadable
  def initialize(lazy_load: T.unsafe(nil)); end

  def initialized_locales(); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
  def initialize(file, expected_locale, unexpected_locales); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
end

class I18n::Backend::LazyLoadable
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Simple::Implementation
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
  MUTEX = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

class I18n::InvalidFilenames
  NUMBER_OF_ERRORS_SHOWN = ::T.let(nil, ::T.untyped)
end

I18n::JSON = ActiveSupport::JSON

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

class I18n::Locale::Tag::Rfc4646
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

module I18n::MissingTranslation::Base
  PERMITTED_KEYS = ::T.let(nil, ::T.untyped)
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.perform_caching?(); end
end

class IO
  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def path(); end

  def pathconf(arg); end

  def ready?(); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def &(arg); end

  def ^(arg); end

  def and!(arg); end

  def clear(*arg); end

  def copy(*arg); end

  def each(*arg, &blk); end

  def each_byte(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def get_values(arg, arg1); end

  def hexdump(); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def not!(); end

  def null?(); end

  def or!(arg); end

  def pread(*arg); end

  def pwrite(*arg); end

  def read(*arg); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def set_values(arg, arg1, arg2); end

  def shared?(); end

  def size(); end

  def slice(*arg); end

  def transfer(); end

  def valid?(); end

  def values(*arg); end

  def write(*arg); end

  def xor!(arg); end

  def |(arg); end

  def ~(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  SHARED = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::MaskError
end

class IO::Buffer::MaskError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end

  def self.size_of(arg); end
end

class IO::ConsoleMode
  VERSION = ::T.let(nil, ::T.untyped)
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO::TimeoutError
end

class IO::TimeoutError
end

class IO
  def self.console(*arg); end

  def self.console_size(); end

  def self.default_console_size(); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::BaseCompletor
  def command_candidates(target); end

  def completion_candidates(preposing, target, postposing, bind:); end

  def doc_namespace(preposing, matched, postposing, bind:); end

  def retrieve_files_to_require_from_load_path(); end

  def retrieve_files_to_require_relative_from_current_dir(); end

  def retrieve_gem_and_system_load_path(); end
  GEM_PATHS = ::T.let(nil, ::T.untyped)
  HELP_COMMAND_PREPOSING = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  DIM = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class IRB::ColorPrinter
  METHOD_INSPECT = ::T.let(nil, ::T.untyped)
  METHOD_RESPOND_TO = ::T.let(nil, ::T.untyped)
end

module IRB::Command
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

class IRB::Command::Backtrace
  def execute(arg); end
end

class IRB::Command::Base
  def execute(arg); end

  def initialize(irb_context); end

  def irb_context(); end
end

class IRB::Command::Base
  def self.execute(irb_context, arg); end
end

class IRB::Command::Break
  def execute(arg); end
end

class IRB::Command::Catch
  def execute(arg); end
end

class IRB::Command::Context
  def execute(_arg); end
end

class IRB::Command::Continue
  def execute(arg); end
end

class IRB::Command::CurrentWorkingWorkspace
  def execute(_arg); end
end

class IRB::Command::Debug
  def execute(_arg); end

  def execute_debug_command(pre_cmds: T.unsafe(nil), do_cmds: T.unsafe(nil)); end
end

class IRB::Command::DebugCommand
  def self.category(); end

  def self.description(); end
end

class IRB::Command::Delete
  def execute(arg); end
end

class IRB::Command::DisableIrb
  def execute(*arg); end
end

class IRB::Command::Exit
  def execute(_arg); end
end

class IRB::Command::Finish
  def execute(arg); end
end

class IRB::Command::ForceExit
  def execute(_arg); end
end

class IRB::Command::Foreground
  def execute_internal(key=T.unsafe(nil)); end
end

class IRB::Command::Help
  def execute(command_name); end
end

class IRB::Command::Info
  def execute(arg); end
end

class IRB::Command::IrbCommand
  def execute_internal(*obj); end
end

class IRB::Command::IrbInfo
  def execute(_arg); end
end

class IRB::Command::Jobs
  def execute(_arg); end
end

class IRB::Command::Kill
  def execute_internal(*keys); end
end

class IRB::Command::Load
  def execute_internal(file_name=T.unsafe(nil), priv=T.unsafe(nil)); end
end

class IRB::Command::LoaderCommand
  def raise_cmd_argument_error(); end
end

class IRB::Command::Ls
  def class_method_map(classes, dumped_mods); end

  def dump_methods(o, klass, obj); end
end

class IRB::Command::Measure
  def execute_internal(type=T.unsafe(nil), arg=T.unsafe(nil)); end

  def initialize(*args); end
end

class IRB::Command::Next
  def execute(arg); end
end

IRB::Command::Nop = IRB::Command::Base

class IRB::Command::PushWorkspace
  def execute(arg); end
end

class IRB::Command::Require
  def execute_internal(file_name=T.unsafe(nil)); end
end

module IRB::Command::RubyArgsExtractor
  def ruby_args(arg); end

  def unwrap_string_literal(str); end
end

class IRB::Command::Source
  def execute_internal(file_name=T.unsafe(nil)); end
end

class IRB::Command::Step
  def execute(arg); end
end

class IRB::Command::Whereami
  def execute(_arg); end
end

class IRB::Command::Workspaces
  def execute(_arg); end
end

module IRB::Command
  def self._register_with_aliases(name, command_class, *aliases); end

  def self.all_commands_info(); end

  def self.command_names(); end

  def self.command_override_policies(); end

  def self.execute_as_command?(name, public_method:, private_method:); end

  def self.extract_ruby_args(*args, **kwargs); end

  def self.load_command(command); end
end

class IRB::Context
  def __inspect__(); end

  def __to_s__(); end

  def change_workspace(*_main); end

  def command_aliases(); end

  def command_aliases=(command_aliases); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def evaluate(statement, line_no); end

  def evaluate_expression(code, line_no); end

  def extra_doc_dirs(); end

  def extra_doc_dirs=(extra_doc_dirs); end

  def from_binding?(); end

  def history_file(); end

  def history_file=(hist); end

  def home_workspace(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect_last_value(); end

  def newline_before_multiline_output(); end

  def newline_before_multiline_output=(newline_before_multiline_output); end

  def newline_before_multiline_output?(); end

  def pop_workspace(); end

  def push_workspace(*_main); end

  def replace_workspace(workspace); end

  def save_history(); end

  def use_autocomplete(); end

  def use_autocomplete?(); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_reline(); end

  def use_reline?(); end

  def use_singleline(); end

  def use_singleline?(); end

  def with_debugger(); end

  def with_debugger=(with_debugger); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

module IRB::Debug
  IRB_DIR = ::T.let(nil, ::T.untyped)
end

module IRB::Debug
  def self.insert_debug_break(pre_cmds: T.unsafe(nil), do_cmds: T.unsafe(nil)); end

  def self.setup(irb); end
end

IRB::ExtendCommand = IRB::Command

class IRB::FileInputMethod
  def close(); end

  def initialize(file); end
end

class IRB::FileInputMethod
  def self.open(file, &block); end
end

class IRB::HelperMethod::Conf
  def execute(); end
end

module IRB::HelpersContainer
  def conf(*args, **opts, &block); end
end

module IRB::HelpersContainer
  def self.install_helper_methods(); end
end

module IRB::HistorySavingAbility
  def load_history(); end

  def reset_history_counter(); end

  def save_history(); end

  def support_history_saving?(); end
end

module IRB::InputCompletor
  CompletionProc = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end
end

class IRB::InputMethod
  def prompting?(); end

  def support_history_saving?(); end

  def winsize(); end
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
  KERNEL_INSPECT = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
  def build_statement(code); end

  def command?(code); end

  def configure_io(); end

  def convert_invalid_byte_sequence(str, enc); end

  def debug_break(); end

  def debug_readline(binding); end

  def each_top_level_statement(); end

  def encode_with_invalid_byte_sequence(str, enc); end

  def from_binding(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), from_binding: T.unsafe(nil)); end

  def output_value(omit=T.unsafe(nil)); end

  def parse_command(code); end

  def read_input(prompt); end

  def readmultiline(); end
  ASSIGN_OPERATORS_REGEXP = ::T.let(nil, ::T.untyped)
  CONTROL_CHARACTERS_PATTERN = ::T.let(nil, ::T.untyped)
  PROMPT_MAIN_TRUNCATE_LENGTH = ::T.let(nil, ::T.untyped)
  PROMPT_MAIN_TRUNCATE_OMISSION = ::T.let(nil, ::T.untyped)
end

module IRB::IrbLoader
  def irb_load(fn, priv=T.unsafe(nil)); end

  def load_file(path, priv=T.unsafe(nil)); end

  def old(); end

  def search_file_from_ruby_path(fn); end

  def source_file(path); end
end

class IRB::Locale
  def String(mes); end

  def each_localized_path(dir, file); end

  def each_sublocale(); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def search_file(lib_paths, dir, file); end

  def territory(); end
  LEGACY_ENCODING_ALIAS_MAP = ::T.let(nil, ::T.untyped)
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

module IRB::NestingParser
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
end

class IRB::Pager
  PAGE_COMMANDS = ::T.let(nil, ::T.untyped)
end

class IRB::Pager
  def self.page(retain_content: T.unsafe(nil)); end

  def self.page_content(content, **options); end
end

class IRB::ReadlineInputMethod
  def completion_info(); end
end

class IRB::ReadlineInputMethod
  def self.initialize_readline(); end
end

class IRB::RegexpCompletor
  def complete_require_path(target, preposing, postposing); end

  def doc_namespace(_preposing, matched, _postposing, bind:); end

  def retrieve_completion_data(input, bind:, doc_namespace:); end

  def select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
  Operators = ::T.let(nil, ::T.untyped)
end

class IRB::ReidlineInputMethod
  def initialize(); end
end

class IRB::RelineInputMethod
  def auto_indent(&block); end

  def check_termination(&block); end

  def completion_info(); end

  def display_document(matched); end

  def dynamic_prompt(&block); end

  def initialize(completor); end

  def rdoc_ri_driver(); end

  def retrieve_doc_namespace(matched); end

  def show_doc_dialog_proc(); end
  HISTORY = ::T.let(nil, ::T.untyped)
end

class IRB::RubyLex
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
  ERROR_TOKENS = ::T.let(nil, ::T.untyped)
  FREE_INDENT_TOKENS = ::T.let(nil, ::T.untyped)
  LTYPE_TOKENS = ::T.let(nil, ::T.untyped)
end

class IRB::SourceFinder
  def find_source(signature, super_level=T.unsafe(nil)); end

  def initialize(irb_context); end
end

class IRB::Statement
  def code(); end

  def is_assignment?(); end

  def should_be_handled_by_debugger?(); end

  def suppresses_echo?(); end
end

class IRB::Statement::Command
  def arg(); end

  def command_class(); end

  def initialize(original_code, command_class, arg); end
end

class IRB::Statement::Expression
  def initialize(code, is_assignment); end
end

class IRB::TypeCompletor
  def completion_candidates(preposing, target, _postposing, bind:); end

  def doc_namespace(preposing, matched, _postposing, bind:); end

  def initialize(context); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def load_helper_methods_to_main(); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.initialized?(); end

  def self.irbrc_files(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.raise_validation_error(msg); end

  def self.rc_file(ext); end

  def self.run_config(); end

  def self.set_measure_callback(type=T.unsafe(nil), arg=T.unsafe(nil), &block); end

  def self.unset_measure_callback(type=T.unsafe(nil)); end

  def self.validate_config(); end
end

class Integer
  include ::ActiveSupport::NumericWithFormat
  def ceildiv(other); end

  def multiple_of?(number); end

  def ordinal(); end

  def ordinalize(); end
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end

  def script_safe(); end

  def script_safe=(script_safe); end

  def script_safe?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  extend ::Bootsnap::CompileCache::JSON::Patch
  def self.create_fast_state(); end

  def self.create_pretty_state(); end
end

module Kernel
  include ::DEBUGGER__::TrapInterceptor
  def class_eval(*args, &block); end

  def debugger(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.trap(*arg); end

  def self.zeitwerk_original_require(arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module LanguageServer::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionKind
  EMPTY = ::T.let(nil, ::T.untyped)
  QUICK_FIX = ::T.let(nil, ::T.untyped)
  REFACTOR = ::T.let(nil, ::T.untyped)
  REFACTOR_EXTRACT = ::T.let(nil, ::T.untyped)
  REFACTOR_INLINE = ::T.let(nil, ::T.untyped)
  REFACTOR_REWRITE = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
  SOURCE_FIX_ALL = ::T.let(nil, ::T.untyped)
  SOURCE_ORGANIZE_IMPORTS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionTriggerKind
  AUTOMATIC = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemKind
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionTriggerKind
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
  TRIGGER_FOR_INCOMPLETE_COMPLETIONS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticSeverity
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
  UNNECESSARY = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentDiagnosticReportKind
  FULL = ::T.let(nil, ::T.untyped)
  UNCHANGED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentHighlightKind
  READ = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ErrorCodes
  CONTENT_MODIFIED = ::T.let(nil, ::T.untyped)
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  REQUEST_FAILED = ::T.let(nil, ::T.untyped)
  SERVER_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FailureHandlingKind
  ABORT = ::T.let(nil, ::T.untyped)
  TEXT_ONLY_TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  UNDO = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileChangeType
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileOperationPatternKind
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FoldingRangeKind
  COMMENT = ::T.let(nil, ::T.untyped)
  IMPORTS = ::T.let(nil, ::T.untyped)
  REGION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InitializeErrorCodes
  UNKNOWN_PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InlayHintKind
  PARAMETER = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextFormat
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextMode
  ADJUST_INDENTATION = ::T.let(nil, ::T.untyped)
  AS_IS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MarkupKind
  MARKDOWN = ::T.let(nil, ::T.untyped)
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MessageType
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MonikerKind
  EXPORT = ::T.let(nil, ::T.untyped)
  IMPORT = ::T.let(nil, ::T.untyped)
  LOCAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::NotebookCellKind
  CODE = ::T.let(nil, ::T.untyped)
  MARKUP = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PositionEncodingKind
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior
  IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ResourceOperationKind
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  RENAME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenModifiers
  ABSTRACT = ::T.let(nil, ::T.untyped)
  ASYNC = ::T.let(nil, ::T.untyped)
  DECLARATION = ::T.let(nil, ::T.untyped)
  DEFAULT_LIBRARY = ::T.let(nil, ::T.untyped)
  DEFINITION = ::T.let(nil, ::T.untyped)
  DEPRECATED = ::T.let(nil, ::T.untyped)
  DOCUMENTATION = ::T.let(nil, ::T.untyped)
  MODIFICATION = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  STATIC = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenTypes
  CLASS = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DECORATOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  MACRO = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PARAMETER = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind
  CONTENT_CHANGE = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolKind
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSaveReason
  AFTER_DELAY = ::T.let(nil, ::T.untyped)
  FOCUS_OUT = ::T.let(nil, ::T.untyped)
  MANUAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSyncKind
  FULL = ::T.let(nil, ::T.untyped)
  INCREMENTAL = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TokenFormat
  RELATIVE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::UniquenessLevel
  DOCUMENT = ::T.let(nil, ::T.untyped)
  GLOBAL = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  PROJECT = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::WatchKind
  CHANGE = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
end

class LanguageServer::Protocol::Interface::AnnotatedTextEdit
  def annotation_id(); end

  def attributes(); end

  def initialize(range:, new_text:, annotation_id:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditParams
  def attributes(); end

  def edit(); end

  def initialize(edit:, label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditResult
  def applied(); end

  def attributes(); end

  def failed_change(); end

  def failure_reason(); end

  def initialize(applied:, failure_reason: T.unsafe(nil), failed_change: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCall
  def attributes(); end

  def from(); end

  def from_ranges(); end

  def initialize(from:, from_ranges:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCall
  def attributes(); end

  def from_ranges(); end

  def initialize(to:, from_ranges:); end

  def to(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CancelParams
  def attributes(); end

  def id(); end

  def initialize(id:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ChangeAnnotation
  def attributes(); end

  def description(); end

  def initialize(label:, needs_confirmation: T.unsafe(nil), description: T.unsafe(nil)); end

  def label(); end

  def needs_confirmation(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ClientCapabilities
  def attributes(); end

  def experimental(); end

  def general(); end

  def initialize(workspace: T.unsafe(nil), text_document: T.unsafe(nil), notebook_document: T.unsafe(nil), window: T.unsafe(nil), general: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def notebook_document(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def window(); end

  def workspace(); end
end

class LanguageServer::Protocol::Interface::CodeAction
  def attributes(); end

  def command(); end

  def data(); end

  def diagnostics(); end

  def disabled(); end

  def edit(); end

  def initialize(title:, kind: T.unsafe(nil), diagnostics: T.unsafe(nil), is_preferred: T.unsafe(nil), disabled: T.unsafe(nil), edit: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def is_preferred(); end

  def kind(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionClientCapabilities
  def attributes(); end

  def code_action_literal_support(); end

  def data_support(); end

  def disabled_support(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), code_action_literal_support: T.unsafe(nil), is_preferred_support: T.unsafe(nil), disabled_support: T.unsafe(nil), data_support: T.unsafe(nil), resolve_support: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def is_preferred_support(); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionContext
  def attributes(); end

  def diagnostics(); end

  def initialize(diagnostics:, only: T.unsafe(nil), trigger_kind: T.unsafe(nil)); end

  def only(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CodeActionOptions
  def attributes(); end

  def code_action_kinds(); end

  def initialize(work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeActionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeActionRegistrationOptions
  def attributes(); end

  def code_action_kinds(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeDescription
  def attributes(); end

  def href(); end

  def initialize(href:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLens
  def attributes(); end

  def command(); end

  def data(); end

  def initialize(range:, command: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeLensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Color
  def alpha(); end

  def attributes(); end

  def blue(); end

  def green(); end

  def initialize(red:, green:, blue:, alpha:); end

  def red(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorInformation
  def attributes(); end

  def color(); end

  def initialize(range:, color:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentation
  def additional_text_edits(); end

  def attributes(); end

  def initialize(label:, text_edit: T.unsafe(nil), additional_text_edits: T.unsafe(nil)); end

  def label(); end

  def text_edit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentationParams
  def attributes(); end

  def color(); end

  def initialize(text_document:, color:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::Command
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(title:, command:, arguments: T.unsafe(nil)); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionClientCapabilities
  def attributes(); end

  def completion_item(); end

  def completion_item_kind(); end

  def completion_list(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), completion_item: T.unsafe(nil), completion_item_kind: T.unsafe(nil), context_support: T.unsafe(nil), insert_text_mode: T.unsafe(nil), completion_list: T.unsafe(nil)); end

  def insert_text_mode(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionContext
  def attributes(); end

  def initialize(trigger_kind:, trigger_character: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CompletionItem
  def additional_text_edits(); end

  def attributes(); end

  def command(); end

  def commit_characters(); end

  def data(); end

  def deprecated(); end

  def detail(); end

  def documentation(); end

  def filter_text(); end

  def initialize(label:, label_details: T.unsafe(nil), kind: T.unsafe(nil), tags: T.unsafe(nil), detail: T.unsafe(nil), documentation: T.unsafe(nil), deprecated: T.unsafe(nil), preselect: T.unsafe(nil), sort_text: T.unsafe(nil), filter_text: T.unsafe(nil), insert_text: T.unsafe(nil), insert_text_format: T.unsafe(nil), insert_text_mode: T.unsafe(nil), text_edit: T.unsafe(nil), text_edit_text: T.unsafe(nil), additional_text_edits: T.unsafe(nil), commit_characters: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def insert_text(); end

  def insert_text_format(); end

  def insert_text_mode(); end

  def kind(); end

  def label(); end

  def label_details(); end

  def preselect(); end

  def sort_text(); end

  def tags(); end

  def text_edit(); end

  def text_edit_text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionItemLabelDetails
  def attributes(); end

  def description(); end

  def detail(); end

  def initialize(detail: T.unsafe(nil), description: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionList
  def attributes(); end

  def initialize(is_incomplete:, items:, item_defaults: T.unsafe(nil)); end

  def is_incomplete(); end

  def item_defaults(); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CompletionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CompletionRegistrationOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ConfigurationItem
  def attributes(); end

  def initialize(scope_uri: T.unsafe(nil), section: T.unsafe(nil)); end

  def scope_uri(); end

  def section(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ConfigurationParams
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CreateFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeclarationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DeclarationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeleteFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::DeleteFileOptions
  def attributes(); end

  def ignore_if_not_exists(); end

  def initialize(recursive: T.unsafe(nil), ignore_if_not_exists: T.unsafe(nil)); end

  def recursive(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeleteFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Diagnostic
  def attributes(); end

  def code(); end

  def code_description(); end

  def data(); end

  def initialize(range:, message:, severity: T.unsafe(nil), code: T.unsafe(nil), code_description: T.unsafe(nil), source: T.unsafe(nil), tags: T.unsafe(nil), related_information: T.unsafe(nil), data: T.unsafe(nil)); end

  def message(); end

  def range(); end

  def related_information(); end

  def severity(); end

  def source(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), related_document_support: T.unsafe(nil)); end

  def related_document_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticOptions
  def attributes(); end

  def identifier(); end

  def initialize(inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def identifier(); end

  def initialize(document_selector:, inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil), id: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticRelatedInformation
  def attributes(); end

  def initialize(location:, message:); end

  def location(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticServerCancellationData
  def attributes(); end

  def initialize(retrigger_request:); end

  def retrigger_request(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationParams
  def attributes(); end

  def initialize(settings:); end

  def settings(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeNotebookDocumentParams
  def attributes(); end

  def change(); end

  def initialize(notebook_document:, change:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeTextDocumentParams
  def attributes(); end

  def content_changes(); end

  def initialize(text_document:, content_changes:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), relative_pattern_support: T.unsafe(nil)); end

  def relative_pattern_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesParams
  def attributes(); end

  def changes(); end

  def initialize(changes:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesRegistrationOptions
  def attributes(); end

  def initialize(watchers:); end

  def to_hash(); end

  def to_json(*args); end

  def watchers(); end
end

class LanguageServer::Protocol::Interface::DidChangeWorkspaceFoldersParams
  def attributes(); end

  def event(); end

  def initialize(event:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveNotebookDocumentParams
  def attributes(); end

  def initialize(notebook_document:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, text: T.unsafe(nil)); end

  def text(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentColorParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentColorRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, id: T.unsafe(nil), work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil), previous_result_id: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticReportPartialResult
  def attributes(); end

  def initialize(related_documents:); end

  def related_documents(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFilter
  def attributes(); end

  def initialize(language: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def language(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingParams
  def attributes(); end

  def initialize(text_document:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlight
  def attributes(); end

  def initialize(range:, kind: T.unsafe(nil)); end

  def kind(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLink
  def attributes(); end

  def data(); end

  def initialize(range:, target: T.unsafe(nil), tooltip: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def target(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), tooltip_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip_support(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingOptions
  def attributes(); end

  def first_trigger_character(); end

  def initialize(first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingParams
  def attributes(); end

  def ch(); end

  def initialize(text_document:, position:, ch:, options:); end

  def options(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def first_trigger_character(); end

  def initialize(document_selector:, first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingParams
  def attributes(); end

  def initialize(text_document:, range:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbol
  def attributes(); end

  def children(); end

  def deprecated(); end

  def detail(); end

  def initialize(name:, kind:, range:, selection_range:, detail: T.unsafe(nil), tags: T.unsafe(nil), deprecated: T.unsafe(nil), children: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def hierarchical_document_symbol_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), hierarchical_document_symbol_support: T.unsafe(nil), tag_support: T.unsafe(nil), label_support: T.unsafe(nil)); end

  def label_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandParams
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(command:, work_done_token: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandRegistrationOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecutionSummary
  def attributes(); end

  def execution_order(); end

  def initialize(execution_order:, success: T.unsafe(nil)); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileCreate
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileDelete
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileEvent
  def attributes(); end

  def initialize(uri:, type:); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileOperationFilter
  def attributes(); end

  def initialize(pattern:, scheme: T.unsafe(nil)); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPattern
  def attributes(); end

  def glob(); end

  def initialize(glob:, matches: T.unsafe(nil), options: T.unsafe(nil)); end

  def matches(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPatternOptions
  def attributes(); end

  def ignore_case(); end

  def initialize(ignore_case: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationRegistrationOptions
  def attributes(); end

  def filters(); end

  def initialize(filters:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileRename
  def attributes(); end

  def initialize(old_uri:, new_uri:); end

  def new_uri(); end

  def old_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileSystemWatcher
  def attributes(); end

  def glob_pattern(); end

  def initialize(glob_pattern:, kind: T.unsafe(nil)); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRange
  def attributes(); end

  def collapsed_text(); end

  def end_character(); end

  def end_line(); end

  def initialize(start_line:, end_line:, start_character: T.unsafe(nil), end_character: T.unsafe(nil), kind: T.unsafe(nil), collapsed_text: T.unsafe(nil)); end

  def kind(); end

  def start_character(); end

  def start_line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def folding_range(); end

  def folding_range_kind(); end

  def initialize(dynamic_registration: T.unsafe(nil), range_limit: T.unsafe(nil), line_folding_only: T.unsafe(nil), folding_range_kind: T.unsafe(nil), folding_range: T.unsafe(nil)); end

  def line_folding_only(); end

  def range_limit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FormattingOptions
  def attributes(); end

  def initialize(tab_size:, insert_spaces:, trim_trailing_whitespace: T.unsafe(nil), insert_final_newline: T.unsafe(nil), trim_final_newlines: T.unsafe(nil)); end

  def insert_final_newline(); end

  def insert_spaces(); end

  def tab_size(); end

  def to_hash(); end

  def to_json(*args); end

  def trim_final_newlines(); end

  def trim_trailing_whitespace(); end
end

class LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Hover
  def attributes(); end

  def contents(); end

  def initialize(contents:, range: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverClientCapabilities
  def attributes(); end

  def content_format(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), content_format: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::HoverRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverResult
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ImplementationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ImplementationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ImplementationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ImplementationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InitializeError
  def attributes(); end

  def initialize(retry:); end

  def retry(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializeParams
  def attributes(); end

  def capabilities(); end

  def client_info(); end

  def initialization_options(); end

  def initialize(process_id:, root_uri:, capabilities:, work_done_token: T.unsafe(nil), client_info: T.unsafe(nil), locale: T.unsafe(nil), root_path: T.unsafe(nil), initialization_options: T.unsafe(nil), trace: T.unsafe(nil), workspace_folders: T.unsafe(nil)); end

  def locale(); end

  def process_id(); end

  def root_path(); end

  def root_uri(); end

  def to_hash(); end

  def to_json(*args); end

  def trace(); end

  def work_done_token(); end

  def workspace_folders(); end
end

class LanguageServer::Protocol::Interface::InitializeResult
  def attributes(); end

  def capabilities(); end

  def initialize(capabilities:, server_info: T.unsafe(nil)); end

  def server_info(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializedParams
  def attributes(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHint
  def attributes(); end

  def data(); end

  def initialize(position:, label:, kind: T.unsafe(nil), text_edits: T.unsafe(nil), tooltip: T.unsafe(nil), padding_left: T.unsafe(nil), padding_right: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def label(); end

  def padding_left(); end

  def padding_right(); end

  def position(); end

  def text_edits(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::InlayHintClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHintLabelPart
  def attributes(); end

  def command(); end

  def initialize(value:, tooltip: T.unsafe(nil), location: T.unsafe(nil), command: T.unsafe(nil)); end

  def location(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::InlayHintOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlayHintRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil), id: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueContext
  def attributes(); end

  def frame_id(); end

  def initialize(frame_id:, stopped_location:); end

  def stopped_location(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueEvaluatableExpression
  def attributes(); end

  def expression(); end

  def initialize(range:, expression: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlineValueRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueText
  def attributes(); end

  def initialize(range:, text:); end

  def range(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueVariableLookup
  def attributes(); end

  def case_sensitive_lookup(); end

  def initialize(range:, case_sensitive_lookup:, variable_name: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def variable_name(); end
end

class LanguageServer::Protocol::Interface::InlineValueWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InsertReplaceEdit
  def attributes(); end

  def initialize(new_text:, insert:, replace:); end

  def insert(); end

  def new_text(); end

  def replace(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRanges
  def attributes(); end

  def initialize(ranges:, word_pattern: T.unsafe(nil)); end

  def ranges(); end

  def to_hash(); end

  def to_json(*args); end

  def word_pattern(); end
end

class LanguageServer::Protocol::Interface::Location
  def attributes(); end

  def initialize(uri:, range:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::LocationLink
  def attributes(); end

  def initialize(target_uri:, target_range:, target_selection_range:, origin_selection_range: T.unsafe(nil)); end

  def origin_selection_range(); end

  def target_range(); end

  def target_selection_range(); end

  def target_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LogMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::LogTraceParams
  def attributes(); end

  def initialize(message:, verbose: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def verbose(); end
end

class LanguageServer::Protocol::Interface::MarkupContent
  def attributes(); end

  def initialize(kind:, value:); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::Message
  def attributes(); end

  def initialize(jsonrpc:); end

  def jsonrpc(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MessageActionItem
  def attributes(); end

  def initialize(title:); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Moniker
  def attributes(); end

  def identifier(); end

  def initialize(scheme:, identifier:, unique:, kind: T.unsafe(nil)); end

  def kind(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end

  def unique(); end
end

class LanguageServer::Protocol::Interface::MonikerClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MonikerOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::MonikerParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::MonikerRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::NotebookCell
  def attributes(); end

  def document(); end

  def execution_summary(); end

  def initialize(kind:, document:, metadata: T.unsafe(nil), execution_summary: T.unsafe(nil)); end

  def kind(); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellArrayChange
  def attributes(); end

  def cells(); end

  def delete_count(); end

  def initialize(start:, delete_count:, cells: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellTextDocumentFilter
  def attributes(); end

  def initialize(notebook:, language: T.unsafe(nil)); end

  def language(); end

  def notebook(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocument
  def attributes(); end

  def cells(); end

  def initialize(uri:, notebook_type:, version:, cells:, metadata: T.unsafe(nil)); end

  def metadata(); end

  def notebook_type(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentChangeEvent
  def attributes(); end

  def cells(); end

  def initialize(metadata: T.unsafe(nil), cells: T.unsafe(nil)); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentClientCapabilities
  def attributes(); end

  def initialize(synchronization:); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentFilter
  def attributes(); end

  def initialize(notebook_type: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def notebook_type(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def execution_summary_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), execution_summary_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncOptions
  def attributes(); end

  def initialize(notebook_selector:, save: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(notebook_selector:, save: T.unsafe(nil), id: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotificationMessage
  def attributes(); end

  def initialize(jsonrpc:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::ParameterInformation
  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PartialResultParams
  def attributes(); end

  def initialize(partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Position
  def attributes(); end

  def character(); end

  def initialize(line:, character:); end

  def line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PrepareRenameParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::PreviousResultId
  def attributes(); end

  def initialize(uri:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ProgressParams
  def attributes(); end

  def initialize(token:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsClientCapabilities
  def attributes(); end

  def code_description_support(); end

  def data_support(); end

  def initialize(related_information: T.unsafe(nil), tag_support: T.unsafe(nil), version_support: T.unsafe(nil), code_description_support: T.unsafe(nil), data_support: T.unsafe(nil)); end

  def related_information(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end

  def version_support(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsParams
  def attributes(); end

  def diagnostics(); end

  def initialize(uri:, diagnostics:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::Range
  def attributes(); end

  def end(); end

  def initialize(start:, end:); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceContext
  def attributes(); end

  def include_declaration(); end

  def initialize(include_declaration:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ReferenceParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ReferenceRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::Registration
  def attributes(); end

  def id(); end

  def initialize(id:, method:, register_options: T.unsafe(nil)); end

  def method(); end

  def register_options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RegistrationParams
  def attributes(); end

  def initialize(registrations:); end

  def registrations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RegularExpressionsClientCapabilities
  def attributes(); end

  def engine(); end

  def initialize(engine:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def version(); end
end

class LanguageServer::Protocol::Interface::RelatedFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil), related_documents: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelatedUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, related_documents: T.unsafe(nil)); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelativePattern
  def attributes(); end

  def base_uri(); end

  def initialize(base_uri:, pattern:); end

  def pattern(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), prepare_support: T.unsafe(nil), prepare_support_default_behavior: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def prepare_support(); end

  def prepare_support_default_behavior(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, old_uri:, new_uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def new_uri(); end

  def old_uri(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RenameParams
  def attributes(); end

  def initialize(text_document:, position:, new_name:, work_done_token: T.unsafe(nil)); end

  def new_name(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::RenameRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RequestMessage
  def attributes(); end

  def id(); end

  def initialize(jsonrpc:, id:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseError
  def attributes(); end

  def code(); end

  def data(); end

  def initialize(code:, message:, data: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseMessage
  def attributes(); end

  def error(); end

  def id(); end

  def initialize(jsonrpc:, id:, result: T.unsafe(nil), error: T.unsafe(nil)); end

  def jsonrpc(); end

  def result(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SaveOptions
  def attributes(); end

  def include_text(); end

  def initialize(include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRange
  def attributes(); end

  def initialize(range:, parent: T.unsafe(nil)); end

  def parent(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeParams
  def attributes(); end

  def initialize(text_document:, positions:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def positions(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokens
  def attributes(); end

  def data(); end

  def initialize(data:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensClientCapabilities
  def attributes(); end

  def augments_syntax_tokens(); end

  def dynamic_registration(); end

  def formats(); end

  def initialize(requests:, token_types:, token_modifiers:, formats:, dynamic_registration: T.unsafe(nil), overlapping_token_support: T.unsafe(nil), multiline_token_support: T.unsafe(nil), server_cancel_support: T.unsafe(nil), augments_syntax_tokens: T.unsafe(nil)); end

  def multiline_token_support(); end

  def overlapping_token_support(); end

  def requests(); end

  def server_cancel_support(); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDelta
  def attributes(); end

  def edits(); end

  def initialize(edits:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaParams
  def attributes(); end

  def initialize(text_document:, previous_result_id:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaPartialResult
  def attributes(); end

  def edits(); end

  def initialize(edits:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensEdit
  def attributes(); end

  def data(); end

  def delete_count(); end

  def initialize(start:, delete_count:, data: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensLegend
  def attributes(); end

  def initialize(token_types:, token_modifiers:); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensOptions
  def attributes(); end

  def full(); end

  def initialize(legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensPartialResult
  def attributes(); end

  def data(); end

  def initialize(data:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRangeParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def full(); end

  def id(); end

  def initialize(document_selector:, legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil), id: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ServerCapabilities
  def attributes(); end

  def call_hierarchy_provider(); end

  def code_action_provider(); end

  def code_lens_provider(); end

  def color_provider(); end

  def completion_provider(); end

  def declaration_provider(); end

  def definition_provider(); end

  def diagnostic_provider(); end

  def document_formatting_provider(); end

  def document_highlight_provider(); end

  def document_link_provider(); end

  def document_on_type_formatting_provider(); end

  def document_range_formatting_provider(); end

  def document_symbol_provider(); end

  def execute_command_provider(); end

  def experimental(); end

  def folding_range_provider(); end

  def hover_provider(); end

  def implementation_provider(); end

  def initialize(position_encoding: T.unsafe(nil), text_document_sync: T.unsafe(nil), notebook_document_sync: T.unsafe(nil), completion_provider: T.unsafe(nil), hover_provider: T.unsafe(nil), signature_help_provider: T.unsafe(nil), declaration_provider: T.unsafe(nil), definition_provider: T.unsafe(nil), type_definition_provider: T.unsafe(nil), implementation_provider: T.unsafe(nil), references_provider: T.unsafe(nil), document_highlight_provider: T.unsafe(nil), document_symbol_provider: T.unsafe(nil), code_action_provider: T.unsafe(nil), code_lens_provider: T.unsafe(nil), document_link_provider: T.unsafe(nil), color_provider: T.unsafe(nil), document_formatting_provider: T.unsafe(nil), document_range_formatting_provider: T.unsafe(nil), document_on_type_formatting_provider: T.unsafe(nil), rename_provider: T.unsafe(nil), folding_range_provider: T.unsafe(nil), execute_command_provider: T.unsafe(nil), selection_range_provider: T.unsafe(nil), linked_editing_range_provider: T.unsafe(nil), call_hierarchy_provider: T.unsafe(nil), semantic_tokens_provider: T.unsafe(nil), moniker_provider: T.unsafe(nil), type_hierarchy_provider: T.unsafe(nil), inline_value_provider: T.unsafe(nil), inlay_hint_provider: T.unsafe(nil), diagnostic_provider: T.unsafe(nil), workspace_symbol_provider: T.unsafe(nil), workspace: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def inlay_hint_provider(); end

  def inline_value_provider(); end

  def linked_editing_range_provider(); end

  def moniker_provider(); end

  def notebook_document_sync(); end

  def position_encoding(); end

  def references_provider(); end

  def rename_provider(); end

  def selection_range_provider(); end

  def semantic_tokens_provider(); end

  def signature_help_provider(); end

  def text_document_sync(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition_provider(); end

  def type_hierarchy_provider(); end

  def workspace(); end

  def workspace_symbol_provider(); end
end

class LanguageServer::Protocol::Interface::SetTraceParams
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ShowDocumentClientCapabilities
  def attributes(); end

  def initialize(support:); end

  def support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowDocumentParams
  def attributes(); end

  def external(); end

  def initialize(uri:, external: T.unsafe(nil), take_focus: T.unsafe(nil), selection: T.unsafe(nil)); end

  def selection(); end

  def take_focus(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::ShowDocumentResult
  def attributes(); end

  def initialize(success:); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestClientCapabilities
  def attributes(); end

  def initialize(message_action_item: T.unsafe(nil)); end

  def message_action_item(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestParams
  def actions(); end

  def attributes(); end

  def initialize(type:, message:, actions: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::SignatureHelp
  def active_parameter(); end

  def active_signature(); end

  def attributes(); end

  def initialize(signatures:, active_signature: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def signatures(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelpClientCapabilities
  def attributes(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), signature_information: T.unsafe(nil), context_support: T.unsafe(nil)); end

  def signature_information(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelpContext
  def active_signature_help(); end

  def attributes(); end

  def initialize(trigger_kind:, is_retrigger:, trigger_character: T.unsafe(nil), active_signature_help: T.unsafe(nil)); end

  def is_retrigger(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureInformation
  def active_parameter(); end

  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil), parameters: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def label(); end

  def parameters(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::StaticRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SymbolInformation
  def attributes(); end

  def container_name(); end

  def deprecated(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), deprecated: T.unsafe(nil), container_name: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentChangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, sync_kind:); end

  def sync_kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentClientCapabilities
  def attributes(); end

  def call_hierarchy(); end

  def code_action(); end

  def code_lens(); end

  def color_provider(); end

  def completion(); end

  def declaration(); end

  def definition(); end

  def diagnostic(); end

  def document_highlight(); end

  def document_link(); end

  def document_symbol(); end

  def folding_range(); end

  def formatting(); end

  def hover(); end

  def implementation(); end

  def initialize(synchronization: T.unsafe(nil), completion: T.unsafe(nil), hover: T.unsafe(nil), signature_help: T.unsafe(nil), declaration: T.unsafe(nil), definition: T.unsafe(nil), type_definition: T.unsafe(nil), implementation: T.unsafe(nil), references: T.unsafe(nil), document_highlight: T.unsafe(nil), document_symbol: T.unsafe(nil), code_action: T.unsafe(nil), code_lens: T.unsafe(nil), document_link: T.unsafe(nil), color_provider: T.unsafe(nil), formatting: T.unsafe(nil), range_formatting: T.unsafe(nil), on_type_formatting: T.unsafe(nil), rename: T.unsafe(nil), publish_diagnostics: T.unsafe(nil), folding_range: T.unsafe(nil), selection_range: T.unsafe(nil), linked_editing_range: T.unsafe(nil), call_hierarchy: T.unsafe(nil), semantic_tokens: T.unsafe(nil), moniker: T.unsafe(nil), type_hierarchy: T.unsafe(nil), inline_value: T.unsafe(nil), inlay_hint: T.unsafe(nil), diagnostic: T.unsafe(nil)); end

  def inlay_hint(); end

  def inline_value(); end

  def linked_editing_range(); end

  def moniker(); end

  def on_type_formatting(); end

  def publish_diagnostics(); end

  def range_formatting(); end

  def references(); end

  def rename(); end

  def selection_range(); end

  def semantic_tokens(); end

  def signature_help(); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition(); end

  def type_hierarchy(); end
end

class LanguageServer::Protocol::Interface::TextDocumentContentChangeEvent
  def attributes(); end

  def initialize(text:, range: T.unsafe(nil), range_length: T.unsafe(nil)); end

  def range(); end

  def range_length(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentEdit
  def attributes(); end

  def edits(); end

  def initialize(text_document:, edits:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TextDocumentItem
  def attributes(); end

  def initialize(uri:, language_id:, version:, text:); end

  def language_id(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::TextDocumentPositionParams
  def attributes(); end

  def initialize(text_document:, position:); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSaveRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def include_text(); end

  def initialize(document_selector:, include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncClientCapabilities
  def attributes(); end

  def did_save(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), did_save: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncOptions
  def attributes(); end

  def change(); end

  def initialize(open_close: T.unsafe(nil), change: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), save: T.unsafe(nil)); end

  def open_close(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextEdit
  def attributes(); end

  def initialize(range:, new_text:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySubtypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySupertypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::UnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Unregistration
  def attributes(); end

  def id(); end

  def initialize(id:, method:); end

  def method(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::UnregistrationParams
  def attributes(); end

  def initialize(unregisterations:); end

  def to_hash(); end

  def to_json(*args); end

  def unregisterations(); end
end

class LanguageServer::Protocol::Interface::VersionedNotebookDocumentIdentifier
  def attributes(); end

  def initialize(version:, uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::VersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WillSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, reason:); end

  def reason(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressBegin
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, title:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCancelParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCreateParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressEnd
  def attributes(); end

  def initialize(kind:, message: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressParams
  def attributes(); end

  def initialize(work_done_token: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressReport
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(previous_result_ids:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_ids(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReport
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReportPartialResult
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEdit
  def attributes(); end

  def change_annotations(); end

  def changes(); end

  def document_changes(); end

  def initialize(changes: T.unsafe(nil), document_changes: T.unsafe(nil), change_annotations: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEditClientCapabilities
  def attributes(); end

  def change_annotation_support(); end

  def document_changes(); end

  def failure_handling(); end

  def initialize(document_changes: T.unsafe(nil), resource_operations: T.unsafe(nil), failure_handling: T.unsafe(nil), normalizes_line_endings: T.unsafe(nil), change_annotation_support: T.unsafe(nil)); end

  def normalizes_line_endings(); end

  def resource_operations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFolder
  def attributes(); end

  def initialize(uri:, name:); end

  def name(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersChangeEvent
  def added(); end

  def attributes(); end

  def initialize(added:, removed:); end

  def removed(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersServerCapabilities
  def attributes(); end

  def change_notifications(); end

  def initialize(supported: T.unsafe(nil), change_notifications: T.unsafe(nil)); end

  def supported(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, uri:, version:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbol
  def attributes(); end

  def container_name(); end

  def data(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), container_name: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), tag_support: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolParams
  def attributes(); end

  def initialize(query:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def query(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolRegistrationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, uri:, version:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Transport::Io::Reader
  def initialize(io); end

  def read(&block); end
end

class LanguageServer::Protocol::Transport::Io::Writer
  def initialize(io); end

  def io(); end

  def write(response); end
end

class LanguageServer::Protocol::Transport::Stdio::Reader
  def initialize(); end
end

class LanguageServer::Protocol::Transport::Stdio::Writer
  def initialize(); end
end

class LoadError
  include ::DidYouMean::Correctable
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  DatetimeFormat = ::T.let(nil, ::T.untyped)
  Format = ::T.let(nil, ::T.untyped)
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::DocumentDecorator
  def initialize(*args, &block); end
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  INLINE_LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINEBREAKERS = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

Loofah::HTML = Loofah::HTML4

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_COLORS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_EXTENDED_COLORS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ARIA_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_IMPORTANT = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
  CSS_PROPERTY_STRING_WITHOUT_EMBEDDED_QUOTES = ::T.let(nil, ::T.untyped)
  CSS_WHITESPACE = ::T.let(nil, ::T.untyped)
  DATA_ATTRIBUTE_NAME = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  def self.allowed_element?(element_name); end

  def self.cdata_escape(node); end

  def self.cdata_needs_escaping?(node); end

  def self.escape_tags(string); end

  def self.force_correct_attribute_escaping!(node); end

  def self.scrub_attribute_that_allows_local_ref(attr_node); end

  def self.scrub_attributes(node); end

  def self.scrub_css(style); end

  def self.scrub_css_attribute(node); end

  def self.scrub_uri_attribute(attr_node); end
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::HtmlDocumentBehavior
  def serialize_root(); end
end

module Loofah::HtmlDocumentBehavior::ClassMethods
  def parse(*args, &block); end
end

module Loofah::HtmlDocumentBehavior
  def self.included(base); end
end

module Loofah::HtmlFragmentBehavior
  def serialize(); end

  def serialize_root(); end

  def to_s(); end
end

module Loofah::HtmlFragmentBehavior::ClassMethods
  def document_klass(); end

  def parse(tags, encoding=T.unsafe(nil)); end
end

module Loofah::HtmlFragmentBehavior
  def self.included(base); end
end

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

module Loofah::MetaHelpers
  def self.add_downcased_set_members_to_all_set_constants(mojule); end
end

module Loofah::ScrubBehavior::Node
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::NodeSet
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior
  def self.resolve_scrubber(scrubber); end
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubbers::Escape
  def initialize(); end
end

class Loofah::Scrubbers::NewlineBlockElements
  def initialize(); end
end

class Loofah::Scrubbers::NoFollow
  def initialize(); end
end

class Loofah::Scrubbers::NoOpener
  def initialize(); end
end

class Loofah::Scrubbers::NoReferrer
  def initialize(); end
end

class Loofah::Scrubbers::Prune
  def initialize(); end
end

class Loofah::Scrubbers::Strip
  def initialize(); end
end

class Loofah::Scrubbers::TargetBlank
  def initialize(); end
end

class Loofah::Scrubbers::Unprintable
  def initialize(); end
end

class Loofah::Scrubbers::Whitewash
  def initialize(); end
end

module Loofah::Scrubbers
  def self.scrubber_symbols(); end
end

module Loofah::TextBehavior
  def inner_text(options=T.unsafe(nil)); end

  def text(options=T.unsafe(nil)); end

  def to_str(options=T.unsafe(nil)); end

  def to_text(options=T.unsafe(nil)); end
end

class Loofah::XML::DocumentFragment
  def self.parse(tags); end
end

module Loofah
  def self.document(*args, &block); end

  def self.fragment(*args, &block); end

  def self.html4_document(*args, &block); end

  def self.html4_fragment(*args, &block); end

  def self.html5_document(*args, &block); end

  def self.html5_fragment(*args, &block); end

  def self.html5_support?(); end

  def self.remove_extraneous_whitespace(string); end

  def self.scrub_document(string_or_io, method); end

  def self.scrub_fragment(string_or_io, method); end

  def self.scrub_html4_document(string_or_io, method); end

  def self.scrub_html4_fragment(string_or_io, method); end

  def self.scrub_html5_document(string_or_io, method); end

  def self.scrub_html5_fragment(string_or_io, method); end

  def self.scrub_xml_document(string_or_io, method); end

  def self.scrub_xml_fragment(string_or_io, method); end

  def self.xml_document(*args, &block); end

  def self.xml_fragment(*args, &block); end
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::BccField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommonField
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LAX_CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNFOLD_WS = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Envelope
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FromField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::LoggerDelivery
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

class Mail::Message
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
  def self.parse(string); end
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte::Unicode
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::PartsList
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def deliver!(mail); end

  def destinations_for(envelope); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SmtpEnvelope
  def from(); end

  def from=(addr); end

  def initialize(mail); end

  def message(); end

  def message=(message); end

  def to(); end

  def to=(addr); end
  MAX_ADDRESS_BYTESIZE = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Marcel
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  MAGIC = ::T.let(nil, ::T.untyped)
  TYPE_EXTS = ::T.let(nil, ::T.untyped)
  TYPE_PARENTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class MatchData
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

class MessagePack::HeldBuffer
end

class MessagePack::HeldBuffer
end

module MessagePack::Time
  Packer = ::T.let(nil, ::T.untyped)
  TIME_AT_3_AVAILABLE = ::T.let(nil, ::T.untyped)
  Unpacker = ::T.let(nil, ::T.untyped)
end

class MessagePack::Timestamp
  TIMESTAMP32_MAX_SEC = ::T.let(nil, ::T.untyped)
  TIMESTAMP64_MAX_SEC = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  def initialize(); end
end

class Mime::Mimes
  def <<(type); end

  def delete_if(); end

  def each(&block); end

  def symbols(); end
end

class Mime::NullType
  def ref(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def match?(mime_type); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type, &block); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

MiniMime::Db::PReadFile = File

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Minitest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
  RE = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def _synchronize(); end

  def _where(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_pattern(); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_pattern(); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), _ignored=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end

  def initialize(regexp=T.unsafe(nil)); end

  def regexp(); end

  def regexp=(regexp); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

module Minitest::Compress
  def compress(orig); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
  BASE_DIR = ::T.let(nil, ::T.untyped)
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Result
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def metadata(); end

  def metadata=(metadata); end

  def metadata?(); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.test_order(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end

  def warnings(); end

  def warnings=(warnings); end
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::Test
  def capture_exceptions(); end

  def neuter_exception(e); end

  def new_exception(klass, msg, bt, kill=T.unsafe(nil)); end

  def sanitize_exception(e); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  SETUP_METHODS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

class Minitest::Test
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
  BASE_RE = ::T.let(nil, ::T.untyped)
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.allow_fork(); end

  def self.allow_fork=(allow_fork); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.cattr_accessor(name); end

  def self.clock_time(); end

  def self.empty_run!(options); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.register_plugin(name_or_mod); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end

  def self.seed(); end

  def self.seed=(seed); end
end

class Module
  def anonymous?(); end

  def thread_cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def undefined_instance_methods(); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, prepend: T.unsafe(nil), &block); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module NIO
  ENGINE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class NIO::ByteBuffer
  include ::Enumerable
  def <<(arg); end

  def [](arg); end

  def capacity(); end

  def clear(); end

  def each(&blk); end

  def flip(); end

  def full?(); end

  def get(*arg); end

  def initialize(arg); end

  def limit(); end

  def limit=(limit); end

  def mark(); end

  def position(); end

  def position=(position); end

  def read_from(arg); end

  def remaining(); end

  def reset(); end

  def rewind(); end

  def size(); end

  def write_to(arg); end
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer
end

class NIO::Monitor
  def add_interest(arg); end

  def close(*arg); end

  def closed?(); end

  def initialize(arg, arg1, arg2); end

  def interests(); end

  def interests=(interests); end

  def io(); end

  def readable?(); end

  def readiness(); end

  def remove_interest(arg); end

  def selector(); end

  def value(); end

  def value=(value); end

  def writable?(); end

  def writeable?(); end
end

class NIO::Monitor
end

class NIO::Selector
  def backend(); end

  def close(); end

  def closed?(); end

  def deregister(arg); end

  def empty?(); end

  def initialize(*arg); end

  def register(arg, arg1); end

  def registered?(arg); end

  def wakeup(); end
end

class NIO::Selector
  def self.backends(); end
end

module NIO
  def self.engine(); end

  def self.pure?(env=T.unsafe(nil)); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::HTTP
  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def write_timeout(); end

  def write_timeout=(sec); end
  VERSION = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPClientException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse
  def body_encoding(); end

  def body_encoding=(value); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end
end

class Net::HTTPResponse::Inflater
  def bytes_inflated(); end
end

Net::HTTPResponseReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  include ::Net::IMAP::DeprecatedClientOptions
  def auth_capable?(mechanism); end

  def auth_mechanisms(); end

  def capabilities(); end

  def capabilities_cached?(); end

  def capability?(capability); end

  def capable?(capability); end

  def clear_cached_capabilities(); end

  def clear_responses(type=T.unsafe(nil)); end

  def config(); end

  def enable(*capabilities); end

  def host(); end

  def id(client_id=T.unsafe(nil)); end

  def idle_response_timeout(); end

  def logout!(); end

  def namespace(); end

  def open_timeout(); end

  def port(); end

  def ssl_ctx(); end

  def ssl_ctx_params(); end

  def tls_verified?(); end

  def uid_expunge(uid_set); end

  def unselect(); end
  ALL = ::T.let(nil, ::T.untyped)
  ARCHIVE = ::T.let(nil, ::T.untyped)
  DRAFTS = ::T.let(nil, ::T.untyped)
  ENABLE_ALIASES = ::T.let(nil, ::T.untyped)
  HASCHILDREN = ::T.let(nil, ::T.untyped)
  HASNOCHILDREN = ::T.let(nil, ::T.untyped)
  HAS_CHILDREN = ::T.let(nil, ::T.untyped)
  HAS_NO_CHILDREN = ::T.let(nil, ::T.untyped)
  JUNK = ::T.let(nil, ::T.untyped)
  NONEXISTENT = ::T.let(nil, ::T.untyped)
  NO_INFERIORS = ::T.let(nil, ::T.untyped)
  NO_SELECT = ::T.let(nil, ::T.untyped)
  REMOTE = ::T.let(nil, ::T.untyped)
  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
  SENT = ::T.let(nil, ::T.untyped)
  STRFDATE = ::T.let(nil, ::T.untyped)
  STRFTIME = ::T.let(nil, ::T.untyped)
  SUBSCRIBED = ::T.let(nil, ::T.untyped)
  TRASH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::Authenticators
  def add_authenticator(*arg, **arg1, &arg2); end

  def authenticator(*arg, **arg1, &arg2); end
end

module Net::IMAP::Authenticators
end

module Net::IMAP::BodyStructure
end

module Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeBasic
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeMessage
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeMultipart
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeText
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::ClientID
  def initialize(data); end

  def send_data(imap, tag); end

  def validate(); end
end

class Net::IMAP::ClientID
end

class Net::IMAP::Config
  include ::Net::IMAP::Config::AttrAccessors
  include ::Net::IMAP::Config::AttrInheritance
  include ::Net::IMAP::Config::AttrTypeCoercion
  def defaults_hash(); end

  def initialize(parent=T.unsafe(nil), **attrs); end

  def load_defaults(version); end

  def to_h(); end

  def update(**attrs); end

  def with(**attrs); end
end

module Net::IMAP::Config::AttrAccessors
  def data(); end

  def debug(*args, **arg, &block); end

  def debug=(*args, **arg, &block); end

  def freeze(); end

  def idle_response_timeout(*args, **arg, &block); end

  def idle_response_timeout=(*args, **arg, &block); end

  def initialize(); end

  def open_timeout(*args, **arg, &block); end

  def open_timeout=(*args, **arg, &block); end

  def responses_without_block(*args, **arg, &block); end

  def responses_without_block=(*args, **arg, &block); end

  def sasl_ir(*args, **arg, &block); end

  def sasl_ir=(*args, **arg, &block); end
end

class Net::IMAP::Config::AttrAccessors::Struct
  def debug(); end

  def debug=(_); end

  def idle_response_timeout(); end

  def idle_response_timeout=(_); end

  def open_timeout(); end

  def open_timeout=(_); end

  def responses_without_block(); end

  def responses_without_block=(_); end

  def sasl_ir(); end

  def sasl_ir=(_); end
end

class Net::IMAP::Config::AttrAccessors::Struct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Net::IMAP::Config::AttrAccessors
  extend ::Forwardable
  def self.attr_accessor(name); end

  def self.struct(); end
end

module Net::IMAP::Config::AttrInheritance
  def debug(); end

  def idle_response_timeout(); end

  def inherited?(attr); end

  def initialize(parent=T.unsafe(nil)); end

  def new(**attrs); end

  def open_timeout(); end

  def parent(); end

  def reset(attr=T.unsafe(nil)); end

  def responses_without_block(); end

  def sasl_ir(); end
end

module Net::IMAP::Config::AttrInheritance
  def self.attr_accessor(name); end
end

module Net::IMAP::Config::AttrTypeCoercion
  def debug=(val); end

  def debug?(); end

  def idle_response_timeout=(val); end

  def open_timeout=(val); end

  def responses_without_block=(val); end

  def sasl_ir=(val); end

  def sasl_ir?(); end
end

module Net::IMAP::Config::AttrTypeCoercion
  def self.attr_accessor(attr, type: T.unsafe(nil)); end

  def self.boolean(attr); end

  def self.enum(attr, enum); end

  def self.integer(attr); end
end

class Net::IMAP::Config
  def self.[](config); end

  def self.default(); end

  def self.global(); end

  def self.version_defaults(); end
end

module Net::IMAP::DeprecatedClientOptions
  def initialize(host, port_or_options=T.unsafe(nil), *deprecated, **options); end

  def starttls(*deprecated, **options); end
end

module Net::IMAP::DeprecatedClientOptions
end

class Net::IMAP::ExtensionData
end

class Net::IMAP::ExtensionData
end

class Net::IMAP::FetchData
  def attr_upcase(); end

  def binary(*part_nums, offset: T.unsafe(nil)); end

  def binary_size(*part_nums); end

  def body(); end

  def body_structure(); end

  def bodystructure(); end

  def emailid(); end

  def envelope(); end

  def flags(); end

  def header(*part_nums, fields: T.unsafe(nil), except: T.unsafe(nil), offset: T.unsafe(nil)); end

  def header_fields(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end

  def header_fields_not(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end

  def internal_date(); end

  def internaldate(); end

  def message(offset: T.unsafe(nil)); end

  def mime(part, *subparts, offset: T.unsafe(nil)); end

  def modseq(); end

  def part(index, *subparts, offset: T.unsafe(nil)); end

  def rfc822(); end

  def rfc822_header(); end

  def rfc822_size(); end

  def rfc822_text(); end

  def text(*part, offset: T.unsafe(nil)); end

  def threadid(); end

  def uid(); end
end

class Net::IMAP::IgnoredResponse
end

class Net::IMAP::IgnoredResponse
end

class Net::IMAP::InvalidResponseError
end

class Net::IMAP::InvalidResponseError
end

class Net::IMAP::Namespace
end

class Net::IMAP::Namespace
end

class Net::IMAP::Namespaces
end

class Net::IMAP::Namespaces
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

class Net::IMAP::ResponseParser
  include ::Net::IMAP::ResponseParser::ParserUtils
  include ::Net::IMAP::ResponseParser::ResponseConditions
  def CRLF!(); end

  def CRLF?(); end

  def EOF!(); end

  def EOF?(); end

  def NIL!(); end

  def NIL?(); end

  def PLUS!(); end

  def PLUS?(); end

  def SP!(); end

  def SP?(); end

  def STAR!(); end

  def STAR?(); end

  def body_fld_enc(); end

  def body_fld_lines(); end

  def body_fld_octets(); end

  def case_insensitive__string(); end

  def case_insensitive__string?(); end

  def config(); end

  def date_time(); end

  def lbra(); end

  def lbra?(); end

  def lookahead_CRLF!(); end

  def lookahead_EOF!(); end

  def lookahead_NIL!(); end

  def lookahead_PLUS?(); end

  def lookahead_SP?(); end

  def lookahead_STAR?(); end

  def lookahead_body?(); end

  def lookahead_case_insensitive__string!(); end

  def lookahead_lbra?(); end

  def lookahead_lpar?(); end

  def lookahead_number!(); end

  def lookahead_quoted!(); end

  def lookahead_rbra?(); end

  def lookahead_rpar?(); end

  def lookahead_string!(); end

  def lookahead_string8!(); end

  def lookahead_tagged_ext_label!(); end

  def lookahead_thread_list?(); end

  def lookahead_thread_nested?(); end

  def lpar(); end

  def lpar?(); end

  def media_subtype(); end

  def mod_sequence_value(); end

  def mod_sequence_valzer(); end

  def number(); end

  def number64(); end

  def number64?(); end

  def number?(); end

  def nz_number(); end

  def nz_number64(); end

  def nz_number?(); end

  def peek_PLUS?(); end

  def peek_SP?(); end

  def peek_STAR?(); end

  def peek_lbra?(); end

  def peek_lpar?(); end

  def peek_rbra?(); end

  def peek_rpar?(); end

  def permsg_modsequence(); end

  def quirky_SP?(); end

  def quoted(); end

  def quoted?(); end

  def rbra(); end

  def rbra?(); end

  def rpar(); end

  def rpar?(); end

  def string(); end

  def string8(); end

  def string8?(); end

  def string?(); end

  def tagged_ext_label(); end

  def tagged_ext_label?(); end

  def uniqueid(); end

  def x_gm_id(); end
  ASTRING_CHARS_TOKENS = ::T.let(nil, ::T.untyped)
  ASTRING_TOKENS = ::T.let(nil, ::T.untyped)
  RE_RESPONSE_TYPE = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_TOKENS = ::T.let(nil, ::T.untyped)
  T_LITERAL8 = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::ParserUtils
end

module Net::IMAP::ResponseParser::ParserUtils::Generator
  def def_char_matchers(name, char, token); end

  def def_token_matchers(name, *token_symbols, coerce: T.unsafe(nil), send: T.unsafe(nil)); end
  LOOKAHEAD = ::T.let(nil, ::T.untyped)
  SHIFT_TOKEN = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::ParserUtils::Generator
end

module Net::IMAP::ResponseParser::ParserUtils
end

module Net::IMAP::ResponseParser::Patterns
  include ::Net::IMAP::ResponseParser::Patterns::RFC5234
  include ::Net::IMAP::ResponseParser::Patterns::RFC3629
  ASTRING_CHAR = ::T.let(nil, ::T.untyped)
  ASTRING_CHARS = ::T.let(nil, ::T.untyped)
  ASTRING_SPECIALS = ::T.let(nil, ::T.untyped)
  ATOM = ::T.let(nil, ::T.untyped)
  ATOMISH = ::T.let(nil, ::T.untyped)
  ATOM_CHAR = ::T.let(nil, ::T.untyped)
  ATOM_SPECIALS = ::T.let(nil, ::T.untyped)
  CHAR8 = ::T.let(nil, ::T.untyped)
  CODE_TEXT = ::T.let(nil, ::T.untyped)
  CODE_TEXT_CHAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  FLAG_EXTENSION = ::T.let(nil, ::T.untyped)
  FLAG_KEYWORD = ::T.let(nil, ::T.untyped)
  FLAG_LIST = ::T.let(nil, ::T.untyped)
  FLAG_PERM = ::T.let(nil, ::T.untyped)
  FLAG_PERM_LIST = ::T.let(nil, ::T.untyped)
  LIST_WILDCARDS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LITERAL8 = ::T.let(nil, ::T.untyped)
  MBX_FLAG = ::T.let(nil, ::T.untyped)
  MBX_LIST_FLAGS = ::T.let(nil, ::T.untyped)
  NZ_NUMBER = ::T.let(nil, ::T.untyped)
  QUIRKY_FLAG = ::T.let(nil, ::T.untyped)
  QUIRKY_FLAGS_LIST = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_esc = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_rev1 = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_rev2 = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_safe = ::T.let(nil, ::T.untyped)
  QUOTED_SPECIALS = ::T.let(nil, ::T.untyped)
  QUOTED_rev1 = ::T.let(nil, ::T.untyped)
  QUOTED_rev2 = ::T.let(nil, ::T.untyped)
  RESP_SPECIALS = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET_ITEM = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET_STR = ::T.let(nil, ::T.untyped)
  SEQ_NUMBER = ::T.let(nil, ::T.untyped)
  SEQ_RANGE = ::T.let(nil, ::T.untyped)
  TAG = ::T.let(nil, ::T.untyped)
  TAGGED_EXT_LABEL = ::T.let(nil, ::T.untyped)
  TAGGED_LABEL_CHAR = ::T.let(nil, ::T.untyped)
  TAGGED_LABEL_FCHAR = ::T.let(nil, ::T.untyped)
  TEXT_CHAR = ::T.let(nil, ::T.untyped)
  TEXT_rev1 = ::T.let(nil, ::T.untyped)
  TEXT_rev2 = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::Patterns::CharClassSubtraction
end

module Net::IMAP::ResponseParser::Patterns::CharClassSubtraction
end

module Net::IMAP::ResponseParser::Patterns::RFC3629
  UTF8_1 = ::T.let(nil, ::T.untyped)
  UTF8_2 = ::T.let(nil, ::T.untyped)
  UTF8_3 = ::T.let(nil, ::T.untyped)
  UTF8_4 = ::T.let(nil, ::T.untyped)
  UTF8_CHAR = ::T.let(nil, ::T.untyped)
  UTF8_OCTETS = ::T.let(nil, ::T.untyped)
  UTF8_TAIL = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::Patterns::RFC3629
end

module Net::IMAP::ResponseParser::Patterns::RFC5234
  ALPHA = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CTL = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DQUOTE = ::T.let(nil, ::T.untyped)
  HEXDIG = ::T.let(nil, ::T.untyped)
  OCTET = ::T.let(nil, ::T.untyped)
  SP = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::Patterns::RFC5234
end

module Net::IMAP::ResponseParser::Patterns
  def self.unescape_quoted(quoted); end

  def self.unescape_quoted!(quoted); end
end

module Net::IMAP::ResponseParser::ResponseConditions
  AUTH_CONDS = ::T.let(nil, ::T.untyped)
  BAD = ::T.let(nil, ::T.untyped)
  BYE = ::T.let(nil, ::T.untyped)
  GREETING_CONDS = ::T.let(nil, ::T.untyped)
  NO = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PREAUTH = ::T.let(nil, ::T.untyped)
  RESP_CONDS = ::T.let(nil, ::T.untyped)
  RESP_COND_STATES = ::T.let(nil, ::T.untyped)
  RESP_DATA_CONDS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::ResponseConditions
end

class Net::IMAP::ResponseParser::Token
  def self.keyword_init?(); end
end

class Net::IMAP::ResponseParser
  extend ::Net::IMAP::ResponseParser::ParserUtils::Generator
end

class Net::IMAP::ResponseText
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::SASL
end

class Net::IMAP::SASL::AnonymousAuthenticator
  def anonymous_message(); end

  def done?(); end

  def initial_response?(); end

  def initialize(anon_msg=T.unsafe(nil), anonymous_message: T.unsafe(nil), **arg); end

  def process(_server_challenge_string); end
end

class Net::IMAP::SASL::AnonymousAuthenticator
end

class Net::IMAP::SASL::AuthenticationCanceled
end

class Net::IMAP::SASL::AuthenticationCanceled
end

class Net::IMAP::SASL::AuthenticationError
end

class Net::IMAP::SASL::AuthenticationError
end

class Net::IMAP::SASL::AuthenticationExchange
  def authenticate(); end

  def authenticator(); end

  def done?(); end

  def initialize(client, mechanism, authenticator, sasl_ir: T.unsafe(nil)); end

  def mechanism(); end

  def send_initial_response?(); end
end

class Net::IMAP::SASL::AuthenticationExchange
  def self.authenticate(*arg, **arg1, &arg2); end

  def self.build(client, mechanism, *args, sasl_ir: T.unsafe(nil), **kwargs, &block); end
end

class Net::IMAP::SASL::AuthenticationFailed
end

class Net::IMAP::SASL::AuthenticationFailed
end

class Net::IMAP::SASL::AuthenticationIncomplete
  def initialize(response, message=T.unsafe(nil)); end

  def response(); end
end

class Net::IMAP::SASL::AuthenticationIncomplete
end

class Net::IMAP::SASL::Authenticators
  def add_authenticator(name, authenticator=T.unsafe(nil)); end

  def authenticator(mechanism, *arg, **arg1, &arg2); end

  def initialize(use_defaults: T.unsafe(nil), use_deprecated: T.unsafe(nil)); end

  def mechanism?(name); end

  def names(); end

  def new(mechanism, *arg, **arg1, &arg2); end

  def remove_authenticator(name); end
end

class Net::IMAP::SASL::Authenticators
end

Net::IMAP::SASL::BidiStringError = Net::IMAP::StringPrep::BidiStringError

class Net::IMAP::SASL::ClientAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def auth_capable?(mechanism); end

  def authenticate(*arg, **arg1, &arg2); end

  def client(); end

  def command_proc(); end

  def drop_connection(); end

  def drop_connection!(); end

  def initialize(client, &command_proc); end

  def response_errors(); end

  def run_command(mechanism, initial_response=T.unsafe(nil), &block); end

  def sasl_ir_capable?(); end
end

class Net::IMAP::SASL::ClientAdapter
end

class Net::IMAP::SASL::CramMD5Authenticator
  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **arg); end

  def process(challenge); end
end

class Net::IMAP::SASL::CramMD5Authenticator
end

class Net::IMAP::SASL::DigestMD5Authenticator
  def authcid(); end

  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authz=T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **arg); end

  def password(); end

  def process(challenge); end

  def username(); end
end

class Net::IMAP::SASL::DigestMD5Authenticator
end

class Net::IMAP::SASL::Error
end

class Net::IMAP::SASL::Error
end

class Net::IMAP::SASL::ExternalAuthenticator
  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), authzid: T.unsafe(nil), username: T.unsafe(nil), **arg); end

  def process(_); end

  def username(); end
end

class Net::IMAP::SASL::ExternalAuthenticator
end

module Net::IMAP::SASL::GS2Header
  def gs2_authzid(); end

  def gs2_cb_flag(); end

  def gs2_header(); end
  NO_NULL_CHARS = ::T.let(nil, ::T.untyped)
  RFC5801_SASLNAME = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::SASL::GS2Header
  def self.gs2_saslname_encode(str); end
end

class Net::IMAP::SASL::LoginAuthenticator
  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **arg); end

  def process(data); end
end

class Net::IMAP::SASL::LoginAuthenticator
end

class Net::IMAP::SASL::OAuthAuthenticator
  include ::Net::IMAP::SASL::GS2Header
  def authorization(); end

  def authzid(); end

  def done?(); end

  def host(); end

  def initial_client_response(); end

  def initialize(authzid: T.unsafe(nil), host: T.unsafe(nil), port: T.unsafe(nil), username: T.unsafe(nil), query: T.unsafe(nil), mthd: T.unsafe(nil), path: T.unsafe(nil), post: T.unsafe(nil), qs: T.unsafe(nil), **arg); end

  def last_server_response(); end

  def mthd(); end

  def path(); end

  def port(); end

  def post(); end

  def process(data); end

  def qs(); end

  def query(); end

  def username(); end
end

class Net::IMAP::SASL::OAuthAuthenticator
end

class Net::IMAP::SASL::OAuthBearerAuthenticator
  def initial_response?(); end

  def initialize(arg1=T.unsafe(nil), arg2=T.unsafe(nil), oauth2_token: T.unsafe(nil), secret: T.unsafe(nil), **args, &blk); end

  def oauth2_token(); end

  def secret(); end
end

class Net::IMAP::SASL::OAuthBearerAuthenticator
end

class Net::IMAP::SASL::PlainAuthenticator
  def authcid(); end

  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), **arg); end

  def password(); end

  def process(data); end

  def secret(); end

  def username(); end
end

class Net::IMAP::SASL::PlainAuthenticator
end

Net::IMAP::SASL::ProhibitedCodepoint = Net::IMAP::StringPrep::ProhibitedCodepoint

module Net::IMAP::SASL::ProtocolAdapters
end

module Net::IMAP::SASL::ProtocolAdapters::Generic
  def cancel_response(); end

  def command_name(); end

  def decode(string); end

  def encode(string); end

  def encode_ir(string); end

  def host(); end

  def port(); end

  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::Generic
end

module Net::IMAP::SASL::ProtocolAdapters::IMAP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::IMAP
end

module Net::IMAP::SASL::ProtocolAdapters::POP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def command_name(); end

  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::POP
end

module Net::IMAP::SASL::ProtocolAdapters::SMTP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def command_name(); end

  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::SMTP
end

module Net::IMAP::SASL::ProtocolAdapters
end

Net::IMAP::SASL::SASLprep = Net::IMAP::StringPrep::SASLprep

module Net::IMAP::SASL::ScramAlgorithm
  def H(str); end

  def HMAC(key, data); end

  def Hi(str, salt, iterations); end

  def Normalize(str); end

  def XOR(str1, str2); end

  def auth_message(); end

  def client_key(); end

  def client_proof(); end

  def client_signature(); end

  def salted_password(); end

  def server_key(); end

  def server_signature(); end

  def stored_key(); end
end

module Net::IMAP::SASL::ScramAlgorithm
end

class Net::IMAP::SASL::ScramAuthenticator
  include ::Net::IMAP::SASL::GS2Header
  include ::Net::IMAP::SASL::ScramAlgorithm
  def authcid(); end

  def authzid(); end

  def cbind_input(); end

  def cnonce(); end

  def digest(); end

  def done?(); end

  def initial_client_response(); end

  def initialize(username_arg=T.unsafe(nil), password_arg=T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), authzid: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), min_iterations: T.unsafe(nil), cnonce: T.unsafe(nil), **options); end

  def iterations(); end

  def min_iterations(); end

  def password(); end

  def process(challenge); end

  def salt(); end

  def secret(); end

  def server_error(); end

  def snonce(); end

  def username(); end
end

class Net::IMAP::SASL::ScramAuthenticator
end

class Net::IMAP::SASL::ScramSHA1Authenticator
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SASL::ScramSHA1Authenticator
end

class Net::IMAP::SASL::ScramSHA256Authenticator
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SASL::ScramSHA256Authenticator
end

Net::IMAP::SASL::StringPrep = Net::IMAP::StringPrep

Net::IMAP::SASL::StringPrepError = Net::IMAP::StringPrep::StringPrepError

class Net::IMAP::SASL::XOAuth2Authenticator
  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), token=T.unsafe(nil), username: T.unsafe(nil), oauth2_token: T.unsafe(nil), authzid: T.unsafe(nil), secret: T.unsafe(nil), **arg); end

  def oauth2_token(); end

  def process(_data); end

  def secret(); end

  def username(); end
end

class Net::IMAP::SASL::XOAuth2Authenticator
end

module Net::IMAP::SASL
  def self.add_authenticator(*arg, **arg1, &arg2); end

  def self.authenticator(*args, registry: T.unsafe(nil), **kwargs, &block); end

  def self.authenticators(); end

  def self.saslprep(string, **opts); end
end

class Net::IMAP::SASLAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::IMAP
  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SASLAdapter
end

class Net::IMAP::SearchResult
  def ==(other); end

  def eql?(other); end

  def initialize(seq_nums, modseq: T.unsafe(nil)); end

  def modseq(); end

  def pretty_print(pp); end

  def to_s(type=T.unsafe(nil)); end

  def to_sequence_set(); end
end

class Net::IMAP::SearchResult
  def self.[](*seq_nums, modseq: T.unsafe(nil)); end
end

class Net::IMAP::SequenceSet
  def &(other); end

  def +(other); end

  def -(other); end

  def <<(object); end

  def ==(other); end

  def ===(other); end

  def [](index, length=T.unsafe(nil)); end

  def ^(other); end

  def add(object); end

  def add?(object); end

  def append(object); end

  def at(index); end

  def clear(); end

  def complement(); end

  def complement!(); end

  def count(); end

  def cover?(other); end

  def delete(object); end

  def delete?(object); end

  def delete_at(index); end

  def difference(other); end

  def disjoint?(other); end

  def each_element(); end

  def each_entry(&block); end

  def each_number(&block); end

  def each_range(); end

  def elements(); end

  def empty?(); end

  def entries(); end

  def eql?(other); end

  def find_index(number); end

  def full?(); end

  def include?(element); end

  def include_star?(); end

  def initialize(input=T.unsafe(nil)); end

  def intersect?(other); end

  def intersection(other); end

  def limit(max:); end

  def limit!(max:); end

  def max(star: T.unsafe(nil)); end

  def member?(element); end

  def merge(*inputs); end

  def min(star: T.unsafe(nil)); end

  def minmax(star: T.unsafe(nil)); end

  def normalize(); end

  def normalize!(); end

  def normalized_string(); end

  def numbers(); end

  def overlap?(other); end

  def ranges(); end

  def replace(other); end

  def send_data(imap, tag); end

  def size(); end

  def slice(index, length=T.unsafe(nil)); end

  def slice!(index, length=T.unsafe(nil)); end

  def string(); end

  def string=(str); end

  def subtract(*objects); end

  def to_a(); end

  def to_sequence_set(); end

  def to_set(); end

  def tuples(); end

  def union(other); end

  def valid?(); end

  def valid_string(); end

  def validate(); end

  def xor(other); end

  def |(other); end

  def ~(); end
  UINT32_MAX = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SequenceSet
  def self.[](first, *rest); end

  def self.empty(); end

  def self.full(); end

  def self.try_convert(obj); end
end

module Net::IMAP::StringFormatter
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringFormatter
  def self.nstring(str); end

  def self.string(str); end

  def self.valid_nstring?(str); end

  def self.valid_string?(str); end
end

module Net::IMAP::StringPrep
end

class Net::IMAP::StringPrep::BidiStringError
end

class Net::IMAP::StringPrep::BidiStringError
end

module Net::IMAP::StringPrep::NamePrep
  CHECK_BIDI = ::T.let(nil, ::T.untyped)
  MAPPING_TABLES = ::T.let(nil, ::T.untyped)
  NORMALIZATION = ::T.let(nil, ::T.untyped)
  PROHIBITED_TABLES = ::T.let(nil, ::T.untyped)
  STRINGPREP_PROFILE = ::T.let(nil, ::T.untyped)
  UNASSIGNED_TABLE = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::NamePrep
  def self.nameprep(string, **opts); end
end

class Net::IMAP::StringPrep::ProhibitedCodepoint
  def initialize(table, *args, **kwargs); end

  def table(); end
end

class Net::IMAP::StringPrep::ProhibitedCodepoint
end

module Net::IMAP::StringPrep::SASLprep
  ASCII_NO_CTRLS = ::T.let(nil, ::T.untyped)
  BIDI_FAILURE = ::T.let(nil, ::T.untyped)
  MAP_TO_NOTHING = ::T.let(nil, ::T.untyped)
  MAP_TO_SPACE = ::T.let(nil, ::T.untyped)
  PROHIBITED = ::T.let(nil, ::T.untyped)
  PROHIBITED_OUTPUT = ::T.let(nil, ::T.untyped)
  PROHIBITED_OUTPUT_STORED = ::T.let(nil, ::T.untyped)
  PROHIBITED_STORED = ::T.let(nil, ::T.untyped)
  TABLES_PROHIBITED = ::T.let(nil, ::T.untyped)
  TABLES_PROHIBITED_STORED = ::T.let(nil, ::T.untyped)
  UNASSIGNED = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::SASLprep
  def self.saslprep(str, stored: T.unsafe(nil), exception: T.unsafe(nil)); end
end

class Net::IMAP::StringPrep::StringPrepError
  def initialize(*args, string: T.unsafe(nil), profile: T.unsafe(nil)); end

  def profile(); end

  def string(); end
end

class Net::IMAP::StringPrep::StringPrepError
end

module Net::IMAP::StringPrep::Tables
  BIDI_DESC_REQ2 = ::T.let(nil, ::T.untyped)
  BIDI_DESC_REQ3 = ::T.let(nil, ::T.untyped)
  BIDI_FAILS_REQ2 = ::T.let(nil, ::T.untyped)
  BIDI_FAILS_REQ3 = ::T.let(nil, ::T.untyped)
  BIDI_FAILURE = ::T.let(nil, ::T.untyped)
  IN_A_1 = ::T.let(nil, ::T.untyped)
  IN_B_1 = ::T.let(nil, ::T.untyped)
  IN_B_2 = ::T.let(nil, ::T.untyped)
  IN_B_3 = ::T.let(nil, ::T.untyped)
  IN_C_1_1 = ::T.let(nil, ::T.untyped)
  IN_C_1_2 = ::T.let(nil, ::T.untyped)
  IN_C_2_1 = ::T.let(nil, ::T.untyped)
  IN_C_2_2 = ::T.let(nil, ::T.untyped)
  IN_C_3 = ::T.let(nil, ::T.untyped)
  IN_C_4 = ::T.let(nil, ::T.untyped)
  IN_C_5 = ::T.let(nil, ::T.untyped)
  IN_C_6 = ::T.let(nil, ::T.untyped)
  IN_C_7 = ::T.let(nil, ::T.untyped)
  IN_C_8 = ::T.let(nil, ::T.untyped)
  IN_C_9 = ::T.let(nil, ::T.untyped)
  IN_D_1 = ::T.let(nil, ::T.untyped)
  IN_D_1_NEGATED = ::T.let(nil, ::T.untyped)
  IN_D_2 = ::T.let(nil, ::T.untyped)
  MAPPINGS = ::T.let(nil, ::T.untyped)
  MAP_B_1 = ::T.let(nil, ::T.untyped)
  MAP_B_2 = ::T.let(nil, ::T.untyped)
  MAP_B_3 = ::T.let(nil, ::T.untyped)
  REGEXPS = ::T.let(nil, ::T.untyped)
  TITLES = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::Tables
end

module Net::IMAP::StringPrep::Trace
  CHECK_BIDI = ::T.let(nil, ::T.untyped)
  MAPPING_TABLES = ::T.let(nil, ::T.untyped)
  NORMALIZATION = ::T.let(nil, ::T.untyped)
  PROHIBITED_TABLES = ::T.let(nil, ::T.untyped)
  STRINGPREP_PROFILE = ::T.let(nil, ::T.untyped)
  UNASSIGNED_TABLE = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::Trace
  def self.stringprep_trace(string, **opts); end
end

module Net::IMAP::StringPrep
  def self.[](table); end

  def self.check_bidi!(string, c_8: T.unsafe(nil), profile: T.unsafe(nil)); end

  def self.check_prohibited!(string, *tables, bidi: T.unsafe(nil), unassigned: T.unsafe(nil), stored: T.unsafe(nil), profile: T.unsafe(nil)); end

  def self.map_tables!(string, *tables); end

  def self.stringprep(string, maps:, normalization:, prohibited:, **opts); end
end

class Net::IMAP::ThreadMember
  def all_seqnos(node=T.unsafe(nil)); end

  def to_sequence_set(); end
end

class Net::IMAP::UIDPlusData
  def uid_mapping(); end
end

class Net::IMAP::UIDPlusData
end

class Net::IMAP::UnknownResponseError
end

class Net::IMAP::UnknownResponseError
end

class Net::IMAP::UnparsedData
end

class Net::IMAP::UnparsedData
end

class Net::IMAP::UnparsedNumericResponseData
end

class Net::IMAP::UnparsedNumericResponseData
end

Net::IMAP::XOauth2Authenticator = Net::IMAP::SASL::XOAuth2Authenticator

class Net::IMAP
  extend ::Net::IMAP::Authenticators
  def self.config(); end

  def self.decode_date(string); end

  def self.decode_datetime(string); end

  def self.decode_time(string); end

  def self.encode_date(date); end

  def self.encode_datetime(time); end

  def self.encode_time(time); end

  def self.format_time(time); end

  def self.parse_date(string); end

  def self.parse_datetime(string); end

  def self.parse_time(string); end

  def self.saslprep(string, **opts); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::SMTP
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::SMTP::AuthCramMD5
  CRAM_BUFSIZE = ::T.let(nil, ::T.untyped)
  IMASK = ::T.let(nil, ::T.untyped)
  OMASK = ::T.let(nil, ::T.untyped)
end

Net::SMTPSession = Net::SMTP

class NilClass
  def =~(arg); end

  def to_d(); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

module Nokogiri
  LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  LIBXML_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_MEMORY_MANAGEMENT = ::T.let(nil, ::T.untyped)
  LIBXSLT_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_DATETIME_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXSLT_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  OTHER_LIBRARY_VERSIONS = ::T.let(nil, ::T.untyped)
  PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  PRECOMPILED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  CACHE_SWITCH_NAME = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::XPathVisitor
  WILDCARD_NAMESPACES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS::XPathVisitor::BuiltinsConfig
  ALWAYS = ::T.let(nil, ::T.untyped)
  NEVER = ::T.let(nil, ::T.untyped)
  OPTIMAL = ::T.let(nil, ::T.untyped)
  VALUES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS::XPathVisitor::DoctypeConfig
  HTML4 = ::T.let(nil, ::T.untyped)
  HTML5 = ::T.let(nil, ::T.untyped)
  VALUES = ::T.let(nil, ::T.untyped)
  XML = ::T.let(nil, ::T.untyped)
end

module Nokogiri::ClassResolver
  VALID_NAMESPACES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

class Nokogiri::EncodingHandler
  USEFUL_ALIASES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Gumbo
  DEFAULT_MAX_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_ERRORS = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_TREE_DEPTH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML4
end

class Nokogiri::HTML4::ElementDescription
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML4::ElementDescription
end

module Nokogiri::HTML4
end

module Nokogiri::HTML4
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML4::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML5::QuirksMode
  LIMITED_QUIRKS = ::T.let(nil, ::T.untyped)
  NO_QUIRKS = ::T.let(nil, ::T.untyped)
  QUIRKS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Builder
  DEFAULT_DOCUMENT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  include ::Nokogiri::HTML5::Node
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DECONSTRUCT_KEYS = ::T.let(nil, ::T.untyped)
  DECONSTRUCT_METHODS = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::PP::Node
  COLLECTIONS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
  BIG_LINES = ::T.let(nil, ::T.untyped)
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEMA = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DEFAULT_XSLT = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::XPath
  CURRENT_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  ROOT_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  SUBTREE_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
end

class Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::RequireDependency
  include ::DEBUGGER__::TrapInterceptor
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

module ObjectSpace
  def self.allocation_class_path(arg); end

  def self.allocation_generation(arg); end

  def self.allocation_method_id(arg); end

  def self.allocation_sourcefile(arg); end

  def self.allocation_sourceline(arg); end

  def self.count_nodes(*arg); end

  def self.count_symbols(*arg); end

  def self.dump(obj, output: T.unsafe(nil)); end

  def self.dump_all(output: T.unsafe(nil), full: T.unsafe(nil), since: T.unsafe(nil), shapes: T.unsafe(nil)); end

  def self.dump_shapes(output: T.unsafe(nil), since: T.unsafe(nil)); end

  def self.internal_class_of(arg); end

  def self.internal_super_of(arg); end

  def self.reachable_objects_from(arg); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_debug_start(); end
end

class OpenSSL::BN
  CONSTTIME = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Buffering::Buffer
  BINARY = ::T.let(nil, ::T.untyped)
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider::ProviderError
end

module OpenSSL::SSL
  OP_ALLOW_CLIENT_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CLEANSE_PLAINTEXT = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_DISABLE_TLSEXT_CA_NAMES = ::T.let(nil, ::T.untyped)
  OP_ENABLE_KTLS = ::T.let(nil, ::T.untyped)
  OP_ENABLE_MIDDLEBOX_COMPAT = ::T.let(nil, ::T.untyped)
  OP_IGNORE_UNEXPECTED_EOF = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ANTI_REPLAY = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_PRIORITIZE_CHACHA = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::Response
  GRANTED = ::T.let(nil, ::T.untyped)
  GRANTED_WITH_MODS = ::T.let(nil, ::T.untyped)
  REJECTION = ::T.let(nil, ::T.untyped)
  REVOCATION_NOTIFICATION = ::T.let(nil, ::T.untyped)
  REVOCATION_WARNING = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TimestampError
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def as_json!(options=T.unsafe(nil)); end

  def at_exit!(&block); end

  def class!(); end

  def class_eval!(*args, &block); end

  def clone!(freeze: T.unsafe(nil)); end

  def debugger!(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def deep_dup!(); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def exit!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_values!(); end

  def instance_variable_get!(arg); end

  def instance_variable_names!(); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def presence!(); end

  def presence_in!(another_object); end

  def pretty_inspect!(); end

  def pretty_print!(q); end

  def pretty_print_cycle!(q); end

  def pretty_print_inspect!(); end

  def pretty_print_instance_variables!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def require_dependency!(filename); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_method_added!(mid); end

  def singleton_methods!(*arg); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_json!(options=T.unsafe(nil)); end

  def to_param!(); end

  def to_query!(key); end

  def to_s!(); end

  def to_yaml!(options=T.unsafe(nil)); end

  def trap!(sig, *command, &command_proc); end

  def with_options!(options, &block); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end

  def raise_unknown(); end

  def raise_unknown=(raise_unknown); end

  def require_exact(); end

  def require_exact=(require_exact); end
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class OptionParser::Switch
  def pretty_print_contents(q); end
end

class OptionParser::Switch::NoArgument
  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
  def pretty_head(); end
end

class OptionParser::Switch::PlacedArgument
  def pretty_head(); end
end

class OptionParser::Switch::RequiredArgument
  def pretty_head(); end
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  POSTGRESQL_LIB_PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapBasedOnResult
  include ::PG::BasicTypeRegistry::Checker
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

class PG::BasicTypeMapBasedOnResult
end

class PG::BasicTypeMapForQueries
  include ::PG::BasicTypeRegistry::Checker
  def encode_array_as(); end

  def encode_array_as=(pg_type); end

  def initialize(connection_or_coder_maps, registry: T.unsafe(nil), if_undefined: T.unsafe(nil)); end
end

class PG::BasicTypeMapForQueries::BinaryData
end

class PG::BasicTypeMapForQueries::BinaryData
end

class PG::BasicTypeMapForQueries::UndefinedEncoder
end

class PG::BasicTypeMapForQueries::UndefinedEncoder
end

class PG::BasicTypeMapForQueries
end

class PG::BasicTypeMapForResults
  include ::PG::BasicTypeRegistry::Checker
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
  def initialize(typenames); end

  def typecast_result_value(result, _tuple, field); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
end

class PG::BasicTypeMapForResults
end

class PG::BasicTypeRegistry
  include ::PG::BasicTypeRegistry::Checker
  def alias_type(format, new, old); end

  def coders_for(format, direction); end

  def define_default_types(); end

  def register_coder(coder); end

  def register_default_types(); end

  def register_type(format, name, encoder_class, decoder_class); end
end

module PG::BasicTypeRegistry::Checker
  def build_coder_maps(conn_or_maps, registry: T.unsafe(nil)); end

  def check_format_and_direction(format, direction); end
end

module PG::BasicTypeRegistry::Checker
end

class PG::BasicTypeRegistry::CoderMap
  def coder_by_name(name); end

  def coder_by_oid(oid); end

  def coders(); end

  def coders_by_name(); end

  def coders_by_oid(); end

  def initialize(result, coders_by_name, format, arraycoder); end
end

class PG::BasicTypeRegistry::CoderMap
end

class PG::BasicTypeRegistry::CoderMapsBundle
  def each_format(direction); end

  def initialize(connection, registry: T.unsafe(nil)); end

  def map_for(format, direction); end

  def typenames_by_oid(); end
end

class PG::BasicTypeRegistry::CoderMapsBundle
end

class PG::BasicTypeRegistry
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Date
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Date
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Date
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Float4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Float8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::TimestampLocal
end

class PG::BinaryEncoder::TimestampLocal
end

class PG::BinaryEncoder::TimestampUtc
end

class PG::BinaryEncoder::TimestampUtc
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_STANDBY = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_TARGET = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_WRITABLE = ::T.let(nil, ::T.untyped)
  CONNECTION_CONSUME = ::T.let(nil, ::T.untyped)
  CONNECTION_GSS_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  DEF_PGPORT = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_PIPELINE_ABORTED = ::T.let(nil, ::T.untyped)
  PGRES_PIPELINE_SYNC = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY_NONLOCALIZED = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_SQLSTATE = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ALWAYS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ERRORS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_NEVER = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_ABORTED = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_OFF = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_ON = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

module PG::Constants
end

class PG::CopyDecoder
end

class PG::CopyDecoder
end

class PG::CopyEncoder
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleSessionTimeout
end

class PG::IdleSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForSqlJsonDatetimeFunction
end

class PG::InvalidArgumentForSqlJsonDatetimeFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidJsonText
end

class PG::InvalidJsonText
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NoSqlJsonItem
end

class PG::NoSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::RecordDecoder
end

class PG::RecordDecoder
end

class PG::RecordEncoder
end

class PG::RecordEncoder
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonItemCannotBeCastToTargetType
end

class PG::SqlJsonItemCannotBeCastToTargetType
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonScalarRequired
end

class PG::SqlJsonScalarRequired
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

class PG::TextDecoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Date
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
end

class PG::TextDecoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::JSON
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Numeric
end

class PG::TextDecoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
  CFUNC = ::T.let(nil, ::T.untyped)
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

class PG::TextEncoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Date
  def encode(value); end
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Inet
  def encode(value); end
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::JSON
  def encode(value); end
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Numeric
end

class PG::TextEncoder::QuotedLiteral
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampUtc
  def encode(value); end
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

class PP
  def self.width_for(out); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
  def initialize(value=T.unsafe(nil)); end

  def value(); end
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

module Parallel
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.filter_map(*arg, **arg1, &arg2); end

  def self.flat_map(*arg, **arg1, &arg2); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forwarded_kwrestarg(node); end

  def on_forwarded_restarg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def lexer(); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def forwarded_kwrestarg(dstar_t); end

  def forwarded_restarg(star_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_pattern(lhs, match_t, rhs); end

  def match_pattern_p(lhs, match_t, rhs); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_label(key_t); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_kwargs(); end

  def self.emit_kwargs=(emit_kwargs); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_match_pattern(); end

  def self.emit_match_pattern=(emit_match_pattern); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

class Parser::Context
  def in_argdef(); end

  def in_argdef=(in_argdef); end

  def in_block(); end

  def in_block=(in_block); end

  def in_class(); end

  def in_class=(in_class); end

  def in_def(); end

  def in_def=(in_def); end

  def in_defined(); end

  def in_defined=(in_defined); end

  def in_dynamic_block?(); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def in_lambda(); end

  def in_lambda=(in_lambda); end

  def reset(); end
  FLAGS = ::T.let(nil, ::T.untyped)
end

class Parser::CurrentArgStack
  def empty?(); end

  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def check_ambiguous_slash(tm); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def cmdarg_stack(); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def cond_stack(); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def e_lbrace(); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_class_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_colon_with_digits(p, tm, diag_msg); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment_from_range(p, pe); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_global_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_instance_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_rbrace_rparen_rbrack(); end

  def emit_singleton_class(); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encoding(); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def initialize(version); end

  def lambda_stack(); end

  def numeric_literal_int(); end

  def on_newline(p); end

  def paren_nest(); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def push_cmdarg(); end

  def push_cond(); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version(); end

  def version?(*versions); end
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_inside_string(); end

  def self.lex_en_inside_string=(lex_en_inside_string); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::LexerStrings
  def advance(p); end

  def check_ambiguous_slash(tm); end

  def check_invalid_escapes(p); end

  def close_interp_on_current_literal(p); end

  def cond(); end

  def continue_lexing(current_literal); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_character_constant(); end

  def emit_interp_var(interp_var_kind); end

  def emit_invalid_escapes?(); end

  def encode_escape(ord); end

  def encode_escaped_char(p); end

  def eof_codepoint?(point); end

  def extend_interp_code(current_literal); end

  def extend_interp_digit_var(); end

  def extend_interp_var(current_literal); end

  def extend_string_eol_check_eof(current_literal, pe); end

  def extend_string_eol_heredoc_intertwined(p); end

  def extend_string_eol_heredoc_line(); end

  def extend_string_eol_words(current_literal, p); end

  def extend_string_escaped(); end

  def extend_string_for_token_range(current_literal, string); end

  def extend_string_slice_end(lookahead); end

  def herebody_s(); end

  def herebody_s=(herebody_s); end

  def initialize(lexer, version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def on_newline(p); end

  def pop_literal(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def read_character_constant(p); end

  def read_post_meta_or_ctrl_char(p); end

  def reset(); end

  def slash_c_char(); end

  def slash_m_char(); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def source_pts(); end

  def source_pts=(source_pts); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def unescape_char(p); end

  def unicode_points(p); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::LexerStrings
  def self.lex_en_character(); end

  def self.lex_en_character=(lex_en_character); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_en_unknown(); end

  def self.lex_en_unknown=(lex_en_unknown); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def empty?(); end

  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(static:); end

  def register(numparam); end

  def stack(); end

  def top(); end
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*arg); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def local_pop(); end

  def local_push(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(start, length=T.unsafe(nil)); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_by_identity(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_by_identity(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::MethodDefinition
  def assignment(); end

  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Range
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_anonymous_blockarg(); end

  def declare_anonymous_kwrestarg(); end

  def declare_anonymous_restarg(); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_anonymous_blockarg?(); end

  def declared_anonymous_blockarg_in_current_scpe?(); end

  def declared_anonymous_kwrestarg?(); end

  def declared_anonymous_kwrestarg_in_current_scope?(); end

  def declared_anonymous_restarg?(); end

  def declared_anonymous_restarg_in_current_scope?(); end

  def declared_forward_args?(); end

  def empty?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def parent_has_anonymous_blockarg?(); end

  def parent_has_anonymous_kwrestarg?(); end

  def parent_has_anonymous_restarg?(); end

  def reset(); end

  def unextend(); end
  ANONYMOUS_BLOCKARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_BLOCKARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def empty?(); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Pathname
  def existence(); end

  def lutime(arg, arg1); end
end

class PositionalGenerator
  def generate(); end

  def initialize(as_type, &block); end
end

class PositionalGenerator::Builder
  def as_type(); end

  def build(); end

  def computed(name: T.unsafe(nil), deps: T.unsafe(nil), &block); end

  def group(name: T.unsafe(nil), &block); end

  def initialize(as_type); end

  def int(name: T.unsafe(nil), length: T.unsafe(nil), ranges: T.unsafe(nil)); end

  def letter(name: T.unsafe(nil), length: T.unsafe(nil), ranges: T.unsafe(nil)); end

  def lit(value, name: T.unsafe(nil)); end

  def oneof(name: T.unsafe(nil), &block); end
end

class PositionalGenerator::Builder::Computed
  def generate(args); end

  def initialize(block); end
end

class PositionalGenerator::Builder::Group
  def generate(_); end

  def initialize(as_type, block); end
end

class PositionalGenerator::Builder::Int
  def generate(_); end

  def initialize(length, ranges); end
end

class PositionalGenerator::Builder::Letter
  def generate(_); end

  def initialize(length, ranges); end
end

class PositionalGenerator::Builder::Literal
  def generate(_); end

  def initialize(value); end
end

class PositionalGenerator::Builder::Oneof
  def generate(*arg, **arg1, &arg2); end

  def initialize(builder, block); end
end

class PositionalGenerator::Builder::Oneof::OneofSelector
  def generate(*arg, **arg1, &arg2); end

  def initialize(builder); end

  def method_missing(meth, *args, **kwargs, &block); end

  def sample(); end
end

class PositionalGenerator::Component
  def deps(); end

  def deps=(_); end

  def generator(); end

  def generator=(_); end

  def name(); end

  def name=(_); end

  def position(); end

  def position=(_); end
end

class PositionalGenerator::Component
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  extend ::DEBUGGER__::ForkInterceptor
  extend ::DEBUGGER__::ForkInterceptor::DaemonInterceptor
  extend ::ActiveSupport::ForkTracker::ModernCoreExt
  def self.exit(*arg); end
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar_component(); end

  def bar_component=(bar_component); end

  def clear(*args, **arg, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, **arg, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage_component(); end

  def percentage_component=(percentage_component); end

  def progress(*args, **arg, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def projector(); end

  def projector=(projector); end

  def rate_component(); end

  def rate_component=(rate_component); end

  def refresh(*args, **arg, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time_component(); end

  def time_component=(time_component); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_component(); end

  def title_component=(title_component); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, **arg, &block); end

  def total=(new_total); end

  def update_progress(*args); end
  RUNNING_AVERAGE_RATE_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  SMOOTHING_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Components::Bar
  def bar(length); end

  def bar_with_percentage(length); end

  def complete_bar(length); end

  def complete_bar_with_percentage(length); end

  def incomplete_space(length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def justified_percentage(); end

  def justified_percentage_with_precision(); end

  def percentage(); end

  def percentage_with_precision(); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_of_change(format_string=T.unsafe(nil)); end

  def rate_of_change_with_precision(); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_wall_clock(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(out_of_bounds_time_format=T.unsafe(nil)); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def projector(); end

  def projector=(projector); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TEXT_TO_FORMAT = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
  WALL_CLOCK_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*arg); end

  def resolve_format(*arg); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Projector
  NAME_TO_PROJECTOR_MAP = ::T.let(nil, ::T.untyped)
end

ProgressBar::Projector::DEFAULT_PROJECTOR = ProgressBar::Projectors::SmoothedAverage

class ProgressBar::Projector
  def self.from_type(name); end
end

class ProgressBar::Projectors::SmoothedAverage
  def decrement(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def progress(); end

  def progress=(new_progress); end

  def projection(); end

  def projection=(projection); end

  def reset(); end

  def samples(); end

  def samples=(samples); end

  def start(options=T.unsafe(nil)); end

  def strength(); end

  def strength=(strength); end

  def total=(_new_total); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRENGTH = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Projectors::SmoothedAverage
  def self.calculate(current_projection, new_value, rate); end
end

module ProgressBar::Refinements::Enumerator
  ARITY_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def now(); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar
  def self.create(*args); end
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
  INTEGER_LEGACY = ::T.let(nil, ::T.untyped)
  INTEGER_STRICT = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
  DEFAULT_PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
end

module Psych
  extend ::Bootsnap::CompileCache::YAML::Psych4::Patch
end

module Puma
  HAS_FORK = ::T.let(nil, ::T.untyped)
  HAS_SSL = ::T.let(nil, ::T.untyped)
  HAS_UNIX_SOCKET = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_MRI = ::T.let(nil, ::T.untyped)
  IS_OSX = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  def activated_sockets(); end

  def add_ssl_listener(host, port, ctx, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_tcp_listener(host, port, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_unix_listener(path, umask=T.unsafe(nil), mode=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def close(); end

  def close_listeners(); end

  def connected_ports(); end

  def create_activated_fds(env_hash); end

  def create_inherited_fds(env_hash); end

  def env(sock); end

  def envs(); end

  def inherit_ssl_listener(fd, ctx); end

  def inherit_tcp_listener(host, port, fd); end

  def inherit_unix_listener(path, fd); end

  def inherited_fds(); end

  def initialize(events, conf=T.unsafe(nil)); end

  def ios(); end

  def ios=(ios); end

  def listeners(); end

  def listeners=(listeners); end

  def localhost_authority(); end

  def localhost_authority_context(); end

  def parse(binds, logger, log_msg=T.unsafe(nil)); end

  def proto_env(); end

  def redirects_for_restart(); end

  def redirects_for_restart_env(); end

  def synthesize_binds_from_activated_fs(binds, only_matching); end

  def unix_paths(); end
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  def body(); end

  def call(); end

  def can_close?(); end

  def close(); end

  def closed?(*args, **arg, &block); end

  def eagerly_finish(); end

  def env(); end

  def expect_proxy_proto=(val); end

  def finish(timeout); end

  def hijacked(); end

  def in_data_phase(); end

  def initialize(io, env=T.unsafe(nil)); end

  def io(); end

  def io_ok?(); end

  def listener(); end

  def listener=(listener); end

  def peerip(); end

  def peerip=(peerip); end

  def ready(); end

  def remote_addr_header(); end

  def remote_addr_header=(remote_addr_header); end

  def reset(fast_check=T.unsafe(nil)); end

  def set_timeout(val); end

  def tempfile(); end

  def timeout(); end

  def timeout!(); end

  def timeout_at(); end

  def to_io(); end

  def try_to_finish(); end

  def try_to_parse_proxy_protocol(); end

  def write_error(status_code); end
  ALLOWED_TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE_INVALID = ::T.let(nil, ::T.untyped)
  CHUNK_VALID_ENDING = ::T.let(nil, ::T.untyped)
  CHUNK_VALID_ENDING_SIZE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_VALUE_INVALID = ::T.let(nil, ::T.untyped)
  EmptyBody = ::T.let(nil, ::T.untyped)
  MAX_CHUNK_EXCESS = ::T.let(nil, ::T.untyped)
  MAX_CHUNK_HEADER_SIZE = ::T.let(nil, ::T.untyped)
  TE_ERR_MSG = ::T.let(nil, ::T.untyped)
end

class Puma::Cluster
  def all_workers_booted?(); end

  def check_workers(); end

  def cull_start_index(diff); end

  def cull_workers(); end

  def fork_worker!(); end

  def halt(); end

  def next_worker_index(); end

  def phased_restart(); end

  def preload?(); end

  def reload_worker_directory(); end

  def restart(); end

  def run(); end

  def setup_signals(); end

  def spawn_worker(idx, master); end

  def spawn_workers(); end

  def start_phased_restart(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end

  def stop_workers(); end

  def worker(index, master); end

  def workers_to_cull(diff); end
end

class Puma::Cluster::Worker
  def index(); end

  def initialize(index:, master:, launcher:, pipes:, server: T.unsafe(nil)); end

  def master(); end

  def run(); end
end

class Puma::Cluster::WorkerHandle
  def boot!(); end

  def booted?(); end

  def hup(); end

  def index(); end

  def initialize(idx, pid, phase, options); end

  def kill(); end

  def last_checkin(); end

  def last_status(); end

  def phase(); end

  def phase=(phase); end

  def pid(); end

  def pid=(pid); end

  def ping!(status); end

  def ping_timeout(); end

  def signal(); end

  def started_at(); end

  def term(); end

  def term!(); end

  def term?(); end

  def uptime(); end
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerCheckInterval = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

class Puma::Configuration
  def app(); end

  def app_configured?(); end

  def clamp(); end

  def config_files(); end

  def configure(); end

  def default_max_threads(); end

  def environment(); end

  def environment_str(); end

  def final_options(); end

  def flatten(); end

  def flatten!(); end

  def initialize(user_options=T.unsafe(nil), default_options=T.unsafe(nil), &block); end

  def load(); end

  def load_plugin(name); end

  def options(); end

  def plugins(); end

  def puma_default_options(); end

  def rackup(); end

  def run_hooks(key, arg, events); end
end

class Puma::Configuration::ConfigMiddleware
  def call(env); end

  def initialize(config, app); end
end

class Puma::Configuration
  def self.random_token(); end

  def self.temp_path(); end
end

module Puma::Const
  BANNED_HEADER_KEY = ::T.let(nil, ::T.untyped)
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  DQUOTE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER_DELIMITER = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_KEY_REGEX = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_VALUE_REGEX = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_FAST_INLINE = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PROXY_PROTOCOL_V1_REGEX = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Puma::DSL
  def _load_from(path); end

  def _offer_plugins(); end

  def activate_control_app(url=T.unsafe(nil), opts=T.unsafe(nil)); end

  def after_worker_boot(&block); end

  def after_worker_fork(&block); end

  def app(obj=T.unsafe(nil), &block); end

  def before_fork(&block); end

  def bind(url); end

  def bind_to_activated_sockets(bind=T.unsafe(nil)); end

  def clean_thread_locals(which=T.unsafe(nil)); end

  def clear_binds!(); end

  def debug(); end

  def default_host(); end

  def directory(dir); end

  def drain_on_shutdown(which=T.unsafe(nil)); end

  def early_hints(answer=T.unsafe(nil)); end

  def environment(environment); end

  def extra_runtime_dependencies(answer=T.unsafe(nil)); end

  def first_data_timeout(seconds); end

  def force_shutdown_after(val=T.unsafe(nil)); end

  def fork_worker(after_requests=T.unsafe(nil)); end

  def get(key, default=T.unsafe(nil)); end

  def initialize(options, config); end

  def inject(&blk); end

  def io_selector_backend(backend); end

  def load(file); end

  def log_formatter(&block); end

  def log_requests(which=T.unsafe(nil)); end

  def lowlevel_error_handler(obj=T.unsafe(nil), &block); end

  def max_fast_inline(num_of_requests); end

  def mutate_stdout_and_stderr_to_sync_on_write(enabled=T.unsafe(nil)); end

  def nakayoshi_fork(enabled=T.unsafe(nil)); end

  def on_refork(&block); end

  def on_restart(&block); end

  def on_worker_boot(&block); end

  def on_worker_fork(&block); end

  def on_worker_shutdown(&block); end

  def out_of_band(&block); end

  def persistent_timeout(seconds); end

  def pidfile(path); end

  def plugin(name); end

  def port(port, host=T.unsafe(nil)); end

  def preload_app!(answer=T.unsafe(nil)); end

  def prune_bundler(answer=T.unsafe(nil)); end

  def queue_requests(answer=T.unsafe(nil)); end

  def quiet(which=T.unsafe(nil)); end

  def rack_url_scheme(scheme=T.unsafe(nil)); end

  def rackup(path); end

  def raise_exception_on_sigterm(answer=T.unsafe(nil)); end

  def restart_command(cmd); end

  def set_default_host(host); end

  def set_remote_address(val=T.unsafe(nil)); end

  def shutdown_debug(val=T.unsafe(nil)); end

  def silence_single_worker_warning(); end

  def ssl_bind(host, port, opts=T.unsafe(nil)); end

  def state_path(path); end

  def state_permission(permission); end

  def stdout_redirect(stdout=T.unsafe(nil), stderr=T.unsafe(nil), append=T.unsafe(nil)); end

  def tag(string); end

  def threads(min, max); end

  def wait_for_less_busy_worker(val=T.unsafe(nil)); end

  def worker_boot_timeout(timeout); end

  def worker_check_interval(interval); end

  def worker_culling_strategy(strategy); end

  def worker_shutdown_timeout(timeout); end

  def worker_timeout(timeout); end

  def workers(count); end
end

class Puma::DSL
  def self.ssl_bind_str(host, port, opts); end
end

class Puma::ErrorLogger
  def debug(options=T.unsafe(nil)); end

  def info(options=T.unsafe(nil)); end

  def initialize(ioerr); end

  def ioerr(); end

  def request_dump(req); end

  def request_headers(req); end

  def request_parsed?(req); end

  def request_title(req); end

  def title(options=T.unsafe(nil)); end
  REQUEST_FORMAT = ::T.let(nil, ::T.untyped)
end

class Puma::ErrorLogger
  def self.stdio(); end
end

class Puma::Events
  def connection_error(error, req, text=T.unsafe(nil)); end

  def debug(str); end

  def debug_error(error, req=T.unsafe(nil), text=T.unsafe(nil)); end

  def error(str); end

  def fire(hook, *args); end

  def fire_on_booted!(); end

  def fire_on_restart!(); end

  def fire_on_stopped!(); end

  def format(str); end

  def formatter(); end

  def formatter=(formatter); end

  def initialize(stdout, stderr); end

  def log(str); end

  def on_booted(&block); end

  def on_restart(&block); end

  def on_stopped(&block); end

  def parse_error(error, req); end

  def register(hook, obj=T.unsafe(nil), &blk); end

  def ssl_error(error, ssl_socket); end

  def stderr(); end

  def stdout(); end

  def unknown_error(error, req=T.unsafe(nil), text=T.unsafe(nil)); end

  def write(str); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::Events::DefaultFormatter
  def call(str); end
end

class Puma::Events::PidFormatter
  def call(str); end
end

class Puma::Events
  def self.null(); end

  def self.stdio(); end

  def self.strings(); end
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::IOBuffer
  def append(*args); end

  def reset(); end
end

module Puma::JSONSerialization
  BACKSLASH = ::T.let(nil, ::T.untyped)
  CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
end

class Puma::Launcher
  def binder(); end

  def close_binder_listeners(); end

  def config(); end

  def connected_ports(); end

  def delete_pidfile(); end

  def events(); end

  def halt(); end

  def initialize(conf, launcher_args=T.unsafe(nil)); end

  def options(); end

  def phased_restart(); end

  def refork(); end

  def restart(); end

  def restart_args(); end

  def restart_dir(); end

  def run(); end

  def stats(); end

  def stop(); end

  def thread_status(); end

  def write_state(); end
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

module Puma::MiniSSL
  HAS_TLS1_3 = ::T.let(nil, ::T.untyped)
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SSL3 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1_1 = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  VERIFICATION_FLAGS = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::ContextBuilder
  def context(); end

  def initialize(params, events); end
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::NullIO
  def close(); end

  def closed?(); end

  def each(&blk); end

  def eof?(); end

  def flush(); end

  def gets(); end

  def puts(*ary); end

  def read(count=T.unsafe(nil), _buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def string(); end

  def sync(); end

  def sync=(v); end

  def write(*ary); end
end

class Puma::Plugin
  def in_background(&blk); end
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Plugin
  def self.create(&blk); end

  def self.extract_name(ary); end
end

class Puma::PluginLoader
  def create(name); end

  def fire_starts(launcher); end
end

class Puma::PluginRegistry
  def add_background(blk); end

  def find(name); end

  def fire_background(); end

  def register(name, cls); end
end

class Puma::Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Puma::Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Puma::Rack::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Puma::Reactor
  def add(client); end

  def initialize(backend, &block); end

  def run(background=T.unsafe(nil)); end

  def shutdown(); end
end

module Puma::Request
  def default_server_port(env); end

  def handle_request(client, lines, requests); end

  def normalize_env(env, client); end
end

class Puma::Runner
  def app(); end

  def close_control_listeners(); end

  def debug(str); end

  def development?(); end

  def error(str); end

  def initialize(cli, events); end

  def load_and_bind(); end

  def log(str); end

  def output_header(mode); end

  def redirect_io(); end

  def redirected_io?(); end

  def ruby_engine(); end

  def start_control(); end

  def start_server(); end

  def stop_control(); end

  def test?(); end

  def wakeup!(); end
end

class Puma::Server
  def add_ssl_listener(*args, **arg, &block); end

  def add_tcp_listener(*args, **arg, &block); end

  def add_unix_listener(*args, **arg, &block); end

  def app(); end

  def app=(app); end

  def auto_trim_time(); end

  def auto_trim_time=(auto_trim_time); end

  def backlog(); end

  def begin_restart(sync=T.unsafe(nil)); end

  def binder(); end

  def binder=(binder); end

  def client_error(e, client); end

  def closed_socket?(socket); end

  def connected_ports(*args, **arg, &block); end

  def cork_socket(socket); end

  def early_hints(); end

  def early_hints=(early_hints); end

  def events(); end

  def first_data_timeout(); end

  def first_data_timeout=(first_data_timeout); end

  def graceful_shutdown(); end

  def halt(sync=T.unsafe(nil)); end

  def handle_check(); end

  def handle_servers(); end

  def inherit_binder(bind); end

  def initialize(app, events=T.unsafe(nil), options=T.unsafe(nil)); end

  def leak_stack_on_error(); end

  def leak_stack_on_error=(leak_stack_on_error); end

  def log_writer(); end

  def lowlevel_error(e, env, status=T.unsafe(nil)); end

  def max_threads(); end

  def max_threads=(max_threads); end

  def min_threads(); end

  def min_threads=(min_threads); end

  def persistent_timeout(); end

  def persistent_timeout=(persistent_timeout); end

  def pool_capacity(); end

  def process_client(client, buffer); end

  def reactor_wakeup(client); end

  def reaping_time(); end

  def reaping_time=(reaping_time); end

  def requests_count(); end

  def run(background=T.unsafe(nil), thread_name: T.unsafe(nil)); end

  def running(); end

  def shutting_down?(); end

  def stats(); end

  def stop(sync=T.unsafe(nil)); end

  def thread(); end

  def uncork_socket(socket); end

  def with_force_shutdown(client, &block); end
  STAT_METHODS = ::T.let(nil, ::T.untyped)
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  def self.current(); end
end

class Puma::Single
  def halt(); end

  def restart(); end

  def run(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end
end

class Puma::ThreadPool
  def <<(work); end

  def auto_reap!(timeout=T.unsafe(nil)); end

  def auto_trim!(timeout=T.unsafe(nil)); end

  def backlog(); end

  def busy_threads(); end

  def clean_thread_locals(); end

  def clean_thread_locals=(clean_thread_locals); end

  def initialize(name, min, max, *extra, &block); end

  def out_of_band_hook(); end

  def out_of_band_hook=(out_of_band_hook); end

  def pool_capacity(); end

  def reap(); end

  def shutdown(timeout=T.unsafe(nil)); end

  def spawned(); end

  def trim(force=T.unsafe(nil)); end

  def trim_requested(); end

  def wait_for_less_busy_worker(delay_s); end

  def wait_until_not_full(); end

  def waiting(); end

  def with_force_shutdown(); end

  def with_mutex(&block); end
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool::Automaton
  def initialize(pool, timeout, thread_name, message); end

  def start!(); end

  def stop(); end
end

class Puma::ThreadPool
  def self.clean_thread_locals(); end
end

class Puma::UserFileDefaultOptions
  def [](key); end

  def []=(key, value); end

  def all_of(key); end

  def default_options(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def file_options(); end

  def final_options(); end

  def finalize_values(); end

  def initialize(user_options, default_options); end

  def user_options(); end
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Puma::Util::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def replace(other); end
end

class Puma::Util::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

module Puma::Util
  def self.escape(s, encoding=T.unsafe(nil)); end

  def self.nakayoshi_gc(events); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.pipe(); end

  def self.purge_interrupt_queue(); end

  def self.unescape(s, encoding=T.unsafe(nil)); end
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *arg); end
end

class Rack::Auth::Digest::Request
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, **arg, &block); end
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, **arg, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

module Rack::Events::Abstract
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::BufferedResponse
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

class Rack::Events::EventedBodyProxy
end

class Rack::Events
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::Files
  def self.method_added(name); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, **arg, &block); end

  def close_read(*args, **arg, &block); end

  def close_write(*args, **arg, &block); end

  def closed?(*args, **arg, &block); end

  def flush(*args, **arg, &block); end

  def initialize(io); end

  def read(*args, **arg, &block); end

  def read_nonblock(*args, **arg, &block); end

  def write(*args, **arg, &block); end

  def write_nonblock(*args, **arg, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def cookie(name); end

  def cookies(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
  def self.[](*arg, **arg1); end
end

Rack::MockSession = Rack::Test::Session

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartTotalPartLimitError
end

class Rack::Multipart::MultipartTotalPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def forwarded_authority(); end

  def forwarded_for(); end

  def forwarded_port(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_authority(); end

  def host_with_port(authority=T.unsafe(nil)); end

  def hostname(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def server_authority(); end

  def server_name(); end

  def server_port(); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Request
  def self.ip_filter(); end

  def self.ip_filter=(ip_filter); end
end

class Rack::Response
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), headers=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def write(chunk); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def append(chunk); end

  def bad_request?(); end

  def buffered_body!(); end

  def cache!(duration=T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def content_type=(content_type); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def do_not_cache!(); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

class Rack::Response::Raw
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response
  def self.[](status, headers, body); end
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end
end

class Rack::RewindableInput
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*arg); end

  def generate_sid(*arg); end
end

class Rack::Session::Abstract::SessionHash
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(key, *keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  END_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  START_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  RFC2822_DAY_NAME = ::T.let(nil, ::T.untyped)
  RFC2822_MONTH_NAME = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
end

module Rails::Command::Actions
  def load_generators(); end

  def load_tasks(); end

  def require_application!(); end

  def require_application_and_environment!(); end

  def require_environment!(); end

  def set_application_directory!(); end
end

module Rails::Command::Actions
end

class Rails::Command::Base
  include ::Rails::Command::Actions
  def help(); end
end

class Rails::Command::Base::CorrectableError
  include ::DidYouMean::Correctable
  def initialize(message, key, options); end

  def key(); end

  def options(); end
end

class Rails::Command::Base::CorrectableError
end

class Rails::Command::Base::Error
end

class Rails::Command::Base::Error
end

class Rails::Command::Base
  def self.banner(*arg); end

  def self.base_name(); end

  def self.command_name(); end

  def self.default_command_root(); end

  def self.desc(usage=T.unsafe(nil), description=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.engine?(); end

  def self.executable(); end

  def self.hide_command!(); end

  def self.inherited(base); end

  def self.perform(command, args, config); end

  def self.printing_commands(); end

  def self.usage_path(); end
end

module Rails::Command::Behavior::ClassMethods
  def no_color!(); end

  def subclasses(); end
end

module Rails::Command
  def self.environment(); end

  def self.find_by_namespace(namespace, command_name=T.unsafe(nil)); end

  def self.hidden_commands(); end

  def self.invoke(full_namespace, args=T.unsafe(nil), **config); end

  def self.print_commands(); end

  def self.root(); end
end

class Rails::Conductor::ActionMailbox::InboundEmails::SourcesController
  def create(); end

  def new(); end
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
  def create(); end

  def index(); end

  def new(); end

  def show(); end
end

class Rails::Conductor::ActionMailbox::IncineratesController
  def create(); end
end

class Rails::Conductor::ActionMailbox::ReroutesController
  def create(); end
end

module Rails::Dom::Testing
  def default_html_version(); end

  def default_html_version=(val); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil), strict: T.unsafe(nil), html_version: T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil), strict: T.unsafe(nil), html_version: T.unsafe(nil)); end

  def compare_doms(expected, actual, strict); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_child?(child, other_child, strict); end

  def equal_children?(child, other_child, strict); end

  def extract_children(node, strict); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  def assert_dom(*args, &block); end

  def assert_dom_email(html_version: T.unsafe(nil), &block); end

  def assert_dom_encoded(element=T.unsafe(nil), html_version: T.unsafe(nil), &block); end

  def assert_select(*args, &block); end

  def assert_select_email(html_version: T.unsafe(nil), &block); end

  def assert_select_encoded(element=T.unsafe(nil), html_version: T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing
  def self.default_html_version(); end

  def self.default_html_version=(val); end

  def self.html5_support?(); end

  def self.html_document(html_version: T.unsafe(nil)); end

  def self.html_document_fragment(html_version: T.unsafe(nil)); end
end

module Rails::Generators
  def namespace(); end

  def namespace=(val); end
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil), &block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def github(repo, options=T.unsafe(nil), &block); end

  def initialize(*arg); end

  def initializer(filename, data=T.unsafe(nil)); end

  def lib(filename, data=T.unsafe(nil)); end

  def rails_command(command, options=T.unsafe(nil)); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil)); end

  def readme(path); end

  def route(routing_code, namespace: T.unsafe(nil)); end

  def vendor(filename, data=T.unsafe(nil)); end
end

class Rails::Generators::Actions::CreateMigration
  def existing_migration(); end

  def migration_dir(); end

  def migration_file_name(); end

  def relative_existing_migration(); end
end

class Rails::Generators::Actions::CreateMigration
end

module Rails::Generators::Actions
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

module Rails::Generators::Database
  def convert_database_option_for_jruby(); end

  def gem_for_database(database=T.unsafe(nil)); end

  def initialize(*arg); end
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end

  def migration_exists?(dirname, file_name); end

  def migration_lookup_at(dirname); end

  def next_migration_number(dirname); end
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
end

class Rails::Generators::NamedBase
  def file_name(); end

  def initialize(args, *options); end

  def js_template(source, destination); end

  def name(); end

  def name=(name); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def initialize(*args); end
end

module Rails::Generators::ResourceHelpers
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::FileUtils::StreamUtils_
  def current_path(); end

  def current_path=(current_path); end

  def current_path?(); end

  def default_arguments(); end

  def default_arguments=(default_arguments); end

  def default_arguments?(); end

  def destination_root(); end

  def destination_root=(destination_root); end

  def destination_root?(); end

  def generator_class(); end

  def generator_class=(generator_class); end

  def generator_class?(); end
end

class Rails::Generators::TestCase
  def self.current_path(); end

  def self.current_path=(value); end

  def self.current_path?(); end

  def self.default_arguments(); end

  def self.default_arguments=(value); end

  def self.default_arguments?(); end

  def self.destination_root(); end

  def self.destination_root=(value); end

  def self.destination_root?(); end

  def self.generator_class(); end

  def self.generator_class=(value); end

  def self.generator_class?(); end
end

module Rails::Generators::Testing::Assertions
  def assert_class_method(method, content, &block); end

  def assert_directory(relative, *contents); end

  def assert_field_default_value(attribute_type, value); end

  def assert_field_type(attribute_type, field_type); end

  def assert_file(relative, *contents); end

  def assert_instance_method(method, content); end

  def assert_method(method, content); end

  def assert_migration(relative, *contents, &block); end

  def assert_no_directory(relative); end

  def assert_no_file(relative); end

  def assert_no_migration(relative); end
end

module Rails::Generators::Testing::Behaviour
  def create_generated_attribute(attribute_type, name=T.unsafe(nil), index=T.unsafe(nil)); end

  def generator(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def run_generator(args=T.unsafe(nil), config=T.unsafe(nil)); end
end

module Rails::Generators::Testing::SetupAndTeardown
  def setup(); end

  def teardown(); end
end

module Rails::Generators
  def self.add_generated_file(file); end

  def self.after_generate_callbacks(); end

  def self.aliases(); end

  def self.api_only!(); end

  def self.configure!(config); end

  def self.fallbacks(); end

  def self.find_by_namespace(name, base=T.unsafe(nil), context=T.unsafe(nil)); end

  def self.help(command=T.unsafe(nil)); end

  def self.hidden_namespaces(); end

  def self.hide_namespace(*namespaces); end

  def self.hide_namespaces(*namespaces); end

  def self.invoke(namespace, args=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.options(); end

  def self.print_generators(); end

  def self.public_namespaces(); end

  def self.sorted_groups(); end

  def self.templates_path(); end
end

module Rails::HTML::Concern::ComposedSanitize
  def sanitize(html, options=T.unsafe(nil)); end
end

module Rails::HTML::Concern::Parser::HTML4
  def parse_fragment(html); end
end

module Rails::HTML::Concern::Parser::HTML5
  def parse_fragment(html); end
end

module Rails::HTML::Concern::Scrubber::Full
  def scrub(fragment, options=T.unsafe(nil)); end
end

module Rails::HTML::Concern::Scrubber::Link
  def initialize(); end

  def scrub(fragment, options=T.unsafe(nil)); end
end

module Rails::HTML::Concern::Scrubber::SafeList
  def initialize(prune: T.unsafe(nil)); end

  def sanitize_css(style_string); end

  def scrub(fragment, options=T.unsafe(nil)); end
  DEFAULT_ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEFAULT_ALLOWED_TAGS = ::T.let(nil, ::T.untyped)
end

module Rails::HTML::Concern::Scrubber::SafeList
  def self.included(klass); end
end

module Rails::HTML::Concern::Serializer::UTF8Encode
  def serialize(fragment); end
end

Rails::HTML::FullSanitizer = Rails::HTML4::FullSanitizer

Rails::HTML::LinkSanitizer = Rails::HTML4::LinkSanitizer

class Rails::HTML::PermitScrubber
  def allowed_node?(node); end

  def attributes(); end

  def attributes=(attributes); end

  def initialize(prune: T.unsafe(nil)); end

  def keep_node?(node); end

  def prune(); end

  def scrub_attribute(node, attr_node); end

  def scrub_attribute?(name); end

  def scrub_attributes(node); end

  def scrub_css_attribute(node); end

  def scrub_node(node); end

  def skip_node?(node); end

  def tags(); end

  def tags=(tags); end

  def validate!(var, name); end
end

Rails::HTML::SafeListSanitizer = Rails::HTML4::SafeListSanitizer

class Rails::HTML::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rails::HTML::Sanitizer
  def self.best_supported_vendor(); end

  def self.html5_support?(); end
end

class Rails::HTML::TextOnlyScrubber
  def initialize(); end
end

Rails::HTML::WhiteListSanitizer = Rails::HTML4::SafeListSanitizer

class Rails::HTML4::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

module Rails::HTML4::Sanitizer::VendorMethods
  def full_sanitizer(); end

  def link_sanitizer(); end

  def safe_list_sanitizer(); end

  def white_list_sanitizer(); end
end

class Rails::HTML5::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

class Rails::HTML5::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.safe_list_sanitizer(); end

  def self.white_list_sanitizer(); end
end

Rails::Html = Rails::HTML

module Rails::Info
  def properties(); end

  def properties=(val); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(val); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

module Rails::MailersController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  def locale_query(*args, **arg, &block); end

  def part_query(*args, **arg, &block); end
end

module Rails::MailersController::HelperMethods
end

class Rails::MailersController
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def extract_annotations_from(file, pattern); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def to_s(options=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def self.directories(); end

  def self.extensions(); end

  def self.register_directories(*dirs); end

  def self.register_extensions(*exts, &block); end

  def self.register_tags(*additional_tags); end

  def self.tags(); end
end

class Rails::SourceAnnotationExtractor
  def self.enumerate(tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::EachTimeWithZone
  def %(arg); end

  def entries(); end

  def overlaps?(other); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end
end

class Regexp
  def multiline?(); end

  def timeout(); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::Backref = Regexp::Expression::Backreference

class Regexp::Expression::Backreference::Base
  def match_length(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def case_insensitive?(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def custom_to_s_handling(); end

  def custom_to_s_handling=(custom_to_s_handling); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def options(); end

  def options=(options); end

  def parent(); end

  def parent=(parent); end

  def possessive?(); end

  def pre_quantifier_decorations(); end

  def pre_quantifier_decorations=(pre_quantifier_decorations); end

  def quantifier(); end

  def quantify(*args); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def te(); end

  def te=(te); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negative(); end

  def negative=(negative); end
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

Regexp::Expression::Escape = Regexp::Expression::EscapeSequence

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::FreeSpace
  def match_length(); end

  def quantify(*_args); end
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Passive
  def implicit=(implicit); end

  def implicit?(); end

  def initialize(*arg); end
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Literal
  def match_length(); end
end

Regexp::Expression::MatchLength = Regexp::MatchLength

Regexp::Expression::Nonposixclass = Regexp::Expression::PosixClass

Regexp::Expression::Nonproperty = Regexp::Expression::UnicodeProperty

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end
end

Regexp::Expression::Posixclass = Regexp::Expression::PosixClass

Regexp::Expression::Property = Regexp::Expression::UnicodeProperty

class Regexp::Expression::Quantifier
  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def custom_to_s_handling(); end

  def custom_to_s_handling=(custom_to_s_handling); end

  def greedy?(); end

  def initialize(*args); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def max(); end

  def min(); end

  def mode(); end

  def nesting_level(); end

  def options(); end

  def options=(options); end

  def parent(); end

  def parent=(parent); end

  def possessive?(); end

  def pre_quantifier_decorations(); end

  def pre_quantifier_decorations=(pre_quantifier_decorations); end

  def quantifier(); end

  def reluctant?(); end

  def set_level(); end

  def set_level=(set_level); end

  def te(); end

  def te=(te); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end
end

class Regexp::Expression::Sequence
  def quantify(token, *args); end
end

class Regexp::Expression::Sequence
  def self.add_to(exp, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::CharacterSet
end

Regexp::Expression::Set::IntersectedSequence = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::Shared
  def ==(other); end

  def ===(other); end

  def base_length(); end

  def capturing?(); end

  def coded_offset(); end

  def comment?(); end

  def decorative?(); end

  def ends_at(include_quantifier=T.unsafe(nil)); end

  def eql?(other); end

  def full_length(); end

  def human_name(); end

  def inspect(); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def negated?(); end

  def negative?(); end

  def nesting_level=(lvl); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def optional?(); end

  def parts(); end

  def pre_quantifier_decoration(expression_format=T.unsafe(nil)); end

  def pretty_print(q); end

  def pretty_print_instance_variables(); end

  def quantified?(); end

  def quantifier=(qtf); end

  def quantifier_affix(expression_format=T.unsafe(nil)); end

  def referential?(); end

  def starts_at(); end

  def terminal?(); end

  def to_s(format=T.unsafe(nil)); end

  def to_str(format=T.unsafe(nil)); end

  def token_class(); end

  def type?(test_type); end
end

module Regexp::Expression::Shared::ClassMethods
  def capturing?(); end

  def comment?(); end

  def construct(params=T.unsafe(nil)); end

  def construct_defaults(); end

  def decorative?(); end

  def referential?(); end

  def terminal?(); end

  def token_class(); end
end

module Regexp::Expression::Shared
  def self.included(mod); end
end

class Regexp::Expression::Subexpression
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def each_expression_with_index(&block); end

  def each_expression_without_index(&block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def extract_quantifier_target(quantifier_description); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def shortcut(); end
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Lexer
  def emit(token); end

  def lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  CONDITION_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  def parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Regexp::Parser::UP = Regexp::Expression::UnicodeProperty

Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text); end

  def literal_run(); end

  def literal_run=(literal_run); end

  def scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::UnknownPosixClassError
  def initialize(text, _); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name, _); end
end

class Regexp::Scanner::ValidationError
  def self.for(type, problem, reason=T.unsafe(nil)); end

  def self.types(); end
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.parse_prop_map(name); end

  def self.posix_classes(); end

  def self.scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
  def self.implements?(_type, _token); end
end

class Regexp::Syntax::Base
  def method_missing(name, *args); end
end

class Regexp::Syntax::Base
  def self.added_features(); end

  def self.check!(type, token); end

  def self.check?(type, token); end

  def self.excludes(type, tokens); end

  def self.features(); end

  def self.features=(features); end

  def self.implementations(type); end

  def self.implements(type, tokens); end

  def self.implements!(type, token); end

  def self.implements?(type, token); end

  def self.inherited(subclass); end

  def self.normalize(type, token); end

  def self.normalize_backref(type, token); end

  def self.normalize_group(type, token); end

  def self.removed_features(); end
end

Regexp::Syntax::CURRENT = Regexp::Syntax::V3_2_0

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Alternation
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Backref = Regexp::Syntax::Token::Backreference

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  NumberRef = ::T.let(nil, ::T.untyped)
  Plain = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V1_9_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::EscapeSequence = Regexp::Syntax::Token::Escape

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Alternation = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Property = Regexp::Syntax::Token::UnicodeProperty

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Set = Regexp::Syntax::Token::CharacterSet

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  Age_V3_1_0 = ::T.let(nil, ::T.untyped)
  Age_V3_2_0 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji_V2_6_0 = ::T.let(nil, ::T.untyped)
  Enumerated = ::T.let(nil, ::T.untyped)
  Enumerated_V2_4_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Script_V3_1_0 = ::T.let(nil, ::T.untyped)
  Script_V3_2_0 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_1_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_2_0 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
  V3_1_0 = ::T.let(nil, ::T.untyped)
  V3_2_0 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

module Regexp::Syntax
  def self.comparable(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.for(name); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(arg); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Regexp
  def self.linear_time?(*arg); end
end

module Reline
  DEFAULT_DIALOG_CONTEXT = ::T.let(nil, ::T.untyped)
  DEFAULT_DIALOG_PROC_AUTOCOMPLETE = ::T.let(nil, ::T.untyped)
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  IOGate = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  ANSI_CURSOR_KEY_BINDINGS = ::T.let(nil, ::T.untyped)
  CAPNAME_KEY_BINDINGS = ::T.let(nil, ::T.untyped)
  END_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
  START_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
end

class Reline::Config
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Core
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

class Reline::Dumb
  RESET_COLOR = ::T.let(nil, ::T.untyped)
end

class Reline::IO
  RESET_COLOR = ::T.let(nil, ::T.untyped)
end

module Reline::KeyActor
  EMACS_MAPPING = ::T.let(nil, ::T.untyped)
  VI_COMMAND_MAPPING = ::T.let(nil, ::T.untyped)
  VI_INSERT_MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyStroke
  CSI_INTERMEDIATE_BYTES_RANGE = ::T.let(nil, ::T.untyped)
  CSI_PARAMETER_BYTES_RANGE = ::T.let(nil, ::T.untyped)
  ESC_BYTE = ::T.let(nil, ::T.untyped)
  MATCHED = ::T.let(nil, ::T.untyped)
  MATCHING = ::T.let(nil, ::T.untyped)
  MATCHING_MATCHED = ::T.let(nil, ::T.untyped)
  UNMATCHED = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

class Reline::LineEditor
  DIALOG_DEFAULT_HEIGHT = ::T.let(nil, ::T.untyped)
  MAX_INPUT_LINES = ::T.let(nil, ::T.untyped)
  MINIMUM_SCROLLBAR_HEIGHT = ::T.let(nil, ::T.untyped)
  NullActionState = ::T.let(nil, ::T.untyped)
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
end

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

module Reline::Terminfo
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Reline::Unicode
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
  HalfwidthDakutenHandakuten = ::T.let(nil, ::T.untyped)
  MBCharWidthRE = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::IPv6
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(**kw); end

  def parse(raise_errors: T.unsafe(nil)); end

  def scan(**kw); end

  def tokenize(**kw); end
end

class Ripper::Lexer::Elem
  def [](index); end

  def event(); end

  def event=(event); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pos(); end

  def pos=(pos); end

  def state(); end

  def state=(state); end

  def to_a(); end

  def tok(); end

  def tok=(tok); end
end

class Ripper::Lexer::Elem
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Ripper::Lexer::State
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg, **arg1); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AndNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::ArgNode
  def default?(); end

  def default_value(); end

  def name(); end
end

class RuboCop::AST::ArgsNode
  def argument_list(); end

  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
end

class RuboCop::AST::AsgnNode
  def expression(); end

  def name(); end
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

class RuboCop::AST::BlockNode
  def argument_list(); end

  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def first_argument(); end

  def keywords?(); end

  def lambda?(); end

  def last_argument(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::CaseMatchNode
  def branches(); end

  def each_in_pattern(&block); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseNode
  def branches(); end

  def each_when(&block); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CasgnNode
  def expression(); end

  def name(); end

  def namespace(); end
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

module RuboCop::AST::CollectionNode
  def &(*arg, **arg1, &arg2); end

  def *(*arg, **arg1, &arg2); end

  def +(*arg, **arg1, &arg2); end

  def -(*arg, **arg1, &arg2); end

  def <<(*arg, **arg1, &arg2); end

  def [](*arg, **arg1, &arg2); end

  def []=(*arg, **arg1, &arg2); end

  def all?(*arg, **arg1, &arg2); end

  def any?(*arg, **arg1, &arg2); end

  def append(*arg, **arg1, &arg2); end

  def assoc(*arg, **arg1, &arg2); end

  def at(*arg, **arg1, &arg2); end

  def bsearch(*arg, **arg1, &arg2); end

  def bsearch_index(*arg, **arg1, &arg2); end

  def chain(*arg, **arg1, &arg2); end

  def chunk(*arg, **arg1, &arg2); end

  def chunk_while(*arg, **arg1, &arg2); end

  def clear(*arg, **arg1, &arg2); end

  def collect(*arg, **arg1, &arg2); end

  def collect!(*arg, **arg1, &arg2); end

  def collect_concat(*arg, **arg1, &arg2); end

  def combination(*arg, **arg1, &arg2); end

  def compact(*arg, **arg1, &arg2); end

  def compact!(*arg, **arg1, &arg2); end

  def compact_blank(*arg, **arg1, &arg2); end

  def compact_blank!(*arg, **arg1, &arg2); end

  def concat(*arg, **arg1, &arg2); end

  def count(*arg, **arg1, &arg2); end

  def cycle(*arg, **arg1, &arg2); end

  def deconstruct(*arg, **arg1, &arg2); end

  def delete(*arg, **arg1, &arg2); end

  def delete_at(*arg, **arg1, &arg2); end

  def delete_if(*arg, **arg1, &arg2); end

  def detect(*arg, **arg1, &arg2); end

  def difference(*arg, **arg1, &arg2); end

  def dig(*arg, **arg1, &arg2); end

  def drop(*arg, **arg1, &arg2); end

  def drop_while(*arg, **arg1, &arg2); end

  def each(*arg, **arg1, &arg2); end

  def each_cons(*arg, **arg1, &arg2); end

  def each_entry(*arg, **arg1, &arg2); end

  def each_index(*arg, **arg1, &arg2); end

  def each_slice(*arg, **arg1, &arg2); end

  def each_with_index(*arg, **arg1, &arg2); end

  def each_with_object(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def entries(*arg, **arg1, &arg2); end

  def exclude?(*arg, **arg1, &arg2); end

  def excluding(*arg, **arg1, &arg2); end

  def extract_options!(*arg, **arg1, &arg2); end

  def fetch(*arg, **arg1, &arg2); end

  def fifth(*arg, **arg1, &arg2); end

  def fill(*arg, **arg1, &arg2); end

  def filter(*arg, **arg1, &arg2); end

  def filter!(*arg, **arg1, &arg2); end

  def filter_map(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_all(*arg, **arg1, &arg2); end

  def find_index(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def flat_map(*arg, **arg1, &arg2); end

  def flatten(*arg, **arg1, &arg2); end

  def flatten!(*arg, **arg1, &arg2); end

  def forty_two(*arg, **arg1, &arg2); end

  def fourth(*arg, **arg1, &arg2); end

  def from(*arg, **arg1, &arg2); end

  def grep(*arg, **arg1, &arg2); end

  def grep_v(*arg, **arg1, &arg2); end

  def group_by(*arg, **arg1, &arg2); end

  def in_order_of(*arg, **arg1, &arg2); end

  def include?(*arg, **arg1, &arg2); end

  def including(*arg, **arg1, &arg2); end

  def index(*arg, **arg1, &arg2); end

  def index_by(*arg, **arg1, &arg2); end

  def index_with(*arg, **arg1, &arg2); end

  def inject(*arg, **arg1, &arg2); end

  def insert(*arg, **arg1, &arg2); end

  def intersect?(*arg, **arg1, &arg2); end

  def intersection(*arg, **arg1, &arg2); end

  def join(*arg, **arg1, &arg2); end

  def keep_if(*arg, **arg1, &arg2); end

  def last(*arg, **arg1, &arg2); end

  def lazy(*arg, **arg1, &arg2); end

  def length(*arg, **arg1, &arg2); end

  def many?(*arg, **arg1, &arg2); end

  def map(*arg, **arg1, &arg2); end

  def map!(*arg, **arg1, &arg2); end

  def max(*arg, **arg1, &arg2); end

  def max_by(*arg, **arg1, &arg2); end

  def maximum(*arg, **arg1, &arg2); end

  def member?(*arg, **arg1, &arg2); end

  def min(*arg, **arg1, &arg2); end

  def min_by(*arg, **arg1, &arg2); end

  def minimum(*arg, **arg1, &arg2); end

  def minmax(*arg, **arg1, &arg2); end

  def minmax_by(*arg, **arg1, &arg2); end

  def none?(*arg, **arg1, &arg2); end

  def one?(*arg, **arg1, &arg2); end

  def pack(*arg, **arg1, &arg2); end

  def partition(*arg, **arg1, &arg2); end

  def permutation(*arg, **arg1, &arg2); end

  def pick(*arg, **arg1, &arg2); end

  def pluck(*arg, **arg1, &arg2); end

  def pop(*arg, **arg1, &arg2); end

  def prepend(*arg, **arg1, &arg2); end

  def product(*arg, **arg1, &arg2); end

  def push(*arg, **arg1, &arg2); end

  def rassoc(*arg, **arg1, &arg2); end

  def reduce(*arg, **arg1, &arg2); end

  def reject(*arg, **arg1, &arg2); end

  def reject!(*arg, **arg1, &arg2); end

  def repeated_combination(*arg, **arg1, &arg2); end

  def repeated_permutation(*arg, **arg1, &arg2); end

  def replace(*arg, **arg1, &arg2); end

  def reverse(*arg, **arg1, &arg2); end

  def reverse!(*arg, **arg1, &arg2); end

  def reverse_each(*arg, **arg1, &arg2); end

  def rindex(*arg, **arg1, &arg2); end

  def rotate(*arg, **arg1, &arg2); end

  def rotate!(*arg, **arg1, &arg2); end

  def sample(*arg, **arg1, &arg2); end

  def second(*arg, **arg1, &arg2); end

  def second_to_last(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def select!(*arg, **arg1, &arg2); end

  def shelljoin(*arg, **arg1, &arg2); end

  def shift(*arg, **arg1, &arg2); end

  def shuffle(*arg, **arg1, &arg2); end

  def shuffle!(*arg, **arg1, &arg2); end

  def size(*arg, **arg1, &arg2); end

  def slice(*arg, **arg1, &arg2); end

  def slice!(*arg, **arg1, &arg2); end

  def slice_after(*arg, **arg1, &arg2); end

  def slice_before(*arg, **arg1, &arg2); end

  def slice_when(*arg, **arg1, &arg2); end

  def sole(*arg, **arg1, &arg2); end

  def sort(*arg, **arg1, &arg2); end

  def sort!(*arg, **arg1, &arg2); end

  def sort_by(*arg, **arg1, &arg2); end

  def sort_by!(*arg, **arg1, &arg2); end

  def sum(*arg, **arg1, &arg2); end

  def take(*arg, **arg1, &arg2); end

  def take_while(*arg, **arg1, &arg2); end

  def tally(*arg, **arg1, &arg2); end

  def third(*arg, **arg1, &arg2); end

  def third_to_last(*arg, **arg1, &arg2); end

  def to(*arg, **arg1, &arg2); end

  def to_ary(*arg, **arg1, &arg2); end

  def to_default_s(*arg, **arg1, &arg2); end

  def to_formatted_s(*arg, **arg1, &arg2); end

  def to_fs(*arg, **arg1, &arg2); end

  def to_h(*arg, **arg1, &arg2); end

  def to_msgpack(*arg, **arg1, &arg2); end

  def to_sentence(*arg, **arg1, &arg2); end

  def to_set(*arg, **arg1, &arg2); end

  def to_xml(*arg, **arg1, &arg2); end

  def transpose(*arg, **arg1, &arg2); end

  def union(*arg, **arg1, &arg2); end

  def uniq(*arg, **arg1, &arg2); end

  def uniq!(*arg, **arg1, &arg2); end

  def unshift(*arg, **arg1, &arg2); end

  def values_at(*arg, **arg1, &arg2); end

  def without(*arg, **arg1, &arg2); end

  def zip(*arg, **arg1, &arg2); end

  def |(*arg, **arg1, &arg2); end
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

class RuboCop::AST::ConstNode
  def absolute?(); end

  def class_name?(); end

  def each_path(&block); end

  def module_name?(); end

  def namespace(); end

  def relative?(); end

  def short_name(); end
end

class RuboCop::AST::DefNode
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def endless?(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefinedNode
  def arguments(); end
end

module RuboCop::AST::Descendence
  def child_nodes(); end

  def descendants(); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def visit_descendants(types, &block); end
end

class RuboCop::AST::EnsureNode
  def body(); end

  def void_context?(); end
end

module RuboCop::AST::Ext::Range
  def line_span(exclude_end: T.unsafe(nil)); end
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(&block); end

  def each_pair(); end

  def each_value(&block); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::IfNode
  def branches(); end

  def each_branch(&block); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::InPatternNode
  def body(); end

  def branch_index(); end

  def pattern(); end

  def then?(); end
end

class RuboCop::AST::IndexNode
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexasgnNode
  def attribute_accessor?(); end
end

class RuboCop::AST::KeywordSplatNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
end

class RuboCop::AST::LambdaNode
  def attribute_accessor?(); end
end

module RuboCop::AST::MethodDispatchNode
  def access_modifier?(); end

  def adjacent_def_modifier?(param0=T.unsafe(nil)); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier(node=T.unsafe(nil)); end

  def def_modifier?(node=T.unsafe(nil)); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def in_macro_scope?(param0=T.unsafe(nil)); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def selector(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerable_method?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def nonmutating_array_method?(); end

  def nonmutating_binary_operator_method?(); end

  def nonmutating_hash_method?(); end

  def nonmutating_operator_method?(); end

  def nonmutating_string_method?(); end

  def nonmutating_unary_operator_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::Node
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def argument_type?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(param0=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def class_constructor?(param0=T.unsafe(nil)); end

  def class_definition?(param0=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def find_pattern_type?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_arg_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def forwarded_kwrestarg_type?(); end

  def forwarded_restarg_type?(); end

  def global_const?(param0=T.unsafe(nil), param1); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwargs_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(param0=T.unsafe(nil)); end

  def lambda_or_proc?(param0=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def left_sibling(); end

  def left_siblings(); end

  def line_count(); end

  def literal?(); end

  def loop_keyword?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(param0=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_pattern_p_type?(); end

  def match_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_definition?(param0=T.unsafe(nil)); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(param0=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent?(); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def post_condition_loop?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(param0=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(param0=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def right_sibling(); end

  def right_siblings(); end

  def root?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(param0=T.unsafe(nil)); end

  def str_type?(); end

  def struct_constructor?(param0=T.unsafe(nil)); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
  def ==(other); end

  def as_json(_options=T.unsafe(nil)); end

  def ast(); end

  def captures(*arg, **arg1, &arg2); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def initialize(str, compiler: T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args, **rest, &block); end

  def match_code(); end

  def named_parameters(*arg, **arg1, &arg2); end

  def pattern(); end

  def positional_parameters(*arg, **arg1, &arg2); end
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Builder
  def emit_atom(type, value); end

  def emit_call(type, selector, args=T.unsafe(nil)); end

  def emit_capture(capture_token, node); end

  def emit_list(type, _begin, children, _end); end

  def emit_subsequence(node_list); end

  def emit_unary_op(type, _operator=T.unsafe(nil), *children); end

  def emit_union(begin_t, pattern_lists, end_t); end
end

class RuboCop::AST::NodePattern::Comment
  def ==(other); end

  def initialize(range); end

  def loc(); end

  def location(); end

  def text(); end
end

class RuboCop::AST::NodePattern::Compiler
  def bind(*arg, **arg1, &arg2); end

  def captures(); end

  def compile_as_atom(node); end

  def compile_as_node_pattern(node, **options); end

  def compile_sequence(sequence, var:); end

  def each_union(enum, &block); end

  def named_parameter(name); end

  def named_parameters(); end

  def next_capture(); end

  def parser(); end

  def positional_parameter(number); end

  def positional_parameters(); end

  def with_temp_variables(*names, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Binding
  def bind(name); end

  def union_bind(enum); end
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*arg, **arg1, &arg2); end

  def node_ids(); end

  def tokens(*arg, **arg1, &arg2); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
  def access(); end

  def initialize(compiler, var: T.unsafe(nil), access: T.unsafe(nil), seq_head: T.unsafe(nil)); end

  def seq_head(); end
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  def compile_sequence(); end

  def compile_terms(children=T.unsafe(nil), last_arity=T.unsafe(nil)); end

  def cur_index(); end

  def in_sync(); end

  def initialize(compiler, sequence:, var:); end

  def sync(); end
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def compile(node); end

  def compiler(); end

  def initialize(compiler); end
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def self.inherited(base); end

  def self.method_added(method); end

  def self.registry(); end
end

class RuboCop::AST::NodePattern::Lexer
  def comments(); end

  def initialize(source); end

  def source_buffer(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::LexerRex
  def action(); end

  def filename(); end

  def filename=(filename); end

  def location(); end

  def match(); end

  def matches(); end

  def next_token(); end

  def parse(str); end

  def parse_file(path); end

  def scanner_class(); end

  def ss(); end

  def ss=(ss); end

  def state(); end

  def state=(state); end
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str, **keyword_defaults); end

  def def_node_search(method_name, pattern_str, **keyword_defaults); end
end

module RuboCop::AST::NodePattern::MethodDefiner
  def as_lambda(); end

  def compile_as_lambda(); end

  def def_node_matcher(base, method_name, **defaults); end

  def def_node_search(base, method_name, **defaults); end
end

class RuboCop::AST::NodePattern::Node
  def arity(); end

  def arity_range(); end

  def capture?(); end

  def child(); end

  def children_nodes(); end

  def in_sequence_head(); end

  def matches_within_set?(); end

  def nb_captures(); end

  def rest?(); end

  def source_range(); end

  def variadic?(); end

  def with(type: T.unsafe(nil), children: T.unsafe(nil), location: T.unsafe(nil)); end
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::AnyOrder
  def ends_with_rest?(); end

  def rest_node(); end

  def term_nodes(); end
end

class RuboCop::AST::NodePattern::Node::Capture
  def arity(*arg, **arg1, &arg2); end

  def rest?(*arg, **arg1, &arg2); end
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def in_sequence_head(); end
end

class RuboCop::AST::NodePattern::Node::Predicate
  def arg_list(); end

  def method_name(); end
end

class RuboCop::AST::NodePattern::Node::Repetition
  def operator(); end
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser
  def _reduce_10(val, _values); end

  def _reduce_11(val, _values); end

  def _reduce_13(val, _values); end

  def _reduce_14(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_19(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_20(val, _values); end

  def _reduce_21(val, _values); end

  def _reduce_22(val, _values); end

  def _reduce_25(val, _values); end

  def _reduce_26(val, _values); end

  def _reduce_3(val, _values); end

  def _reduce_33(val, _values); end

  def _reduce_37(val, _values); end

  def _reduce_38(val, _values); end

  def _reduce_39(val, _values); end

  def _reduce_4(val, _values); end

  def _reduce_40(val, _values); end

  def _reduce_41(val, _values); end

  def _reduce_42(val, _values); end

  def _reduce_43(val, _values); end

  def _reduce_44(val, _values); end

  def _reduce_45(val, _values); end

  def _reduce_46(val, _values); end

  def _reduce_5(val, _values); end

  def _reduce_6(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def emit_atom(*arg, **arg1, &arg2); end

  def emit_call(*arg, **arg1, &arg2); end

  def emit_capture(*arg, **arg1, &arg2); end

  def emit_list(*arg, **arg1, &arg2); end

  def emit_unary_op(*arg, **arg1, &arg2); end

  def emit_union(*arg, **arg1, &arg2); end

  def initialize(builder=T.unsafe(nil)); end

  def next_token(*arg, **arg1, &arg2); end

  def parse(source); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ANY_EMPTY = ::T.let(nil, ::T.untyped)
  SET_ANY_EMPTY_NONE_ETC = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_BRANCH_REF_TAG = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_CLONE_DUP_FREEZE = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_EXIST_EXISTS = ::T.let(nil, ::T.untyped)
  SET_FILETEST_FILE_DIR_SHELL = ::T.let(nil, ::T.untyped)
  SET_FILE_DIR = ::T.let(nil, ::T.untyped)
  SET_FILE_FILETEST = ::T.let(nil, ::T.untyped)
  SET_FILE_TEMPFILE = ::T.let(nil, ::T.untyped)
  SET_FILE_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GETHOSTBYADDR_GETHOSTBYNAME = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_MAP_FILTER_MAP = ::T.let(nil, ::T.untyped)
  SET_MODULE_FUNCTION_RUBY2_KEYWORDS = ::T.let(nil, ::T.untyped)
  SET_NEW_ = ::T.let(nil, ::T.untyped)
  SET_NEW_COMPILE = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRESENT_ANY_BLANK_EMPTY = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PRIVATE_CLASS_METHOD = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_READ_BINREAD = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REJECT_DELETE_IF_REJECT = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_SELECT_FILTER_FIND_ALL = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_H_TO_HASH = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C_TO_R = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__FETCH = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET__PUSH_APPEND = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___8 = ::T.let(nil, ::T.untyped)
  SET___EQL_ETC = ::T.let(nil, ::T.untyped)
  SET___EQL_INCLUDE = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____2 = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
  SET____ETC_4 = ::T.let(nil, ::T.untyped)
  SET_____2 = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Sets
  def self.[](set); end

  def self.name(set); end

  def self.uniq(name); end
end

class RuboCop::AST::NodePattern
  def self.descend(element, &block); end
end

module RuboCop::AST::NumericNode
  def sign?(); end
end

class RuboCop::AST::OpAsgnNode
  def assignment_node(); end

  def expression(); end

  def name(); end

  def operator(); end
end

class RuboCop::AST::OrNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::PairNode
  def colon?(); end

  def delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def value_omission?(); end

  def value_on_new_line?(); end
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
  def arguments(); end

  def arguments?(); end

  def first_argument(); end

  def last_argument(); end
  EMPTY_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
  def arguments(); end
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
end

class RuboCop::AST::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_at_line(line); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def contains_comment?(source_range); end

  def current_line(token); end

  def diagnostics(); end

  def each_comment(&block); end

  def each_comment_in_lines(line_range); end

  def each_token(&block); end

  def file_path(); end

  def find_comment(&block); end

  def find_token(&block); end

  def first_token_of(range_or_node); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil), parser_engine: T.unsafe(nil)); end

  def last_token_of(range_or_node); end

  def line_indentation(line_number); end

  def line_with_comment?(line); end

  def lines(); end

  def parser_engine(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def sorted_tokens(); end

  def start_with?(string); end

  def tokens(); end

  def tokens_within(range_or_node); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  def self.from_file(path, ruby_version, parser_engine: T.unsafe(nil)); end
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RegexpNode
  def content(); end

  def delimiter?(char); end

  def delimiters(); end

  def extended?(); end

  def fixed_encoding?(); end

  def ignore_case?(); end

  def interpolation?(); end

  def multiline_mode?(); end

  def no_encoding?(); end

  def options(); end

  def percent_r_literal?(); end

  def regopt(); end

  def single_interpolation?(); end

  def slash_literal?(); end

  def to_regexp(); end
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def branch_index(); end

  def exception_variable(); end

  def exceptions(); end
end

class RuboCop::AST::RescueNode
  def body(); end

  def branches(); end

  def else?(); end

  def else_branch(); end

  def resbody_branches(); end
end

module RuboCop::AST::RuboCopCompatibility
  def rubocop_loaded(); end
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SendNode
  def attribute_accessor?(param0=T.unsafe(nil)); end
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

class RuboCop::AST::StrNode
  def character_literal?(); end

  def heredoc?(); end
end

class RuboCop::AST::SuperNode
  def arguments(); end
end

class RuboCop::AST::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def dot?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def new_line?(); end

  def pos(); end

  def regexp_dots?(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
  LEFT_PAREN_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Token
  def self.from_parser_token(parser_token); end
end

module RuboCop::AST::Traversal
  def on_(node); end

  def on___ENCODING__(node); end

  def on___FILE__(node); end

  def on___LINE__(node); end

  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_find_pattern(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_forwarded_kwrestarg(node); end

  def on_forwarded_restarg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwnilarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_mrasgn(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rasgn(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::UntilNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(&block); end

  def then?(); end
end

class RuboCop::AST::WhileNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::YieldNode
  def arguments(); end
end

class RuboCop::ArgumentsEnv
  def self.read_as_arguments(); end
end

class RuboCop::ArgumentsFile
  def self.read_as_arguments(); end
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  DEFAULT_PARALLEL_OPTIONS = ::T.let(nil, ::T.untyped)
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_1_SKIPPED_ONLY_COPS = ::T.let(nil, ::T.untyped)
  PHASE_1_SKIPPED_ONLY_EXCLUDE = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
  PLACEHOLDER = ::T.let(nil, ::T.untyped)
  YAML_OPTIONAL_DOC_START = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  def run(); end
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::LSP
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowDocsUrl
  def run(); end
end

class RuboCop::CLI::Command::SuggestExtensions
  def run(); end
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::Version
  def run(); end
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CacheConfig
  def self.root_dir(); end
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CommentConfig
  def comment_only_line?(line_number); end

  def config(); end

  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def cop_opted_in?(cop); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end

  def registry(); end
  CONFIG_DISABLED_LINE_RANGE_MIN = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment
  def initialize(cop_name); end

  def line_number(); end

  def loc(); end

  def text(); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression
  def line(); end

  def line=(_); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc
  def expression(); end

  def expression=(_); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Config
  def [](*arg, **arg1, &arg2); end

  def []=(*arg, **arg1, &arg2); end

  def active_support_extensions_enabled?(); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def clusivity_config_for_badge?(badge); end

  def delete(*arg, **arg1, &arg2); end

  def deprecation_check(); end

  def dig(*arg, **arg1, &arg2); end

  def disabled_new_cops?(); end

  def each(*arg, **arg1, &arg2); end

  def each_key(*arg, **arg1, &arg2); end

  def enabled_new_cops?(); end

  def fetch(*arg, **arg1, &arg2); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_badge(badge); end

  def for_cop(cop); end

  def for_department(department_name); end

  def gem_versions_in_target(); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*arg, **arg1, &arg2); end

  def keys(*arg, **arg1, &arg2); end

  def loaded_features(); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*arg, **arg1, &arg2); end

  def merge(*arg, **arg1, &arg2); end

  def parser_engine(); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def replace(*arg, **arg1, &arg2); end

  def signature(); end

  def smart_loaded_path(); end

  def string_literals_frozen_by_default?(); end

  def target_rails_version(); end

  def target_ruby_version(); end

  def to_h(*arg, **arg1, &arg2); end

  def to_hash(*arg, **arg1, &arg2); end

  def transform_values(*arg, **arg1, &arg2); end

  def validate(*arg, **arg1, &arg2); end

  def validate_after_resolution(); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Config
  def self.create(hash, path, check: T.unsafe(nil)); end
end

class RuboCop::ConfigFinder
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigFinder
  extend ::RuboCop::FileFinder
  def self.find_config_path(target_dir); end

  def self.project_root(); end

  def self.project_root=(project_root); end
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_loaded_features(loaded_features); end

  def self.add_missing_namespaces(path, hash); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file, check: T.unsafe(nil)); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.ignore_unrecognized_cops(); end

  def self.ignore_unrecognized_cops=(ignore_unrecognized_cops); end

  def self.inject_defaults!(project_root); end

  def self.load_file(file, check: T.unsafe(nil)); end

  def self.load_yaml_configuration(absolute_path); end

  def self.loaded_features(); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.pending_cops_only_qualified(pending_cops); end

  def self.possible_new_cops?(config); end

  def self.project_root(); end

  def self.warn_on_pending_cops(pending_cops); end

  def self.warn_pending_cop(cop); end
end

class RuboCop::ConfigLoaderResolver
  def fix_include_paths(base_config_path, hash, path, key, value); end

  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def override_department_setting_for_cops(base_hash, derived_hash); end

  def override_enabled_for_disabled_departments(base_hash, derived_hash); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete!(); end

  def rules(); end

  def warnings(); end
  COP_RULE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RULES_FILE = ::T.let(nil, ::T.untyped)
  PARAMETER_RULE_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedParameter
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name); end

  def message(); end

  def old_name(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::ExtractedCop
  def department(); end

  def gem(); end

  def initialize(config, old_name, gem); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::ParameterRule
  def cop(); end

  def initialize(config, cop, parameter, metadata); end

  def metadata(); end

  def parameter(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::RemovedCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::RenamedCop
  def initialize(config, old_name, new_name); end

  def new_name(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::Rule
  def cop_rule?(); end

  def initialize(config); end

  def parameter_rule?(); end

  def violated?(); end
end

class RuboCop::ConfigObsoletion::SplitCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion
  def self.files(); end

  def self.files=(files); end

  def self.legacy_cop_names(); end
end

class RuboCop::ConfigRegeneration
  def options(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def for_dir(dir); end

  def for_file(file); end

  def for_pwd(); end

  def force_default_config!(); end

  def options_config=(options_config); end

  def unvalidated(); end

  def validated(); end

  def validated?(); end
end

class RuboCop::ConfigValidator
  def for_all_cops(); end

  def initialize(config); end

  def smart_loaded_path(); end

  def target_ruby_version(); end

  def validate(); end

  def validate_after_resolution(); end

  def validate_section_presence(name); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  CONFIG_CHECK_AUTOCORRECTS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AlignmentCorrector
  def self.align_end(corrector, processed_source, node, align_to); end

  def self.correct(corrector, processed_source, node, column_delta); end

  def self.processed_source(); end
end

module RuboCop::Cop::AllowedIdentifiers
  def allowed_identifier?(name); end

  def allowed_identifiers(); end
  SIGILS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::AllowedReceivers
  def allowed_receiver?(receiver); end

  def allowed_receivers(); end

  def receiver_name(receiver); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AnnotationComment
  def annotation?(); end

  def bounds(); end

  def colon(); end

  def comment(); end

  def correct?(colon:); end

  def initialize(comment, keywords); end

  def keyword(); end

  def margin(); end

  def note(); end

  def space(); end
end

module RuboCop::Cop::AutoCorrector
  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def autocorrect_with_disable_uncorrectable?(); end

  def correctable?(); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def department_name(); end

  def eql?(other); end

  def initialize(class_name_parts); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge
  def self.camel_case(name_part); end

  def self.for(class_name); end

  def self.parse(identifier); end
end

class RuboCop::Cop::Base
  def active_support_extensions_enabled?(); end

  def add_global_offense(message=T.unsafe(nil), severity: T.unsafe(nil)); end

  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def always_autocorrect?(); end

  def begin_investigation(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  def callbacks_needed(); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def contextual_autocorrect?(); end

  def cop_config(); end

  def cop_name(); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def message(_range=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def on_investigation_end(); end

  def on_new_investigation(); end

  def on_other_file(); end

  def parse(source, path=T.unsafe(nil)); end

  def parser_engine(); end

  def processed_source(); end

  def ready(); end

  def relevant_file?(file); end

  def string_literals_frozen_by_default?(); end

  def target_rails_version(); end

  def target_ruby_version(); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base::InvestigationReport
  def cop(); end

  def cop=(_); end

  def corrector(); end

  def corrector=(_); end

  def offenses(); end

  def offenses=(_); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Base::InvestigationReport
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Base
  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.callbacks_needed(); end

  def self.cop_name(); end

  def self.department(); end

  def self.documentation_url(config=T.unsafe(nil)); end

  def self.exclude_from_registry(); end

  def self.gem_requirements(); end

  def self.inherited(subclass); end

  def self.joining_forces(); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.requires_gem(gem_name, *version_requirements); end

  def self.support_autocorrect?(); end

  def self.support_multiple_source?(); end
end

class RuboCop::Cop::Bundler::DuplicatedGem
  def gem_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGroup
  def group_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
  SOURCE_BLOCK_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
  def on_send(node); end
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemFilename
  GEMFILE_FILES = ::T.let(nil, ::T.untyped)
  GEMS_RB_FILES = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_REQUIRED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemVersion
  def includes_commit_reference?(param0=T.unsafe(nil)); end

  def includes_version_specification?(param0=T.unsafe(nil)); end

  def on_send(node); end
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  def insecure_protocol_source?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_HTTP_PROTOCOL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
  def gem_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CodeLength
  def max=(value); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CommentsHelp
  def comments_contain_disables?(node, cop_name); end

  def comments_in_range(node); end

  def contains_comments?(node); end

  def source_range_with_comment(node); end
end

class RuboCop::Cop::Commissioner
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def cop_reports(); end

  def cop_reports=(_); end

  def cops(); end

  def correctors(); end

  def errors(); end

  def errors=(_); end

  def merge(investigation); end

  def offenses(); end

  def offenses_per_cop(); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(corrector, node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableFormatting
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableNaming
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
  FORMATS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Cop
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def corrections(); end

  def find_location(node, loc); end

  def support_autocorrect?(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  def self.all(); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def initialize(source); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def rewrite(); end

  def swap(node_or_range1, node_or_range2); end
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  def self.source_buffer(source); end
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::Documentation
  def self.base_url_for(cop_class, config); end

  def self.builtin?(cop_class); end

  def self.default_base_url(); end

  def self.default_extension(); end

  def self.department_to_basename(department); end

  def self.extension_for(cop_class, config); end

  def self.url_for(cop_class, config=T.unsafe(nil)); end
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(corrector, node); end

  def self.insert_before(corrector, node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::EndKeywordAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force::HookError
  def initialize(joining_cop); end

  def joining_cop(); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::GemDeclaration
  def gem_declaration?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Gemspec::AddRuntimeDependency
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DependencyVersion
  def add_dependency_method_declaration?(param0=T.unsafe(nil)); end

  def includes_commit_reference?(param0=T.unsafe(nil)); end

  def includes_version_specification?(param0=T.unsafe(nil)); end

  def on_send(node); end
  ADD_DEPENDENCY_METHODS = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment
  def gem_specification(param0=T.unsafe(nil)); end

  def on_block(block_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DevelopmentDependencies
  def add_development_dependency?(param0=T.unsafe(nil)); end

  def gem?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  def assignment_method_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  def dependency_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequireMFA
  def metadata(param0=T.unsafe(nil)); end

  def on_block(node); end

  def rubygems_mfa_required(param0); end

  def true_string?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def defined_ruby_version(param0=T.unsafe(nil)); end

  def on_send(node); end

  def required_ruby_version?(param0); end
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def on_const(node); end

  def ruby_version?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::GemspecHelp
  def gem_specification(param0); end

  def gem_specification?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Generator
  def initialize(name, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added: T.unsafe(nil)); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment
  def deltas(first_pair, current_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  def deltas_for_first_pair(first_pair, node); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashShorthandSyntax
  def on_hash_for_mixed_shorthand(hash_node); end

  def on_pair(node); end
  DO_NOT_MIX_EXPLICIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_MSG_PREFIX = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_OMIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  EXPLICIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
  OMIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashShorthandSyntax::DefNode
  def first_argument(); end

  def last_argument(); end

  def node(); end

  def node=(_); end

  def selector(); end
end

class RuboCop::Cop::HashShorthandSyntax::DefNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
  def array_receiver?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*arg); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.from_to_h(node, match); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end

  def use_transformed_argname?(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::IfThenCorrector
  def call(corrector); end

  def initialize(if_node, indentation: T.unsafe(nil)); end
  DEFAULT_INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
end

RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
  def on_array(node); end
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  def block_end_align_target?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  def on_case(case_node); end

  def on_case_match(case_match_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  def on_class(class_node); end

  def on_sclass(class_node); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DotPosition
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::ElseAlignment
  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_DIRECTIVE_COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  def on_case(node); end

  def on_if(node); end

  def on_rescue(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  def autocorrect(corrector, prev_def, node, count); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  def on_block(node); end

  def on_numblock(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  def constant_definition?(param0=T.unsafe(nil)); end

  def empty_line_required?(param0=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndAlignment
  def on_case(node); end

  def on_case_match(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndOfLine
  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  def eligible_method_call?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offenses_by(); end

  def offenses_by=(offenses_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  SEPARATOR_ALIGNMENT_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  def on_heredoc(node); end
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
  def access_modifier?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_case(case_node); end

  def on_case_match(case_match); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineContinuationLeadingSpace
  def on_dstr(node); end
end

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation
  def autocorrect(corrector, node); end

  def on_dstr(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
  PARENT_TYPES_FOR_INDENTED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  def max=(value); end

  def on_array(node); end

  def on_block(node); end

  def on_def(node); end

  def on_hash(node); end

  def on_numblock(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  def on_block(node); end

  def on_numblock(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::ParameterAlignment
  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RedundantLineBreak
  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SingleLineBlockChain
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterComma
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_in_pattern(node); end

  def on_kwbegin(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_pattern(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  def on_block(node); end

  def on_numblock(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBrackets
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  def on_block(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  def on_send(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Legacy::CorrectionsProxy
  def <<(callable); end

  def concat(corrections); end

  def corrector(); end

  def empty?(); end

  def initialize(corrector); end
end

class RuboCop::Cop::LineBreakCorrector
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

class RuboCop::Cop::Lint::AmbiguousAssignment
  def on_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MISTAKES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence
  def on_and(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRange
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  def big_decimal_new(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  def on_and(node); end

  def on_or(node); end

  def on_send(node); end
  ALLOWED_MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(param0=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  def constant_assigned_in_block?(param0=T.unsafe(nil)); end

  def module_defined_in_block?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantOverwrittenInRescue
  def on_resbody(node); end

  def overwritten_constant(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
  def on_const(node); end

  def unqualified_const?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
  def on_send(node); end
  BLOCK_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def deprecated_class_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  DIR_ENV_FILE_CONSTANTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedConstants
  def on_const(node); end
  DO_NOT_USE_MSG = ::T.let(nil, ::T.untyped)
  SUGGEST_GOOD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  def algorithm_const(param0=T.unsafe(nil)); end

  def digest_const?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NO_ARG_ALGORITHM = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
  def on_branching_statement(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMatchPattern
  def on_case_match(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(param0=T.unsafe(nil)); end

  def method_alias?(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(param0=T.unsafe(nil)); end
  DEF_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  def each_repeated_character_class_element_loc(node); end

  def on_regexp(node); end
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
  OCTAL_DIGITS_AFTER_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
  def on_class(node); end

  def on_sclass(node); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInPattern
  def on_case_match(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  def erb_new_with_non_keyword_arguments(param0=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGE_EOUTVAR = ::T.let(nil, ::T.untyped)
  MESSAGE_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  MESSAGE_TRIM_MODE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
  def on_send(node); end
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(param0=T.unsafe(nil)); end

  def on_send(node); end
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  def id_as_hash_key?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler
  def io_select(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(param0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  def class_new_call?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ItWithoutArgumentsInBlock
  def deprecated_it_method?(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock
  def lambda_with_symbol_proc?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_case_match(case_match_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAssignmentInCondition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
  def class_new_block(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedCaseRange
  def each_unsafe_regexp_range(node); end

  def on_erange(node); end

  def on_irange(node); end

  def on_regexp(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RANGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  def on_regexp(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  def multiple_compare?(param0=T.unsafe(nil)); end

  def on_send(node); end
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SET_OPERATION_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def eval_call?(param0=T.unsafe(nil)); end

  def exec_call?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_block_body_of_reduce(param0=T.unsafe(nil)); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  def on_lvasgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonAtomicFileOperation
  def explicit_not_force?(param0); end

  def force?(param0); end

  def on_send(node); end

  def receiver_and_method_name(param0=T.unsafe(nil)); end

  def send_exist_node(param0); end
  MAKE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  MAKE_METHODS = ::T.let(nil, ::T.untyped)
  MSG_CHANGE_FORCE_METHOD = ::T.let(nil, ::T.untyped)
  MSG_REMOVE_FILE_EXIST_CHECK = ::T.let(nil, ::T.untyped)
  RECURSIVE_REMOVE_METHODS = ::T.let(nil, ::T.untyped)
  REMOVE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  REMOVE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def loop_variable(param0=T.unsafe(nil)); end

  def method_require?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_numblock(node); end

  def unsorted_dir_block?(param0=T.unsafe(nil)); end

  def unsorted_dir_each?(param0=T.unsafe(nil)); end

  def unsorted_dir_each_pass?(param0=T.unsafe(nil)); end

  def unsorted_dir_glob_pass?(param0=T.unsafe(nil)); end

  def var_is_required?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  def on_csend(node); end

  def on_send(node); end

  def to_method(param0=T.unsafe(nil)); end

  def to_method_symbol(param0=T.unsafe(nil)); end
  CONVERSION_METHODS = ::T.let(nil, ::T.untyped)
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberedParameterAssignment
  def on_lvasgn(node); end
  LVAR_MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_RANGE = ::T.let(nil, ::T.untyped)
  NUM_PARAM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrAssignmentToConstant
  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  def after_send(node); end

  def on_in_pattern(node); end

  def on_match_with_lvasgn(node); end

  def on_nth_ref(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(param0=T.unsafe(nil)); end

  def exception_new_with_message?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  def initialize(config=T.unsafe(nil), options=T.unsafe(nil), offenses=T.unsafe(nil)); end

  def offenses_to_check(); end

  def offenses_to_check=(offenses_to_check); end
  COP_NAME = ::T.let(nil, ::T.untyped)
  DEPARTMENT_MARKER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantDirGlobSort
  def on_send(node); end
  GLOB_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRegexpQuantifiers
  def on_regexp(node); end
  MSG_REDUNDANT_QUANTIFIER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  def on_send(node); end

  def pp_const?(param0=T.unsafe(nil)); end

  def redundant_require_statement?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PRETTY_PRINT_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  RUBY_22_LOADED_FEATURES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  def conversion_with_default?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_or(node); end

  def respond_to_nil_specific_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(param0=T.unsafe(nil)); end

  def literal_expansion(param0=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  def on_interpolation(begin_node); end

  def on_send(node); end

  def to_s_without_args?(param0=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  def on_block(node); end

  def on_numblock(node); end

  def redundant_with_index?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  def on_block(node); end

  def on_numblock(node); end

  def redundant_with_object?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RefinementImportMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRangeParentheses
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRelativeSelfPath
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  def autocorrect(corrector, node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  def bad_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PLUS_MINUS_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_csend(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  def on_send(node); end

  def send_with_mixin_argument?(param0=T.unsafe(nil)); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def uses_var?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def find_conditional_node_from_ascendant(node); end

  def node_or_its_ascendant_conditional?(node); end

  def ractor_block?(param0=T.unsafe(nil)); end

  def same_conditions_node_different_branch?(variable, outer_local_variable); end

  def variable_node(variable); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SymbolConversion
  def on_hash(node); end

  def on_send(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_CONSISTENCY = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
  def enum_conversion_call?(param0=T.unsafe(nil)); end

  def method_name?(param0=T.unsafe(nil), param1); end

  def on_send(node); end

  def passing_keyword_arg?(param0=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TripleQuotes
  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  def fixnum_or_bignum_const(param0=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  def accumulator_index?(param0=T.unsafe(nil), param1); end

  def element_modified?(param0, param1); end

  def expression_values(param0); end

  def lvar_used?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end

  def reduce_with_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
  def break_command?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  CONTINUE_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  def not_implemented?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(param0=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(param0=T.unsafe(nil)); end

  def dynamic_method_definition?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_sclass(node); end

  def static_method_definition?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(corrector, assignment); end

  def chained_assignment?(node); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def offense_range(assignment); end

  def operator_assignment_message(scope, assignment); end

  def remove_exception_assignment_part(corrector, node); end

  def remove_local_variable_assignment_part(corrector, node); end

  def remove_trailing_character_from_operator(corrector, node); end

  def rename_variable_with_underscore(corrector, node); end

  def replace_named_capture_group_with_non_capturing_group(corrector, node, variable_name); end

  def return_value_node_of_scope(scope); end

  def sequential_assignment?(node); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessNumericOperation
  def on_op_asgn(node); end

  def on_send(node); end

  def useless_abbreviated_assignment?(param0=T.unsafe(nil)); end

  def useless_operation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRescue
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRuby2Keywords
  def method_definition(param0=T.unsafe(nil), param1); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(param0=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessTimes
  def block_arg(param0=T.unsafe(nil)); end

  def block_reassigns_arg?(param0, param1); end

  def on_send(node); end

  def times_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_ensure(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  CONST_MSG = ::T.let(nil, ::T.untyped)
  EXPRESSION_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  METHODS_REPLACEABLE_BY_EACH = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS_WITH_BANG_VERSION = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  def define_method?(param0=T.unsafe(nil)); end

  def max=(value); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Metrics::AbcSize
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
  def on_block(node); end

  def on_numblock(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
  def max=(value); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ClassLength
  def on_casgn(node); end

  def on_class(node); end

  def on_sclass(node); end
end

class RuboCop::Cop::Metrics::CollectionLiteralLength
  def on_array(node); end

  def on_hash(node); end

  def on_index(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_numblock(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ModuleLength
  def module_definition?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ParameterLists
  def argument_to_lambda_or_proc?(param0=T.unsafe(nil)); end

  def max=(value); end

  def max_optional_parameters=(value); end

  def on_args(node); end

  def on_def(node); end

  def on_defs(node); end

  def struct_new_or_data_define_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  def calculate(); end

  def else_branch?(node); end

  def evaluate_condition_node(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node, discount_repeated_attributes: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  def calculate(); end

  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  def block_method_name(node); end

  def iterating_block?(node); end

  def iterating_method?(name); end
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  def attribute_call?(param0=T.unsafe(nil)); end

  def calculate_node(node); end

  def discount_repeated_attributes?(); end

  def evaluate_branch_nodes(node); end

  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  def root_node?(param0=T.unsafe(nil)); end
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def discount_for_repeated_csend?(csend_node); end

  def reset_on_lvasgn(node); end

  def reset_repeated_csend(); end
end

class RuboCop::Cop::Migration::DepartmentName
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_csend(node); end

  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def call(); end

  def initialize(corrector, node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def self.correct(corrector, node, processed_source); end
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(param0=T.unsafe(nil)); end
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockForwarding
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockParameterName
  def on_block(node); end
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(param0=T.unsafe(nil)); end

  def literal_receiver?(param0=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
  def struct_definition(param0=T.unsafe(nil)); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::InclusiveLanguage
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_FILE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation
  def position(); end

  def position=(_); end

  def word(); end

  def word=(_); end
end

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  def defined_memoized?(param0=T.unsafe(nil), param1); end

  def method_definition?(param0=T.unsafe(nil)); end

  def on_defined?(node); end

  def on_or_asgn(node); end
  DYNAMIC_DEFINE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(param0=T.unsafe(nil)); end

  def sym_name(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodParameterName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def validate_config(); end
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(param0=T.unsafe(nil)); end

  def single_negative?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def corrector(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil), corrector=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

class RuboCop::Cop::ParenthesesCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, node); end
end

class RuboCop::Cop::PercentLiteralCorrector
  def config(); end

  def correct(corrector, node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(corrector, token); end

  def self.remove_space(corrector, space_before); end

  def self.swap_comma(corrector, range); end
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def cops_for_department(department); end

  def department?(name); end

  def department_missing?(badge, name); end

  def departments(); end

  def disabled(config); end

  def dismiss(cop); end

  def each(&block); end

  def enabled(config); end

  def enabled?(cop, config); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def find_cops_by_directive(directive); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def names_for_department(department); end

  def options(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  def qualify_badge(badge); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
  def self.all(); end

  def self.global(); end

  def self.qualified_cop?(name); end

  def self.qualified_cop_name(name, origin); end

  def self.reset!(); end

  def self.with_temporary_global(temp_global=T.unsafe(nil)); end
end

module RuboCop::Cop::RequireLibrary
  def ensure_required(corrector, node, library_name); end

  def on_send(node); end

  def remove_subsequent_requires(corrector, node, library_name); end

  def require_any_library?(param0=T.unsafe(nil)); end

  def require_library_name?(param0=T.unsafe(nil), param1); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RequireLibraryCorrector
  def self.correct(corrector, node, library_name); end

  def self.require_statement(library_name); end
end

module RuboCop::Cop::RescueNode
  def modifier_locations(); end
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(param0=T.unsafe(nil)); end

  def safe_assignment?(param0=T.unsafe(nil)); end

  def setter_method?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::CompoundHash
  def bad_hash_combinator?(param0=T.unsafe(nil)); end

  def contained_in_hash_method?(node, &block); end

  def dynamic_hash_method_definition?(param0=T.unsafe(nil)); end

  def hash_method_definition?(param0=T.unsafe(nil)); end

  def monuple_hash?(param0=T.unsafe(nil)); end

  def on_op_asgn(node); end

  def on_send(node); end

  def outer_bad_hash_combinator?(node); end

  def redundant_hash?(param0=T.unsafe(nil)); end

  def static_hash_method_definition?(param0=T.unsafe(nil)); end
  COMBINATOR_IN_HASH_MSG = ::T.let(nil, ::T.untyped)
  MONUPLE_HASH_MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_HASH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
  def eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::IoMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  def json_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  def on_send(node); end

  def yaml_load(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::SpaceCorrector
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

class RuboCop::Cop::StringLiteralCorrector
  def self.correct(corrector, node, style); end
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  def access_modifier_with_attr?(param0=T.unsafe(nil)); end

  def access_modifier_with_symbol?(param0=T.unsafe(nil)); end

  def on_send(node); end
  ALLOWED_NODE_TYPES = ::T.let(nil, ::T.untyped)
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding
  def on_def(node); end

  def on_defs(node); end
  ADDITIONAL_ARG_TYPES = ::T.let(nil, ::T.untyped)
  ARGS_MSG = ::T.let(nil, ::T.untyped)
  BLOCK_MSG = ::T.let(nil, ::T.untyped)
  FORWARDING_LVAR_TYPES = ::T.let(nil, ::T.untyped)
  FORWARDING_MSG = ::T.let(nil, ::T.untyped)
  KWARGS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding::SendNodeClassifier
  def classification(); end

  def extract_forwarded_kwrest_arg(param0=T.unsafe(nil), param1); end

  def forwarded_block_arg(); end

  def forwarded_block_arg?(param0=T.unsafe(nil), param1); end

  def forwarded_kwrest_arg(); end

  def forwarded_rest_arg(); end

  def forwarded_rest_arg?(param0=T.unsafe(nil), param1); end

  def initialize(def_node, send_node, referenced_lvars, forwardable_args, **config); end
end

class RuboCop::Cop::Style::ArrayCoercion
  def array_splat?(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_if(node); end

  def unless_array?(param0=T.unsafe(nil)); end
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayFirstLast
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayIntersect
  def active_support_bad_intersection_check?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def regular_bad_intersection_check?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRAIGHT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  def join_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  def class_eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def file_open_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  def after_class(class_node); end

  def after_module(class_node); end

  def after_sclass(class_node); end

  def on_class(class_node); end

  def on_module(class_node); end

  def on_sclass(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  def all_bisected?(); end

  def attr_names(); end

  def attrs(); end

  def bisect(*names); end

  def bisected_names(); end

  def bisection(); end

  def initialize(node); end

  def node(); end

  def reader?(); end

  def rest(); end

  def visibility(); end

  def writer?(); end
end

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  def self.macro?(node); end
end

class RuboCop::Cop::Style::BlockComments
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  def on_block(node); end

  def on_numblock(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def self_class?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  def autocorrect(corrector, node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  def message(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  def class_comparison_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  CLASS_NAME_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  def on_defs(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
  def on_cvasgn(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  def grep_v_with_nil?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def reject_method?(param0=T.unsafe(nil)); end

  def reject_method_with_block_pass?(param0=T.unsafe(nil)); end

  def select_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TO_ENUM_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  def on_block(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  def java_type_node?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG_COLON_STYLE = ::T.let(nil, ::T.untyped)
  MSG_SPACE_STYLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ComparableClamp
  def array_min_max?(param0=T.unsafe(nil)); end

  def if_elsif_else_condition?(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MIN_MAX = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConcatArrayLiterals
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_PERCENT_LITERALS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  def assignment_type?(param0=T.unsafe(nil)); end

  def candidate_condition?(param0=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(param0=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DataInheritance
  def data_define?(param0=T.unsafe(nil)); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  def date_time?(param0=T.unsafe(nil)); end

  def historic_date?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def to_datetime?(param0=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  def dir_replacement?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DirEmpty
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  def on_send(node); end
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
  def constant_definition?(param0=T.unsafe(nil)); end

  def constant_visibility_declaration?(param0=T.unsafe(nil)); end

  def include_statement?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
  def modifier_node?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def each_range(param0=T.unsafe(nil)); end

  def each_range_with_zero_origin?(param0=T.unsafe(nil)); end

  def each_range_without_block_argument?(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  def each_with_object_block_candidate?(param0=T.unsafe(nil)); end

  def each_with_object_numblock_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_numblock(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_PARENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyHeredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  def array_node(param0=T.unsafe(nil)); end

  def array_with_block(param0=T.unsafe(nil)); end

  def array_with_index(param0=T.unsafe(nil)); end

  def hash_node(param0=T.unsafe(nil)); end

  def hash_with_block(param0=T.unsafe(nil)); end

  def hash_with_index(param0=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(param0=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndlessMethod
  def on_def(node); end
  CORRECTION_STYLES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EnvHome
  def env_home?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  def line_with_offset?(param0=T.unsafe(nil), param1, param2); end

  def on_send(node); end

  def valid_eval_receiver?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EVAL = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_FILE = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  def even_odd_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExactRegexpMatch
  def exact_regexp_match(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  def file_expand_path(param0=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(param0=T.unsafe(nil)); end

  def pathname_parent_expand_path(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  def on_yield(node); end

  def yielding_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
  def on_float(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FetchEnvVar
  def env_with_bracket?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileEmpty
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileRead
  def block_read?(param0=T.unsafe(nil)); end

  def file_open?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def send_read?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  READ_FILE_START_TO_FINISH_MODES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileWrite
  def block_write?(param0=T.unsafe(nil)); end

  def evidence(node); end

  def file_open?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def send_write?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TRUNCATING_WRITE_MODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  def any_coerce?(param0=T.unsafe(nil)); end

  def both_coerce?(param0=T.unsafe(nil)); end

  def left_coerce?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(param0=T.unsafe(nil)); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  def formatter(param0=T.unsafe(nil)); end

  def on_send(node); end

  def variable_argument?(param0=T.unsafe(nil)); end
  AUTOCORRECTABLE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatStringToken
  def format_string_in_typical_context?(param0=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  def const_to_gvar_assignment?(param0=T.unsafe(nil), param1); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  def on_hash(node); end
end

class RuboCop::Cop::Style::HashConversion
  def hash_from_array?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_LITERAL_HASH_ARG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL_MULTI_ARG = ::T.let(nil, ::T.untyped)
  MSG_SPLAT = ::T.let(nil, ::T.untyped)
  MSG_TO_H = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  def check_unused_block_args(node, key, value); end

  def each_arguments(param0=T.unsafe(nil)); end

  def kv_each(param0=T.unsafe(nil)); end

  def kv_each_with_block_pass(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_numblock(node); end
  ARRAY_CONVERTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNUSED_BLOCK_ARG_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashExcept
  def bad_method_with_active_support?(param0=T.unsafe(nil)); end

  def bad_method_with_poro?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
  def hash_like_case?(param0=T.unsafe(nil)); end

  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashTransformKeys
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_case_match(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  def on_if(node); end
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches
  def double_negative?(param0=T.unsafe(nil)); end

  def if_with_boolean_literal_branches?(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_ELSIF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  def on_normal_if_unless(node); end
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_NEWLINE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InPatternThen
  def on_in_pattern(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  def inverse_block?(param0=T.unsafe(nil)); end

  def inverse_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_numblock(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InvertibleUnlessCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  def on_kwoptarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  def on_block(node); end

  def on_numblock(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat
  KEBAB_SEPARATOR = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_VALUE = ::T.let(nil, ::T.untyped)
  SNAKE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat::CommentRange
  def comment(); end

  def directives(); end

  def initialize(comment); end

  def loc(); end

  def text(); end

  def values(); end
  DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  VALUE_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapCompactWithConditionalBlock
  def conditional_block(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapIntoArray
  def after_leaving_scope(scope, _variable_table); end

  def each_block_with_push?(param0=T.unsafe(nil)); end

  def empty_array_asgn?(param0=T.unsafe(nil)); end

  def lvar_ref?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToHash
  def map_to_h(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToSet
  def map_to_set?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  def on_csend(node); end

  def on_send(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  def on_block(node); end

  def on_csend(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  def min_max_candidate(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMaxComparison
  def on_if(node); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  GRATER_OPERATORS = ::T.let(nil, ::T.untyped)
  LESS_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
  def on_case(node); end

  def on_case_match(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
  def in_top_level_scope?(param0=T.unsafe(nil)); end

  def include_statement(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  def extend_self_node?(param0=T.unsafe(nil)); end

  def module_function_node?(param0=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(param0=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineInPatternThen
  def on_in_pattern(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  def message(_node); end

  def on_or_asgn(node); end
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG_IF = ::T.let(nil, ::T.untyped)
  MSG_SINGLE_LINE = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison_lhs?(param0=T.unsafe(nil)); end

  def simple_comparison_rhs?(param0=T.unsafe(nil)); end

  def simple_double_comparison?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
  def on_casgn(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(param0=T.unsafe(nil)); end

  def splat_value(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  def self.magic_comment_in_scope(node); end

  def self.recent_shareable_value?(node); end
end

class RuboCop::Cop::Style::NegatedIf
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  def double_negation?(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedUnless
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedWhile
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NestedFileDirname
  def file_dirname?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  def nil_check?(param0=T.unsafe(nil)); end

  def nil_comparison?(param0=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  def nil_return?(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  def nil_check?(param0=T.unsafe(nil)); end

  def not_and_nil_check?(param0=T.unsafe(nil)); end

  def not_equal_to_nil?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(param0=T.unsafe(nil)); end
  MSG_FOR_REDUNDANCY = ::T.let(nil, ::T.untyped)
  MSG_FOR_REPLACEMENT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParameters
  def on_numblock(node); end
  MSG_DISALLOW = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParametersLimit
  def max=(value); end

  def on_numblock(node); end
  DEFAULT_MAX_VALUE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  def min_digits=(value); end

  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  def comparison(param0=T.unsafe(nil)); end

  def inverted_comparison(param0=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ObjectThen
  def on_block(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OpenStructUse
  def on_const(node); end

  def uses_open_struct?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OperatorMethodCall
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(param0=T.unsafe(nil)); end

  def unless_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment
  def implicit_self_getter?(param0=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(param0, param1, param2); end

  def tsort_each_child(assignment); end

  def tsort_each_node(*arg, **arg1, &arg2); end

  def uses_var?(param0, param1); end

  def var_name(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, rhs, modifier, config, new_elements); end

  def node(); end

  def rescue_result(); end

  def rhs(); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  def control_op_condition(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentQLiterals
  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  def on_back_ref(node); end

  def on_gvar(node); end

  def on_nth_ref(node); end
  MESSAGE_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  def on_block(node); end

  def on_numblock(node); end

  def proc_new?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::QuotedSymbols
  def on_sym(node); end
  MSG_DOUBLE = ::T.let(nil, ::T.untyped)
  MSG_SINGLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  def integer_op_rand?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(param0=T.unsafe(nil)); end

  def rand_op_integer?(param0=T.unsafe(nil)); end

  def random_call(param0=T.unsafe(nil)); end

  def to_int(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NO_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArrayConstructor
  def on_send(node); end

  def redundant_array_constructor(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  def on_def(node); end

  def on_defs(node); end

  def redundant_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  def offensive_kwbegins(param0); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  def on_if(node); end
  ARGUMENT_WITH_OPERATOR_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  def on_if(node); end

  def redundant_condition?(param0=T.unsafe(nil)); end

  def redundant_condition_inverted?(param0=T.unsafe(nil)); end
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConstantBase
  def on_cbase(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCurrentDirectoryInPath
  def on_send(node); end
  CURRENT_DIRECTORY_PATH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantDoubleSplatHashBraces
  def on_hash(node); end
  MERGE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantEach
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  def compact?(param0=T.unsafe(nil)); end

  def exploded?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  def on_block(node); end

  def rails_cache?(param0=T.unsafe(nil)); end

  def redundant_fetch_block_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFilterChain
  def on_csend(node); end

  def on_send(node); end

  def select_predicate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RAILS_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  def on_send(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_OR_ESCAPED_CHARACTER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInitialize
  def initialize_forwards?(param0=T.unsafe(nil)); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolationUnfreeze
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantLineContinuation
  ALLOWED_STRING_TOKENS = ::T.let(nil, ::T.untyped)
  ARGUMENT_TAKING_FLOW_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantParentheses
  def allowed_pin_operator?(param0=T.unsafe(nil)); end

  def arg_in_call_with_block?(param0=T.unsafe(nil)); end

  def first_send_argument?(param0=T.unsafe(nil)); end

  def first_super_argument?(param0=T.unsafe(nil)); end

  def first_yield_argument?(param0=T.unsafe(nil)); end

  def interpolation?(param0=T.unsafe(nil)); end

  def method_node_and_args(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def rescue?(param0=T.unsafe(nil)); end

  def square_brackets?(param0=T.unsafe(nil)); end
  ALLOWED_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpArgument
  def on_csend(node); end

  def on_send(node); end
  DETERMINISTIC_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_SPECIAL_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  def on_regexp(node); end
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpConstructor
  def on_send(node); end

  def redundant_regexp_constructor(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  def on_regexp(node); end
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end

  def on_in_pattern(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end

  def on_until(node); end

  def on_while(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_send(node); end

  def redundant_nonself_assignment?(param0=T.unsafe(nil), param1, param2); end

  def redundant_self_assignment?(param0=T.unsafe(nil), param1); end
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch
  def bad_method?(param0=T.unsafe(nil)); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  def on_csend(node); end

  def on_send(node); end

  def redundant_sort?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  def on_block(node); end

  def on_numblock(node); end

  def redundant_sort_by_block(param0=T.unsafe(nil)); end

  def redundant_sort_by_numblock(param0=T.unsafe(nil)); end
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
  MSG_NUMBLOCK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantStringEscape
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RequireOrder
  def if_inside_only_require(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  def on_resbody(node); end

  def rescue_standard_error?(param0=T.unsafe(nil)); end

  def rescue_without_error_class?(param0=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(param0=T.unsafe(nil)); end

  def return_node?(param0=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNilInPredicateMethodDefinition
  def on_def(node); end

  def on_defs(node); end

  def return_nil?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  def modifier_if_safe_navigation_candidate(param0=T.unsafe(nil)); end

  def not_nil_check?(param0=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def ternary_safe_navigation_candidate(param0=T.unsafe(nil)); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  def on_csend(node); end

  def on_send(node); end

  def sample_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelectByRegexp
  def calls_lvar?(param0=T.unsafe(nil), param1); end

  def creates_hash?(param0=T.unsafe(nil)); end

  def env_const?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def regexp_match?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  REGEXP_METHODS = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SendWithLiteralMethodName
  def on_send(node); end
  METHOD_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STATIC_METHOD_NAME_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  def custom_fail_methods(param0); end

  def kernel_call?(param0=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  def on_send(node); end

  def single_argument_dig?(param0=T.unsafe(nil)); end
  IGNORED_ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineDoEndBlock
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  def on_send(node); end

  def range_from_zero?(param0=T.unsafe(nil)); end

  def range_from_zero_till_minus_one?(param0=T.unsafe(nil)); end

  def range_till_minus_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_USELESS_RANGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  def autocorrect(corrector, node, global_var); end

  def message(global_var); end

  def on_gvar(node); end
  BUILTIN_VARS = ::T.let(nil, ::T.untyped)
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
  STYLE_VARS_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
  def on_class(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  def on_send(node); end

  def stderr_puts?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringChars
  def on_csend(node); end

  def on_send(node); end
  BAD_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  def on_send(node); end

  def string_concatenation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  def on_pair(node); end

  def receive_environments_method?(param0=T.unsafe(nil)); end

  def string_hash_key?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  def autocorrect(corrector, node); end
end

class RuboCop::Cop::Style::StringMethods
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  def lstrip_rstrip(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SuperArguments
  def on_super(super_node); end
  ASSIGN_TYPES = ::T.let(nil, ::T.untyped)
  DEF_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SuperWithArgsParentheses
  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  def on_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  DELIMITERS = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
  REDEFINABLE_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_GVARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def on_numblock(node); end

  def proc_node?(param0=T.unsafe(nil)); end

  def symbol_proc?(param0=T.unsafe(nil)); end

  def symbol_proc_receiver?(param0=T.unsafe(nil)); end
  LAMBDA_OR_PROC = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  def method_name(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TopLevelMethodDefinition
  def define_method_block?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  def on_class(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  def looks_like_trivial_writer?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessLogicalOperators
  def and_with_or?(param0=T.unsafe(nil)); end

  def logical_operator?(param0=T.unsafe(nil)); end

  def on_if(node); end

  def or_with_and?(param0=T.unsafe(nil)); end
  FORBID_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
  FORBID_MIXED_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  def on_csend(node); end

  def on_send(node); end

  def unpack_and_first_element?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YAMLFileRead
  def on_send(node); end

  def yaml_file_read?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  def file_constant_equal_program_name?(param0=T.unsafe(nil)); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaExpression
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def non_polymorphic_collection?(param0=T.unsafe(nil)); end

  def nonzero_length_comparison(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def other_length_node(param0=T.unsafe(nil)); end

  def zero_length_comparison(param0=T.unsafe(nil)); end

  def zero_length_node(param0=T.unsafe(nil)); end

  def zero_length_predicate?(param0=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SymbolHelp
  def hash_key?(node); end
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def required_minimum_ruby_version(); end

  def support_target_ruby_version?(version); end
end

class RuboCop::Cop::Team
  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def initialize(cops, config=T.unsafe(nil), options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
end

class RuboCop::Cop::Team
  def self.forces_for(cops); end

  def self.mobilize(cop_classes, config, options=T.unsafe(nil)); end

  def self.mobilize_cops(cop_classes, config, options=T.unsafe(nil)); end

  def self.new(cop_or_classes, config, options=T.unsafe(nil)); end
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingComma
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::UnusedArgCorrector
  def self.correct(corrector, processed_source, node); end

  def self.correct_for_blockarg_type(corrector, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.add_parentheses(node, corrector); end

  def self.any_descendant?(node, *types); end

  def self.args_begin(node); end

  def self.args_end(node); end

  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.comment_lines?(node); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.indent(node, offset: T.unsafe(nil)); end

  def self.interpret_string_escapes(string); end

  def self.line(node_or_range); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.trim_string_interpolation_escape_character(str); end
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end

  def valid?(); end
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::RegexpRanges
  def compound_token(); end

  def initialize(root); end

  def pairs(); end

  def root(); end
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  PATTERN_MATCH_VARIABLE_TYPE = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  REST_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  def exception_assignment?(); end

  def for_assignment?(); end

  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def rest_assignment?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*arg); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.keyword_init?(); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::CaseMatch
  def else_body?(); end

  def in_pattern?(); end

  def target?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  def ensure_body?(); end

  def main_body?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
  def falsey_body?(); end

  def truthy_body?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  def loop_body?(); end
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

class RuboCop::Cop::VariableForce::Reference
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_conditional?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

module RuboCop::Cop::VisibilityHelp
  def visibility_block?(param0=T.unsafe(nil)); end

  def visibility_inline_on_def?(param0=T.unsafe(nil)); end

  def visibility_inline_on_method_name?(param0=T.unsafe(nil), method_name:); end
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::DirectiveComment
  def all_cops?(); end

  def comment(); end

  def cop_names(); end

  def cop_registry(); end

  def cops(); end

  def department_names(); end

  def directive_count(); end

  def disabled?(); end

  def disabled_all?(); end

  def enabled?(); end

  def enabled_all?(); end

  def in_directive_department?(cop); end

  def initialize(comment, cop_registry=T.unsafe(nil)); end

  def line_number(); end

  def match?(cop_names); end

  def match_captures(); end

  def mode(); end

  def overridden_by_department?(cop); end

  def range(); end

  def single_line?(); end
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  DIRECTIVE_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  LINT_DEPARTMENT = ::T.let(nil, ::T.untyped)
  LINT_REDUNDANT_DIRECTIVE_COP = ::T.let(nil, ::T.untyped)
  LINT_SYNTAX_COP = ::T.let(nil, ::T.untyped)
end

class RuboCop::DirectiveComment
  def self.before_comment(line); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

module RuboCop::ExcludeLimit
  def exclude_limit(parameter_name, method_name: T.unsafe(nil)); end
end

module RuboCop::Ext::Comment
  def source(); end

  def source_range(); end
end

module RuboCop::Ext::ProcessedSource
  def comment_config(); end

  def config(); end

  def config=(config); end

  def disabled_line_ranges(); end

  def registry(); end

  def registry=(registry); end
end

module RuboCop::Ext::Range
  def single_line?(); end
end

module RuboCop::Ext::RegexpNode
  def assign_properties(*arg); end

  def each_capture(named: T.unsafe(nil)); end

  def parsed_tree(); end
end

module RuboCop::Ext::RegexpParser::Expression::Base
  def expression(); end

  def loc(); end

  def origin(); end

  def origin=(origin); end
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
  def build_location(); end
end

class RuboCop::Ext::RegexpParser::Map
  def begin(); end

  def body(); end

  def end(); end

  def initialize(expression, body:, quantifier: T.unsafe(nil), begin_l: T.unsafe(nil), end_l: T.unsafe(nil)); end

  def quantifier(); end
end

class RuboCop::FeatureLoader
  def initialize(config_directory_path:, feature:); end

  def load(); end
end

class RuboCop::FeatureLoader
  def self.load(config_directory_path:, feature:); end
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end

  def find_last_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end
end

module RuboCop::FileFinder
  def self.root_level(); end

  def self.root_level=(root_level); end
end

class RuboCop::FilePatterns
  def initialize(patterns); end

  def match?(path); end
end

class RuboCop::FilePatterns
  def self.from(patterns); end
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, options); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  BUILTIN_FORMATTER_NAMES = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
  def finished(_inspected_files); end

  def started(_target_files); end
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  CSS_PATH = ::T.let(nil, ::T.untyped)
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::CSSContext
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlight_source_tag(offense); end

  def highlighted_source_line(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def render_css(); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::FileOffenses
  def offenses(); end

  def offenses=(_); end

  def path(); end

  def path=(_); end
end

class RuboCop::Formatter::HTMLFormatter::FileOffenses
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::Summary
  def inspected_files(); end

  def inspected_files=(_); end

  def offense_count(); end

  def offense_count=(_); end

  def target_files(); end

  def target_files=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Summary
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::JSONFormatter
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JUnitFormatter
  def finished(_inspected_files); end
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::JUnitFormatter::FailureElement
  def initialize(type:, message:, text:); end

  def message(); end

  def text(); end

  def type(); end
end

class RuboCop::Formatter::JUnitFormatter::TestCaseElement
  def classname(); end

  def failures(); end

  def initialize(classname:, name:); end

  def name(); end
end

class RuboCop::Formatter::MarkdownFormatter
  def files(); end

  def summary(); end
end

class RuboCop::Formatter::OffenseCountFormatter
  def cop_information(cop_name); end

  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts, offending_files_count); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::PacmanFormatter
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_autocorrect: T.unsafe(nil)); end

  def summary(); end
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::LSP::Logger
  def self.log(message); end
end

class RuboCop::LSP::Routes
  def for(name); end

  def handle_initialize(request); end

  def handle_initialized(_request); end

  def handle_method_missing(request); end

  def handle_shutdown(request); end

  def handle_unsupported_method(request, method=T.unsafe(nil)); end

  def initialize(server); end
end

class RuboCop::LSP::Runtime
  def format(path, text, command:); end

  def initialize(config_store); end

  def layout_mode=(layout_mode); end

  def lint_mode=(lint_mode); end

  def offenses(path, text); end

  def safe_autocorrect=(safe_autocorrect); end
end

class RuboCop::LSP::Server
  def configure(options); end

  def format(path, text, command:); end

  def initialize(config_store); end

  def offenses(path, text); end

  def start(); end

  def stop(&block); end

  def write(response); end
end

class RuboCop::LSP::Severity
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::LSP::Severity
  def self.find_by(rubocop_severity); end
end

module RuboCop::LSP
  def self.disable(&block); end

  def self.enable(); end

  def self.enabled?(); end
end

class RuboCop::Lockfile
  def dependencies(); end

  def gem_versions(include_transitive_dependencies: T.unsafe(nil)); end

  def gems(); end

  def includes_gem?(name); end

  def initialize(lockfile_path=T.unsafe(nil)); end
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def shareable_constant_value(); end

  def shareable_constant_value_specified?(); end

  def typed(); end

  def typed_specified?(); end

  def valid?(); end

  def valid_literal_value?(); end

  def valid_shareable_constant_value?(); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
  def encoding(); end

  def without(type); end
end

class RuboCop::MagicComment::EmacsComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end

  def without(type); end
  FSTRING_LITERAL_COMMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
  def extract_typed(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def self.find_similar_name(target_name, names); end

  def self.find_similar_names(target_name, names); end
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def disable_parallel_when_invalid_option_combo(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def invalid_arguments_for_parallel(); end

  def only_includes_redundant_disable?(); end

  def validate_auto_gen_config(); end

  def validate_autocorrect(); end

  def validate_cache_enabled_for_cache_root(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_display_only_correctable_and_autocorrect(); end

  def validate_display_only_failed(); end

  def validate_display_only_failed_and_display_only_correctable(); end

  def validate_exclude_limit_option(); end

  def validate_lsp_and_editor_mode(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
  HIDDEN_FILE_PATTERN = ::T.let(nil, ::T.untyped)
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.glob?(path); end

  def self.hidden_dir?(path); end

  def self.hidden_file?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.maybe_hidden_file?(path); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.relative_paths_cache(); end

  def self.relative_paths_cache=(relative_paths_cache); end

  def self.smart_path(path); end
end

module RuboCop::Platform
  def self.windows?(); end
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def debug?(); end

  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def path(); end

  def save(offenses); end

  def valid?(); end
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.rubocop_required_features(); end

  def self.rubocop_required_features=(rubocop_required_features); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
  REDUNDANT_COP_DISABLE_DIRECTIVE_RULES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  def offenses(); end
end

class RuboCop::Runner
  def self.ruby_extractors(); end
end

module RuboCop::SimpleForwardable
  def def_delegators(accessor, *methods); end
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

class RuboCop::TargetFinder
  def find(args, mode); end

  def find_files(base_dir, flags); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::GemspecFile
  def gem_requirement_versions(param0=T.unsafe(nil)); end

  def required_ruby_version(param0); end
  GEMSPEC_EXTENSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::ToolVersionsFile
  TOOL_VERSIONS_FILENAME = ::T.let(nil, ::T.untyped)
  TOOL_VERSIONS_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::Util
  def self.silence_warnings(); end
end

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  EXTENSION_PATH_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.document_version(); end

  def self.extension_versions(env); end

  def self.feature_version(feature); end

  def self.parser_version(); end

  def self.server_mode(); end

  def self.version(debug: T.unsafe(nil), env: T.unsafe(nil)); end
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

RubyLex = IRB::RubyLex

class RubyVM::AbstractSyntaxTree::Node
  def all_tokens(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(wait: T.unsafe(nil)); end

  def self.resume(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

ScanError = StringScanner::Error

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.base36(n=T.unsafe(nil)); end

  def self.base58(n=T.unsafe(nil)); end
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_CONNECTION_INFO = ::T.let(nil, ::T.untyped)
  TCP_KEEPALIVE = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_CONNECTION_INFO = ::T.let(nil, ::T.untyped)
  TCP_KEEPALIVE = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class String
  def dedup(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def set_encoding_by_bom(); end
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*arg); end

  def named_captures(); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct
  def self.new(*arg); end
end

class Symbol
  def ends_with?(*arg); end

  def starts_with?(*arg); end
end

class Symbol
  def self.from_msgpack_ext(data); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

class SyntaxSuggest::MiniStringIO
  def initialize(isatty: T.unsafe(nil)); end

  def isatty(); end

  def puts(value=T.unsafe(nil), **arg); end

  def string(); end
end

class SyntaxSuggest::MiniStringIO
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thor::Argument
  def enum_to_s(); end

  def print_default(); end
end

class Thor::Command
  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end
end

class Thor::CoreExt::HashWithIndifferentAccess
  def except(*keys); end

  def slice(*keys); end
end

class Thor::Group
  def self.command_exists?(command_name); end
end

class Thor::Option
  def aliases_for_usage(); end
end

class Thor::Options
  def check_at_least_one!(); end

  def check_exclusive!(); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def unshift(arg, is_value: T.unsafe(nil)); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
end

module Thor::Shell
  def say_error(*args, &block); end
end

class Thor::UndefinedCommandError
  include ::Thor::Correctable
end

class Thor::UnknownArgumentError
  include ::Thor::Correctable
end

class Thor
  def self.at_least_one(*args, &block); end

  def self.command_exists?(command_name); end

  def self.exclusive(*args, &block); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.sort_commands!(list); end
end

class Thread
  def active_support_execution_state(); end

  def active_support_execution_state=(active_support_execution_state); end
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Time
  def deconstruct_keys(arg); end
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

module Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module URI
  include ::URI::RFC2396_REGEXP
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::GID
  COMPONENT = ::T.let(nil, ::T.untyped)
  COMPOSITE_MODEL_ID_DELIMITER = ::T.let(nil, ::T.untyped)
  COMPOSITE_MODEL_ID_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class URI::Generic
  def decoded_password(); end

  def decoded_user(); end
end

class URI::HTTP
  def authority(); end

  def origin(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::WSS
end

module URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.register_scheme(scheme, klass); end
end

class Unicode::DisplayWidth
  def get_config(**kwargs); end

  def initialize(ambiguous: T.unsafe(nil), overwrite: T.unsafe(nil), emoji: T.unsafe(nil)); end

  def of(string, **kwargs); end
  ASCII_NON_ZERO_REGEX = ::T.let(nil, ::T.untyped)
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  FIRST_4096 = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  INITIAL_DEPTH = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Unicode::DisplayWidth
  def self.decompress_index(index, level); end

  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.width_all_features(string, ambiguous, overwrite, options); end

  def self.width_no_overwrite(string, ambiguous, options=T.unsafe(nil)); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver
  def add_extension(extension); end

  def binary(message); end

  def close(reason=T.unsafe(nil), code=T.unsafe(nil)); end

  def initialize(socket, options=T.unsafe(nil)); end

  def ping(*args); end

  def pong(*args); end

  def protocol(); end

  def ready_state(); end

  def set_header(name, value); end

  def start(); end

  def state(); end

  def text(message); end
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  PORTS = ::T.let(nil, ::T.untyped)
  STATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def headers(); end

  def proxy(origin, options=T.unsafe(nil)); end

  def status(); end
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def self.generate_key(); end
end

class WebSocket::Driver::CloseEvent
  def code(); end

  def code=(_); end

  def reason(); end

  def reason=(_); end
end

class WebSocket::Driver::CloseEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::ConnectEvent
end

class WebSocket::Driver::ConnectEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::Draft75
  def frame(buffer, type=T.unsafe(nil), error_type=T.unsafe(nil)); end

  def parse(chunk); end

  def version(); end
end

class WebSocket::Driver::Draft75
end

class WebSocket::Driver::Draft76
  BODY_SIZE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Draft76
end

module WebSocket::Driver::EventEmitter
  def add_listener(event, callable=T.unsafe(nil), &block); end

  def emit(event, *args); end

  def initialize(); end

  def listener_count(event); end

  def listeners(event); end

  def on(event, callable=T.unsafe(nil), &block); end

  def remove_all_listeners(event=T.unsafe(nil)); end

  def remove_listener(event, callable=T.unsafe(nil), &block); end
end

class WebSocket::Driver::Headers
  def [](name); end

  def []=(name, value); end

  def clear(); end

  def initialize(received=T.unsafe(nil)); end

  def to_h(); end
  ALLOWED_DUPLICATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Headers
end

class WebSocket::Driver::Hybi
  def frame(buffer, type=T.unsafe(nil), code=T.unsafe(nil)); end

  def parse(chunk); end

  def ping(message=T.unsafe(nil), &callback); end

  def pong(message=T.unsafe(nil)); end

  def version(); end
  BYTE = ::T.let(nil, ::T.untyped)
  DEFAULT_ERROR_CODE = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
  ERROR_CODES = ::T.let(nil, ::T.untyped)
  FIN = ::T.let(nil, ::T.untyped)
  GUID = ::T.let(nil, ::T.untyped)
  LENGTH = ::T.let(nil, ::T.untyped)
  MASK = ::T.let(nil, ::T.untyped)
  MAX_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
  MIN_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  OPCODE = ::T.let(nil, ::T.untyped)
  OPCODES = ::T.let(nil, ::T.untyped)
  OPCODE_CODES = ::T.let(nil, ::T.untyped)
  OPENING_OPCODES = ::T.let(nil, ::T.untyped)
  PACK_FORMATS = ::T.let(nil, ::T.untyped)
  RSV1 = ::T.let(nil, ::T.untyped)
  RSV2 = ::T.let(nil, ::T.untyped)
  RSV3 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Hybi::Frame
  def final(); end

  def final=(final); end

  def length(); end

  def length=(length); end

  def length_bytes(); end

  def length_bytes=(length_bytes); end

  def masked(); end

  def masked=(masked); end

  def masking_key(); end

  def masking_key=(masking_key); end

  def opcode(); end

  def opcode=(opcode); end

  def payload(); end

  def payload=(payload); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Frame
end

class WebSocket::Driver::Hybi::Message
  def <<(frame); end

  def data(); end

  def data=(data); end

  def opcode(); end

  def opcode=(opcode); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Message
end

class WebSocket::Driver::Hybi
  def self.generate_accept(key); end
end

class WebSocket::Driver::MessageEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::MessageEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::OpenEvent
end

class WebSocket::Driver::OpenEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::PingEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PingEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::PongEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PongEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::Proxy
  include ::WebSocket::Driver::EventEmitter
  def headers(); end

  def initialize(client, origin, options); end

  def parse(chunk); end

  def set_header(name, value); end

  def start(); end

  def status(); end
end

class WebSocket::Driver::Proxy
end

class WebSocket::Driver::Server
  def add_extension(*args, &block); end

  def binary(*args, &block); end

  def close(*args, &block); end

  def env(); end

  def frame(*args, &block); end

  def parse(chunk); end

  def ping(*args, &block); end

  def set_header(*args, &block); end

  def start(*args, &block); end

  def text(*args, &block); end

  def url(); end

  def version(); end

  def write(buffer); end
  EVENTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Server
end

class WebSocket::Driver::StreamReader
  def each_byte(); end

  def put(chunk); end

  def read(length); end
  MINIMUM_AUTOMATIC_PRUNE_OFFSET = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::StreamReader
end

class WebSocket::Driver
  def self.client(socket, options=T.unsafe(nil)); end

  def self.encode(data, encoding=T.unsafe(nil)); end

  def self.host_header(uri); end

  def self.rack(socket, options=T.unsafe(nil)); end

  def self.server(socket, options=T.unsafe(nil)); end

  def self.validate_options(options, valid_keys); end

  def self.websocket?(env); end
end

class WebSocket::Extensions
  def activate(header); end

  def add(ext); end

  def close(); end

  def generate_offer(); end

  def generate_response(header); end

  def process_incoming_message(message); end

  def process_outgoing_message(message); end

  def valid_frame_rsv(frame); end

  def valid_frame_rsv?(frame); end
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser
  EXT = ::T.let(nil, ::T.untyped)
  EXT_LIST = ::T.let(nil, ::T.untyped)
  NOTOKEN = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PARAM = ::T.let(nil, ::T.untyped)
  QUOTED = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser
  def self.parse_header(header); end

  def self.serialize_params(name, params); end
end

module WebSocket::HTTP
end

module WebSocket::HTTP::Headers
  def complete?(); end

  def error?(); end

  def headers(); end

  def initialize(); end

  def parse(chunk); end
  CR = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  MAX_LINE_LENGTH = ::T.let(nil, ::T.untyped)
end

module WebSocket::HTTP::Headers
end

class WebSocket::HTTP::Request
  include ::WebSocket::HTTP::Headers
  def env(); end
  REQUEST_LINE = ::T.let(nil, ::T.untyped)
  REQUEST_TARGET = ::T.let(nil, ::T.untyped)
  RESERVED_HEADERS = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Request
end

class WebSocket::HTTP::Response
  include ::WebSocket::HTTP::Headers
  def [](name); end

  def body(); end

  def code(); end
  STATUS_LINE = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Response
end

module WebSocket::HTTP
  def self.normalize_header(name); end
end

module WebSocket::Mask
end

module WebSocket::Mask
  def self.mask(arg, arg1); end
end

module Zeitwerk
  VERSION = ::T.let(nil, ::T.untyped)
end

class Zeitwerk::Cref
  def autoload(abspath); end

  def autoload?(); end

  def cname(); end

  def defined?(); end

  def get(); end

  def initialize(mod, cname); end

  def path(); end

  def remove(); end

  def set(value); end
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
  def self.__register(cpath, loader); end

  def self.__registered?(cpath); end

  def self.__unregister_loader(loader); end
end

class Zeitwerk::GemInflector
  def camelize(basename, abspath); end

  def initialize(root_file); end
end

class Zeitwerk::GemLoader
  def initialize(root_file, namespace:, warn_on_extra_files:); end
end

class Zeitwerk::GemLoader
  def self.__new(root_file, namespace:, warn_on_extra_files:); end
end

class Zeitwerk::Inflector
  def camelize(basename, _abspath); end

  def inflect(inflections); end
end

module Zeitwerk::Internal
  def internal(method_name); end
end

class Zeitwerk::Loader
  def __autoloaded_dirs(); end

  def __autoloads(); end

  def __namespace_dirs(); end

  def __shadowed_file?(file); end

  def __shadowed_files(); end

  def __to_unload(); end

  def all_expected_cpaths(); end

  def cpath_expected_at(path); end

  def reload(); end

  def setup(); end

  def unload(); end

  def unloadable_cpath?(cpath); end

  def unloadable_cpaths(); end

  def unregister(); end
end

module Zeitwerk::Loader::Callbacks
  def __on_dir_autoloaded(dir); end

  def __on_file_autoloaded(file); end

  def on_namespace_loaded(namespace); end
end

module Zeitwerk::Loader::Config
  def __ignores?(abspath); end

  def __roots(); end

  def collapse(*glob_patterns); end

  def dirs(namespaces: T.unsafe(nil), ignored: T.unsafe(nil)); end

  def do_not_eager_load(*paths); end

  def enable_reloading(); end

  def ignore(*glob_patterns); end

  def inflector(); end

  def inflector=(inflector); end

  def initialize(); end

  def log!(); end

  def logger(); end

  def logger=(logger); end

  def on_load(cpath=T.unsafe(nil), &block); end

  def on_setup(&block); end

  def on_unload(cpath=T.unsafe(nil), &block); end

  def push_dir(path, namespace: T.unsafe(nil)); end

  def reloading_enabled?(); end

  def tag(); end

  def tag=(tag); end
end

module Zeitwerk::Loader::EagerLoad
  def eager_load(force: T.unsafe(nil)); end

  def eager_load_dir(path); end

  def eager_load_namespace(mod); end

  def load_file(path); end
end

class Zeitwerk::Loader
  extend ::Zeitwerk::RealModName
  def self.all_dirs(); end

  def self.default_logger(); end

  def self.default_logger=(default_logger); end

  def self.eager_load_all(); end

  def self.eager_load_namespace(mod); end

  def self.for_gem(warn_on_extra_files: T.unsafe(nil)); end

  def self.for_gem_extension(namespace); end
end

class Zeitwerk::NullInflector
  def camelize(basename, _abspath); end
end

module Zeitwerk::RealModName
  def real_mod_name(mod); end
end

module Zeitwerk::Registry
  def self.autoloads(); end

  def self.gem_loaders_by_root_file(); end

  def self.inception?(cpath, registered_by_loader=T.unsafe(nil)); end

  def self.inceptions(); end

  def self.loader_for(path); end

  def self.loader_for_gem(root_file, namespace:, warn_on_extra_files:); end

  def self.loaders(); end

  def self.on_unload(loader); end

  def self.register_autoload(loader, abspath); end

  def self.register_inception(cpath, abspath, loader); end

  def self.register_loader(loader); end

  def self.unregister_autoload(abspath); end

  def self.unregister_loader(loader); end
end

class Zeitwerk::ReloadingDisabledError
  def initialize(); end
end

class Zeitwerk::SetupRequired
  def initialize(); end
end

module Zeitwerk
  def self.with_loader(); end
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
